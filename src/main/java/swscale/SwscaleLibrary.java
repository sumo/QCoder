package swscale;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;

import com.ochafik.lang.jnaerator.runtime.LibraryExtractor;
import com.ochafik.lang.jnaerator.runtime.Mangling;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.NativeLong;
import com.sun.jna.Pointer;
import com.sun.jna.ptr.DoubleByReference;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;
/**
 * JNA Wrapper for library <b>swscale</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.free.fr/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface SwscaleLibrary extends Library {
	public static final String JNA_LIBRARY_NAME = LibraryExtractor.getLibraryPath("swscale", true, swscale.SwscaleLibrary.class);
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(swscale.SwscaleLibrary.JNA_LIBRARY_NAME, com.ochafik.lang.jnaerator.runtime.MangledFunctionMapper.DEFAULT_OPTIONS);
	public static final SwscaleLibrary INSTANCE = (SwscaleLibrary)Native.loadLibrary(swscale.SwscaleLibrary.JNA_LIBRARY_NAME, swscale.SwscaleLibrary.class, com.ochafik.lang.jnaerator.runtime.MangledFunctionMapper.DEFAULT_OPTIONS);
	/**
	 * <i>native declaration : src/main/headers/libavutil/avutil.h:71</i><br>
	 * enum values
	 */
	public static interface AVMediaType {
		/// <i>native declaration : src/main/headers/libavutil/avutil.h:72</i>
		public static final int AVMEDIA_TYPE_UNKNOWN = -1;
		/// <i>native declaration : src/main/headers/libavutil/avutil.h:73</i>
		public static final int AVMEDIA_TYPE_VIDEO = 0;
		/// <i>native declaration : src/main/headers/libavutil/avutil.h:74</i>
		public static final int AVMEDIA_TYPE_AUDIO = 1;
		/// <i>native declaration : src/main/headers/libavutil/avutil.h:75</i>
		public static final int AVMEDIA_TYPE_DATA = 2;
		/// <i>native declaration : src/main/headers/libavutil/avutil.h:76</i>
		public static final int AVMEDIA_TYPE_SUBTITLE = 3;
		/// <i>native declaration : src/main/headers/libavutil/avutil.h:77</i>
		public static final int AVMEDIA_TYPE_ATTACHMENT = 4;
		/// <i>native declaration : src/main/headers/libavutil/avutil.h:78</i>
		public static final int AVMEDIA_TYPE_NB = 5;
	};
	/**
	 * Conversion Error : a.num<br>
	 * SKIPPED:<br>
	 * <i>native declaration : src/main/headers/libavutil/rational.h</i><br>
	 * const int64_t tmp = a.num * (int64_t)b.den - b.num * (int64_t)a.den;
	 */
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int SWS_BITEXACT = 524288;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int SWS_AREA = 32;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int SWS_CPU_CAPS_MMX = -2147483648;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int SWS_SINC = 256;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int SWS_GAUSS = 128;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int SWS_CS_FCC = 4;
	/// <i>native declaration : src/main/headers/libavutil/avutil.h</i>
	public static final int LIBAVUTIL_VERSION_MICRO = 1;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int SWS_BICUBLIN = 64;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final String LIBSWSCALE_IDENT = "SwS";
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int SWS_SPLINE = 1024;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int SWS_DIRECT_BGR = 32768;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int SWS_CS_ITU624 = 5;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int SWS_CPU_CAPS_ALTIVEC = 268435456;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int SWS_PRINT_INFO = 4096;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int SWS_SRC_V_CHR_DROP_SHIFT = 16;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int SWS_POINT = 16;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final double SWS_MAX_REDUCE_CUTOFF = 0.0020;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int SWS_CS_SMPTE240M = 7;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int SWS_X = 8;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int SWS_CS_ITU601 = 5;
	/// <i>native declaration : src/main/headers/libavutil/avutil.h</i>
	public static final int LIBAVUTIL_VERSION_MAJOR = 50;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int SWS_CS_DEFAULT = 5;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int SWS_CS_SMPTE170M = 5;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int SWS_FAST_BILINEAR = 1;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int SWS_ACCURATE_RND = 262144;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int SWS_FULL_CHR_H_INP = 16384;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int SWS_FULL_CHR_H_INT = 8192;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int SWS_LANCZOS = 512;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int LIBSWSCALE_VERSION_MAJOR = 1;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int SWS_BICUBIC = 4;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int SWS_SRC_V_CHR_DROP_MASK = 196608;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int SWS_CPU_CAPS_3DNOW = 1073741824;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int SWS_CPU_CAPS_MMX2 = 536870912;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int SWS_CS_ITU709 = 1;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int LIBSWSCALE_VERSION_MICRO = 0;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int SWS_CPU_CAPS_BFIN = 16777216;
	/// <i>native declaration : src/main/headers/libavutil/avutil.h</i>
	public static final int LIBAVUTIL_VERSION_MINOR = 15;
	/// <i>native declaration : src/main/headers/libavutil/avutil.h</i>
	public static final String LIBAVUTIL_IDENT = "Lavu";
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int LIBSWSCALE_VERSION_MINOR = 11;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int SWS_BILINEAR = 2;
	/// <i>native declaration : src/main/headers/libswscale/swscale.h</i>
	public static final int SWS_PARAM_DEFAULT = 123456;
	/**
	 * Returns the LIBAVUTIL_VERSION_INT constant.<br>
	 * Original signature : <code>avutil_version()</code><br>
	 * <i>native declaration : src/main/headers/libavutil/avutil.h:59</i>
	 */
	@Mangling({"_Z14avutil_versionv", "?avutil_version@@YAXXZ"}) 
	int avutil_version();
	/**
	 * Returns the libavutil build-time configuration.<br>
	 * Original signature : <code>char* avutil_configuration()</code><br>
	 * <i>native declaration : src/main/headers/libavutil/avutil.h:64</i>
	 */
	@Mangling({"_Z20avutil_configurationv", "?avutil_configuration@@YAQBDXZ"}) 
	String avutil_configuration();
	/**
	 * Returns the libavutil license.<br>
	 * Original signature : <code>char* avutil_license()</code><br>
	 * <i>native declaration : src/main/headers/libavutil/avutil.h:69</i>
	 */
	@Mangling({"_Z14avutil_licensev", "?avutil_license@@YAQBDXZ"}) 
	String avutil_license();
	/**
	 * Returns the LIBSWSCALE_VERSION_INT constant.<br>
	 * Original signature : <code>swscale_version()</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:48</i>
	 */
	@Mangling({"_Z15swscale_versionv", "?swscale_version@@YAXXZ"}) 
	int swscale_version();
	/**
	 * Returns the libswscale build-time configuration.<br>
	 * Original signature : <code>char* swscale_configuration()</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:53</i>
	 */
	@Mangling({"_Z21swscale_configurationv", "?swscale_configuration@@YAQBDXZ"}) 
	String swscale_configuration();
	/**
	 * Returns the libswscale license.<br>
	 * Original signature : <code>char* swscale_license()</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:58</i>
	 */
	@Mangling({"_Z15swscale_licensev", "?swscale_license@@YAQBDXZ"}) 
	String swscale_license();
	/**
	 * Returns a pointer to yuv<->rgb coefficients for the given colorspace<br>
	 * suitable for sws_setColorspaceDetails().<br>
	 * * @param colorspace One of the SWS_CS_* macros. If invalid,<br>
	 * SWS_CS_DEFAULT is used.<br>
	 * Original signature : <code>int* sws_getCoefficients(int)</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:112</i>
	 */
	@Mangling({"_Z19sws_getCoefficientsi", "?sws_getCoefficients@@YAQBHH@Z"}) 
	IntByReference sws_getCoefficients(int colorspace);
	/**
	 * Returns a positive value if pix_fmt is a supported input format, 0<br>
	 * otherwise.<br>
	 * Original signature : <code>int sws_isSupportedInput(PixelFormat)</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:136</i><br>
	 * @param pix_fmt @see PixelFormat
	 */
	@Mangling({"_Z20sws_isSupportedInput11PixelFormat", "?sws_isSupportedInput@@YAH11PixelFormat@Z"}) 
	int sws_isSupportedInput(int pix_fmt);
	/**
	 * Returns a positive value if pix_fmt is a supported output format, 0<br>
	 * otherwise.<br>
	 * Original signature : <code>int sws_isSupportedOutput(PixelFormat)</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:142</i><br>
	 * @param pix_fmt @see PixelFormat
	 */
	@Mangling({"_Z21sws_isSupportedOutput11PixelFormat", "?sws_isSupportedOutput@@YAH11PixelFormat@Z"}) 
	int sws_isSupportedOutput(int pix_fmt);
	/**
	 * Frees the swscaler context swsContext.<br>
	 * If swsContext is NULL, then does nothing.<br>
	 * Original signature : <code>void sws_freeContext(SwsContext*)</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:148</i>
	 */
	@Mangling({"_Z15sws_freeContextP10SwsContext", "?sws_freeContext@@YAXPA10SwsContext@Z"}) 
	void sws_freeContext(Pointer swsContext);
	/**
	 * Allocates and returns a SwsContext. You need it to perform<br>
	 * scaling/conversion operations using sws_scale().<br>
	 * * @param srcW the width of the source image<br>
	 * @param srcH the height of the source image<br>
	 * @param srcFormat the source image format<br>
	 * @param dstW the width of the destination image<br>
	 * @param dstH the height of the destination image<br>
	 * @param dstFormat the destination image format<br>
	 * @param flags specify which algorithm and options to use for rescaling<br>
	 * @return a pointer to an allocated context, or NULL in case of error<br>
	 * Original signature : <code>SwsContext* sws_getContext(int, int, PixelFormat, int, int, PixelFormat, int, SwsFilter*, SwsFilter*, const double*)</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:163</i><br>
	 * @deprecated use the safer methods {@link #sws_getContext(int, int, int, int, int, int, int, swscale.SwsFilter, swscale.SwsFilter, double[])} and {@link #sws_getContext(int, int, int, int, int, int, int, swscale.SwsFilter, swscale.SwsFilter, com.sun.jna.ptr.DoubleByReference)} instead<br>
	 * @param srcFormat @see PixelFormat<br>
	 * @param dstFormat @see PixelFormat
	 */
	@Mangling({"_Z14sws_getContextii11PixelFormatii11PixelFormatiP9SwsFilterP9SwsFilterPKd", "?sws_getContext@@YAPA10SwsContextHH11PixelFormatHH11PixelFormatHPAUSwsFilter@@PAUSwsFilter@@PAN@Z"}) 
	@Deprecated 
	Pointer sws_getContext(int srcW, int srcH, int srcFormat, int dstW, int dstH, int dstFormat, int flags, SwsFilter srcFilter, SwsFilter dstFilter, DoubleByReference param);
	/**
	 * Allocates and returns a SwsContext. You need it to perform<br>
	 * scaling/conversion operations using sws_scale().<br>
	 * * @param srcW the width of the source image<br>
	 * @param srcH the height of the source image<br>
	 * @param srcFormat the source image format<br>
	 * @param dstW the width of the destination image<br>
	 * @param dstH the height of the destination image<br>
	 * @param dstFormat the destination image format<br>
	 * @param flags specify which algorithm and options to use for rescaling<br>
	 * @return a pointer to an allocated context, or NULL in case of error<br>
	 * Original signature : <code>SwsContext* sws_getContext(int, int, PixelFormat, int, int, PixelFormat, int, SwsFilter*, SwsFilter*, const double*)</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:163</i><br>
	 * @param srcFormat @see PixelFormat<br>
	 * @param dstFormat @see PixelFormat
	 */
	@Mangling({"_Z14sws_getContextii11PixelFormatii11PixelFormatiP9SwsFilterP9SwsFilterPKd", "?sws_getContext@@YAPA10SwsContextHH11PixelFormatHH11PixelFormatHPAUSwsFilter@@PAUSwsFilter@@PAN@Z"}) 
	Pointer sws_getContext(int srcW, int srcH, int srcFormat, int dstW, int dstH, int dstFormat, int flags, SwsFilter srcFilter, SwsFilter dstFilter, double param[]);
	/**
	 * Scales the image slice in srcSlice and puts the resulting scaled<br>
	 * slice in the image in dst. A slice is a sequence of consecutive<br>
	 * rows in an image.<br>
	 * * Slices have to be provided in sequential order, either in<br>
	 * top-bottom or bottom-top order. If slices are provided in<br>
	 * non-sequential order the behavior of the function is undefined.<br>
	 * * @param context   the scaling context previously created with<br>
	 *                  sws_getContext()<br>
	 * @param srcSlice  the array containing the pointers to the planes of<br>
	 *                  the source slice<br>
	 * @param srcStride the array containing the strides for each plane of<br>
	 *                  the source image<br>
	 * @param srcSliceY the position in the source image of the slice to<br>
	 *                  process, that is the number (counted starting from<br>
	 *                  zero) in the image of the first row of the slice<br>
	 * @param srcSliceH the height of the source slice, that is the number<br>
	 *                  of rows in the slice<br>
	 * @param dst       the array containing the pointers to the planes of<br>
	 *                  the destination image<br>
	 * @param dstStride the array containing the strides for each plane of<br>
	 *                  the destination image<br>
	 * @return          the height of the output slice<br>
	 * Original signature : <code>int sws_scale(SwsContext*, const uint8_t*[], const int[], int, int, uint8_t*[], const int[])</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:194</i><br>
	 * @deprecated use the safer methods {@link #sws_scale(com.sun.jna.Pointer, com.sun.jna.ptr.PointerByReference, int[], int, int, com.sun.jna.ptr.PointerByReference, int[])} and {@link #sws_scale(com.sun.jna.Pointer, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference, int, int, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Mangling({"_Z9sws_scaleP10SwsContextPPK7uint8_tPKiiiPP7uint8_tPKi", "?sws_scale@@YAHPA10SwsContextQAPA7uint8_tQAHHHQAPA7uint8_tQAH@Z"}) 
	@Deprecated 
	int sws_scale(Pointer context, PointerByReference srcSlice, IntByReference srcStride, int srcSliceY, int srcSliceH, PointerByReference dst, IntByReference dstStride);
	/**
	 * Scales the image slice in srcSlice and puts the resulting scaled<br>
	 * slice in the image in dst. A slice is a sequence of consecutive<br>
	 * rows in an image.<br>
	 * * Slices have to be provided in sequential order, either in<br>
	 * top-bottom or bottom-top order. If slices are provided in<br>
	 * non-sequential order the behavior of the function is undefined.<br>
	 * * @param context   the scaling context previously created with<br>
	 *                  sws_getContext()<br>
	 * @param srcSlice  the array containing the pointers to the planes of<br>
	 *                  the source slice<br>
	 * @param srcStride the array containing the strides for each plane of<br>
	 *                  the source image<br>
	 * @param srcSliceY the position in the source image of the slice to<br>
	 *                  process, that is the number (counted starting from<br>
	 *                  zero) in the image of the first row of the slice<br>
	 * @param srcSliceH the height of the source slice, that is the number<br>
	 *                  of rows in the slice<br>
	 * @param dst       the array containing the pointers to the planes of<br>
	 *                  the destination image<br>
	 * @param dstStride the array containing the strides for each plane of<br>
	 *                  the destination image<br>
	 * @return          the height of the output slice<br>
	 * Original signature : <code>int sws_scale(SwsContext*, const uint8_t*[], const int[], int, int, uint8_t*[], const int[])</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:194</i>
	 */
	@Mangling({"_Z9sws_scaleP10SwsContextPPK7uint8_tPKiiiPP7uint8_tPKi", "?sws_scale@@YAHPA10SwsContextQAPA7uint8_tQAHHHQAPA7uint8_tQAH@Z"}) 
	int sws_scale(Pointer context, PointerByReference srcSlice, int srcStride[], int srcSliceY, int srcSliceH, PointerByReference dst, int dstStride[]);
	/**
	 * @param inv_table the yuv2rgb coefficients, normally ff_yuv2rgb_coeffs[x]<br>
	 * @param fullRange if 1 then the luma range is 0..255 if 0 it is 16..235<br>
	 * @return -1 if not supported<br>
	 * Original signature : <code>int sws_setColorspaceDetails(SwsContext*, const int[4], int, const int[4], int, int, int, int)</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:210</i><br>
	 * @deprecated use the safer methods {@link #sws_setColorspaceDetails(com.sun.jna.Pointer, int[], int, int[], int, int, int, int)} and {@link #sws_setColorspaceDetails(com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference, int, com.sun.jna.ptr.IntByReference, int, int, int, int)} instead
	 */
	@Mangling({"_Z24sws_setColorspaceDetailsP10SwsContextPKiiPKiiiii", "?sws_setColorspaceDetails@@YAHPA10SwsContextQAHHQAHHHHH@Z"}) 
	@Deprecated 
	int sws_setColorspaceDetails(Pointer c, IntByReference inv_table, int srcRange, IntByReference table, int dstRange, int brightness, int contrast, int saturation);
	/**
	 * @param inv_table the yuv2rgb coefficients, normally ff_yuv2rgb_coeffs[x]<br>
	 * @param fullRange if 1 then the luma range is 0..255 if 0 it is 16..235<br>
	 * @return -1 if not supported<br>
	 * Original signature : <code>int sws_setColorspaceDetails(SwsContext*, const int[4], int, const int[4], int, int, int, int)</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:210</i>
	 */
	@Mangling({"_Z24sws_setColorspaceDetailsP10SwsContextPKiiPKiiiii", "?sws_setColorspaceDetails@@YAHPA10SwsContextQAHHQAHHHHH@Z"}) 
	int sws_setColorspaceDetails(Pointer c, int inv_table[], int srcRange, int table[], int dstRange, int brightness, int contrast, int saturation);
	/**
	 * @return -1 if not supported<br>
	 * Original signature : <code>int sws_getColorspaceDetails(SwsContext*, int**, int*, int**, int*, int*, int*, int*)</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:217</i><br>
	 * @deprecated use the safer methods {@link #sws_getColorspaceDetails(com.sun.jna.Pointer, com.sun.jna.ptr.PointerByReference, java.nio.IntBuffer, com.sun.jna.ptr.PointerByReference, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #sws_getColorspaceDetails(com.sun.jna.Pointer, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Mangling({"_Z24sws_getColorspaceDetailsP10SwsContextPPiPiPPiPiPiPiPi", "?sws_getColorspaceDetails@@YAHPA10SwsContextPAPAHPAHPAPAHPAHPAHPAHPAH@Z"}) 
	@Deprecated 
	int sws_getColorspaceDetails(Pointer c, PointerByReference inv_table, IntByReference srcRange, PointerByReference table, IntByReference dstRange, IntByReference brightness, IntByReference contrast, IntByReference saturation);
	/**
	 * @return -1 if not supported<br>
	 * Original signature : <code>int sws_getColorspaceDetails(SwsContext*, int**, int*, int**, int*, int*, int*, int*)</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:217</i>
	 */
	@Mangling({"_Z24sws_getColorspaceDetailsP10SwsContextPPiPiPPiPiPiPiPi", "?sws_getColorspaceDetails@@YAHPA10SwsContextPAPAHPAHPAPAHPAHPAHPAHPAH@Z"}) 
	int sws_getColorspaceDetails(Pointer c, PointerByReference inv_table, IntBuffer srcRange, PointerByReference table, IntBuffer dstRange, IntBuffer brightness, IntBuffer contrast, IntBuffer saturation);
	/**
	 * Allocates and returns an uninitialized vector with length coefficients.<br>
	 * Original signature : <code>SwsVector* sws_allocVec(int)</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:224</i>
	 */
	@Mangling({"_Z12sws_allocVeci", "?sws_allocVec@@YAPAUSwsVector@@H@Z"}) 
	SwsVector sws_allocVec(int length);
	/**
	 * Returns a normalized Gaussian curve used to filter stuff<br>
	 * quality=3 is high quality, lower is lower quality.<br>
	 * Original signature : <code>SwsVector* sws_getGaussianVec(double, double)</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:230</i>
	 */
	@Mangling({"_Z18sws_getGaussianVecdd", "?sws_getGaussianVec@@YAPAUSwsVector@@NN@Z"}) 
	SwsVector sws_getGaussianVec(double variance, double quality);
	/**
	 * Allocates and returns a vector with length coefficients, all<br>
	 * with the same value c.<br>
	 * Original signature : <code>SwsVector* sws_getConstVec(double, int)</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:236</i>
	 */
	@Mangling({"_Z15sws_getConstVecdi", "?sws_getConstVec@@YAPAUSwsVector@@NH@Z"}) 
	SwsVector sws_getConstVec(double c, int length);
	/**
	 * Allocates and returns a vector with just one coefficient, with<br>
	 * value 1.0.<br>
	 * Original signature : <code>SwsVector* sws_getIdentityVec()</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:242</i>
	 */
	@Mangling({"_Z18sws_getIdentityVecv", "?sws_getIdentityVec@@YAPAUSwsVector@@XZ"}) 
	SwsVector sws_getIdentityVec();
	/**
	 * Scales all the coefficients of a by the scalar value.<br>
	 * Original signature : <code>void sws_scaleVec(SwsVector*, double)</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:247</i>
	 */
	@Mangling({"_Z12sws_scaleVecP9SwsVectord", "?sws_scaleVec@@YAXPAUSwsVector@@N@Z"}) 
	void sws_scaleVec(SwsVector a, double scalar);
	/**
	 * Scales all the coefficients of a so that their sum equals height.<br>
	 * Original signature : <code>void sws_normalizeVec(SwsVector*, double)</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:252</i>
	 */
	@Mangling({"_Z16sws_normalizeVecP9SwsVectord", "?sws_normalizeVec@@YAXPAUSwsVector@@N@Z"}) 
	void sws_normalizeVec(SwsVector a, double height);
	/**
	 * Original signature : <code>void sws_convVec(SwsVector*, SwsVector*)</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:253</i>
	 */
	@Mangling({"_Z11sws_convVecP9SwsVectorP9SwsVector", "?sws_convVec@@YAXPAUSwsVector@@PAUSwsVector@@@Z"}) 
	void sws_convVec(SwsVector a, SwsVector b);
	/**
	 * Original signature : <code>void sws_addVec(SwsVector*, SwsVector*)</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:254</i>
	 */
	@Mangling({"_Z10sws_addVecP9SwsVectorP9SwsVector", "?sws_addVec@@YAXPAUSwsVector@@PAUSwsVector@@@Z"}) 
	void sws_addVec(SwsVector a, SwsVector b);
	/**
	 * Original signature : <code>void sws_subVec(SwsVector*, SwsVector*)</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:255</i>
	 */
	@Mangling({"_Z10sws_subVecP9SwsVectorP9SwsVector", "?sws_subVec@@YAXPAUSwsVector@@PAUSwsVector@@@Z"}) 
	void sws_subVec(SwsVector a, SwsVector b);
	/**
	 * Original signature : <code>void sws_shiftVec(SwsVector*, int)</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:256</i>
	 */
	@Mangling({"_Z12sws_shiftVecP9SwsVectori", "?sws_shiftVec@@YAXPAUSwsVector@@H@Z"}) 
	void sws_shiftVec(SwsVector a, int shift);
	/**
	 * Allocates and returns a clone of the vector a, that is a vector<br>
	 * with the same coefficients as a.<br>
	 * Original signature : <code>SwsVector* sws_cloneVec(SwsVector*)</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:262</i>
	 */
	@Mangling({"_Z12sws_cloneVecP9SwsVector", "?sws_cloneVec@@YAPAUSwsVector@@PAUSwsVector@@@Z"}) 
	SwsVector sws_cloneVec(SwsVector a);
	/**
	 * Prints with av_log() a textual representation of the vector a<br>
	 * if log_level <= av_log_level.<br>
	 * Original signature : <code>void sws_printVec2(SwsVector*, AVClass*, int)</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:275</i>
	 */
	@Mangling({"_Z13sws_printVec2P9SwsVectorP7AVClassi", "?sws_printVec2@@YAXPAUSwsVector@@PAUAVClass@@H@Z"}) 
	void sws_printVec2(SwsVector a, Pointer log_ctx, int log_level);
	/**
	 * Original signature : <code>void sws_freeVec(SwsVector*)</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:277</i>
	 */
	@Mangling({"_Z11sws_freeVecP9SwsVector", "?sws_freeVec@@YAXPAUSwsVector@@@Z"}) 
	void sws_freeVec(SwsVector a);
	/**
	 * Original signature : <code>SwsFilter* sws_getDefaultFilter(float, float, float, float, float, float, int)</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:279</i>
	 */
	@Mangling({"_Z20sws_getDefaultFilterffffffi", "?sws_getDefaultFilter@@YAPAUSwsFilter@@MMMMMMH@Z"}) 
	SwsFilter sws_getDefaultFilter(float lumaGBlur, float chromaGBlur, float lumaSharpen, float chromaSharpen, float chromaHShift, float chromaVShift, int verbose);
	/**
	 * Original signature : <code>void sws_freeFilter(SwsFilter*)</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:283</i>
	 */
	@Mangling({"_Z14sws_freeFilterP9SwsFilter", "?sws_freeFilter@@YAXPAUSwsFilter@@@Z"}) 
	void sws_freeFilter(SwsFilter filter);
	/**
	 * Checks if context can be reused, otherwise reallocates a new<br>
	 * one.<br>
	 * * If context is NULL, just calls sws_getContext() to get a new<br>
	 * context. Otherwise, checks if the parameters are the ones already<br>
	 * saved in context. If that is the case, returns the current<br>
	 * context. Otherwise, frees context and gets a new context with<br>
	 * the new parameters.<br>
	 * * Be warned that srcFilter and dstFilter are not checked, they<br>
	 * are assumed to remain the same.<br>
	 * Original signature : <code>SwsContext* sws_getCachedContext(SwsContext*, int, int, PixelFormat, int, int, PixelFormat, int, SwsFilter*, SwsFilter*, const double*)</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:298</i><br>
	 * @deprecated use the safer methods {@link #sws_getCachedContext(com.sun.jna.Pointer, int, int, int, int, int, int, int, swscale.SwsFilter, swscale.SwsFilter, double[])} and {@link #sws_getCachedContext(com.sun.jna.Pointer, int, int, int, int, int, int, int, swscale.SwsFilter, swscale.SwsFilter, com.sun.jna.ptr.DoubleByReference)} instead<br>
	 * @param srcFormat @see PixelFormat<br>
	 * @param dstFormat @see PixelFormat
	 */
	@Mangling({"_Z20sws_getCachedContextP10SwsContextii11PixelFormatii11PixelFormatiP9SwsFilterP9SwsFilterPKd", "?sws_getCachedContext@@YAPA10SwsContextPA10SwsContextHH11PixelFormatHH11PixelFormatHPAUSwsFilter@@PAUSwsFilter@@PAN@Z"}) 
	@Deprecated 
	Pointer sws_getCachedContext(Pointer context, int srcW, int srcH, int srcFormat, int dstW, int dstH, int dstFormat, int flags, SwsFilter srcFilter, SwsFilter dstFilter, DoubleByReference param);
	/**
	 * Checks if context can be reused, otherwise reallocates a new<br>
	 * one.<br>
	 * * If context is NULL, just calls sws_getContext() to get a new<br>
	 * context. Otherwise, checks if the parameters are the ones already<br>
	 * saved in context. If that is the case, returns the current<br>
	 * context. Otherwise, frees context and gets a new context with<br>
	 * the new parameters.<br>
	 * * Be warned that srcFilter and dstFilter are not checked, they<br>
	 * are assumed to remain the same.<br>
	 * Original signature : <code>SwsContext* sws_getCachedContext(SwsContext*, int, int, PixelFormat, int, int, PixelFormat, int, SwsFilter*, SwsFilter*, const double*)</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:298</i><br>
	 * @param srcFormat @see PixelFormat<br>
	 * @param dstFormat @see PixelFormat
	 */
	@Mangling({"_Z20sws_getCachedContextP10SwsContextii11PixelFormatii11PixelFormatiP9SwsFilterP9SwsFilterPKd", "?sws_getCachedContext@@YAPA10SwsContextPA10SwsContextHH11PixelFormatHH11PixelFormatHPAUSwsFilter@@PAUSwsFilter@@PAN@Z"}) 
	Pointer sws_getCachedContext(Pointer context, int srcW, int srcH, int srcFormat, int dstW, int dstH, int dstFormat, int flags, SwsFilter srcFilter, SwsFilter dstFilter, double param[]);
	/**
	 * Converts an 8bit paletted frame into a frame with a color depth of 32-bits.<br>
	 * * The output frame will have the same packed format as the palette.<br>
	 * * @param src        source frame buffer<br>
	 * @param dst        destination frame buffer<br>
	 * @param num_pixels number of pixels to convert<br>
	 * @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src<br>
	 * Original signature : <code>void sws_convertPalette8ToPacked32(const uint8_t*, uint8_t*, long, const uint8_t*)</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:314</i><br>
	 * @deprecated use the safer methods {@link #sws_convertPalette8ToPacked32(byte[], java.nio.ByteBuffer, com.sun.jna.NativeLong, byte[])} and {@link #sws_convertPalette8ToPacked32(com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.NativeLong, com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z29sws_convertPalette8ToPacked32PK7uint8_tP7uint8_tlPK7uint8_t", "?sws_convertPalette8ToPacked32@@YAXPA7uint8_tPA7uint8_tJPA7uint8_t@Z"}) 
	@Deprecated 
	void sws_convertPalette8ToPacked32(Pointer src, Pointer dst, NativeLong num_pixels, Pointer palette);
	/**
	 * Converts an 8bit paletted frame into a frame with a color depth of 32-bits.<br>
	 * * The output frame will have the same packed format as the palette.<br>
	 * * @param src        source frame buffer<br>
	 * @param dst        destination frame buffer<br>
	 * @param num_pixels number of pixels to convert<br>
	 * @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src<br>
	 * Original signature : <code>void sws_convertPalette8ToPacked32(const uint8_t*, uint8_t*, long, const uint8_t*)</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:314</i>
	 */
	@Mangling({"_Z29sws_convertPalette8ToPacked32PK7uint8_tP7uint8_tlPK7uint8_t", "?sws_convertPalette8ToPacked32@@YAXPA7uint8_tPA7uint8_tJPA7uint8_t@Z"}) 
	void sws_convertPalette8ToPacked32(byte src[], ByteBuffer dst, NativeLong num_pixels, byte palette[]);
	/**
	 * Converts an 8bit paletted frame into a frame with a color depth of 24 bits.<br>
	 * * With the palette format "ABCD", the destination frame ends up with the format "ABC".<br>
	 * * @param src        source frame buffer<br>
	 * @param dst        destination frame buffer<br>
	 * @param num_pixels number of pixels to convert<br>
	 * @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src<br>
	 * Original signature : <code>void sws_convertPalette8ToPacked24(const uint8_t*, uint8_t*, long, const uint8_t*)</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:326</i><br>
	 * @deprecated use the safer methods {@link #sws_convertPalette8ToPacked24(byte[], java.nio.ByteBuffer, com.sun.jna.NativeLong, byte[])} and {@link #sws_convertPalette8ToPacked24(com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.NativeLong, com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z29sws_convertPalette8ToPacked24PK7uint8_tP7uint8_tlPK7uint8_t", "?sws_convertPalette8ToPacked24@@YAXPA7uint8_tPA7uint8_tJPA7uint8_t@Z"}) 
	@Deprecated 
	void sws_convertPalette8ToPacked24(Pointer src, Pointer dst, NativeLong num_pixels, Pointer palette);
	/**
	 * Converts an 8bit paletted frame into a frame with a color depth of 24 bits.<br>
	 * * With the palette format "ABCD", the destination frame ends up with the format "ABC".<br>
	 * * @param src        source frame buffer<br>
	 * @param dst        destination frame buffer<br>
	 * @param num_pixels number of pixels to convert<br>
	 * @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src<br>
	 * Original signature : <code>void sws_convertPalette8ToPacked24(const uint8_t*, uint8_t*, long, const uint8_t*)</code><br>
	 * <i>native declaration : src/main/headers/libswscale/swscale.h:326</i>
	 */
	@Mangling({"_Z29sws_convertPalette8ToPacked24PK7uint8_tP7uint8_tlPK7uint8_t", "?sws_convertPalette8ToPacked24@@YAXPA7uint8_tPA7uint8_tJPA7uint8_t@Z"}) 
	void sws_convertPalette8ToPacked24(byte src[], ByteBuffer dst, NativeLong num_pixels, byte palette[]);
	/// Undefined type
	public static interface SwsContext {
		
	};
}
