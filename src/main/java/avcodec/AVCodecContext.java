package avcodec;
import avformat.AvformatLibrary.PixelFormat;
import avutil.AVRational;
import com.ochafik.lang.jnaerator.runtime.Structure;
import com.sun.jna.Callback;
import com.sun.jna.Pointer;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.ShortByReference;
/**
 * <i>native declaration : src/main/headers/libavcodec/avcodec.h</i><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.free.fr/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public class AVCodecContext extends Structure<AVCodecContext, AVCodecContext.ByValue, AVCodecContext.ByReference > {
	/**
	 * information on struct for av_log<br>
	 * - set by avcodec_alloc_context<br>
	 * C type : const AVClass*
	 */
	public Pointer av_class;
	/**
	 * the average bitrate<br>
	 * - encoding: Set by user; unused for constant quantizer encoding.<br>
	 * - decoding: Set by libavcodec. 0 or some bitrate if this info is available in the stream.
	 */
	public int bit_rate;
	/**
	 * number of bits the bitstream is allowed to diverge from the reference.<br>
	 *           the reference can be CBR (for CBR pass1) or VBR (for pass2)<br>
	 * - encoding: Set by user; unused for constant quantizer encoding.<br>
	 * - decoding: unused
	 */
	public int bit_rate_tolerance;
	/**
	 * CODEC_FLAG_*.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by user.
	 */
	public int flags;
	/**
	 * Some codecs need additional format info. It is stored here.<br>
	 * If any muxer uses this then ALL demuxers/parsers AND encoders for the<br>
	 * specific codec MUST set it correctly otherwise stream copy breaks.<br>
	 * In general use of this field by muxers is not recommanded.<br>
	 * - encoding: Set by libavcodec.<br>
	 * - decoding: Set by libavcodec. (FIXME: Is this OK?)
	 */
	public int sub_id;
	/**
	 * Motion estimation algorithm used for video coding.<br>
	 * 1 (zero), 2 (full), 3 (log), 4 (phods), 5 (epzs), 6 (x1), 7 (hex),<br>
	 * 8 (umh), 9 (iter), 10 (tesa) [7, 8, 10 are x264 specific, 9 is snow specific]<br>
	 * - encoding: MUST be set by user.<br>
	 * - decoding: unused
	 */
	public int me_method;
	/**
	 * some codecs need / can use extradata like Huffman tables.<br>
	 * mjpeg: Huffman tables<br>
	 * rv10: additional flags<br>
	 * mpeg4: global headers (they can be in the bitstream or here)<br>
	 * The allocated memory should be FF_INPUT_BUFFER_PADDING_SIZE bytes larger<br>
	 * than extradata_size to avoid prolems if it is read with the bitstream reader.<br>
	 * The bytewise contents of extradata must not depend on the architecture or CPU endianness.<br>
	 * - encoding: Set/allocated/freed by libavcodec.<br>
	 * - decoding: Set/allocated/freed by user.<br>
	 * C type : uint8_t*
	 */
	public Pointer extradata;
	public int extradata_size;
	/**
	 * This is the fundamental unit of time (in seconds) in terms<br>
	 * of which frame timestamps are represented. For fixed-fps content,<br>
	 * timebase should be 1/framerate and timestamp increments should be<br>
	 * identically 1.<br>
	 * - encoding: MUST be set by user.<br>
	 * - decoding: Set by libavcodec.<br>
	 * C type : AVRational
	 */
	public AVRational time_base;
	/**
	 * picture width / height.<br>
	 * - encoding: MUST be set by user.<br>
	 * - decoding: Set by libavcodec.<br>
	 * Note: For compatibility it is possible to set this instead of<br>
	 * coded_width/height before decoding.
	 */
	public int width;
	/**
	 * picture width / height.<br>
	 * - encoding: MUST be set by user.<br>
	 * - decoding: Set by libavcodec.<br>
	 * Note: For compatibility it is possible to set this instead of<br>
	 * coded_width/height before decoding.
	 */
	public int height;
	/**
	 * the number of pictures in a group of pictures, or 0 for intra_only<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int gop_size;
	/**
	 * Pixel format, see PIX_FMT_xxx.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by libavcodec.<br>
	 * C type : PixelFormat
	 */
	public PixelFormat pix_fmt;
	/**
	 * Frame rate emulation. If not zero, the lower layer (i.e. format handler)<br>
	 * has to read frames at native frame rate.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int rate_emu;
	/**
	 * If non NULL, 'draw_horiz_band' is called by the libavcodec<br>
	 * decoder to draw a horizontal band. It improves cache usage. Not<br>
	 * all codecs can do that. You must check the codec capabilities<br>
	 * beforehand.<br>
	 * The function is also used by hardware acceleration APIs.<br>
	 * It is called at least once during frame decoding to pass<br>
	 * the data needed for hardware render.<br>
	 * In that mode instead of pixel data, AVFrame points to<br>
	 * a structure specific to the acceleration API. The application<br>
	 * reads the structure and can change some fields to indicate progress<br>
	 * or mark state.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.<br>
	 * @param height the height of the slice<br>
	 * @param y the y position of the slice<br>
	 * @param type 1->top field, 2->bottom field, 3->frame<br>
	 * @param offset offset into the AVFrame.data from which the slice should be read<br>
	 * C type : draw_horiz_band_callback
	 */
	public AVCodecContext.draw_horiz_band_callback draw_horiz_band;
	/**
	 * audio only<br>
	 * < samples per second
	 */
	public int sample_rate;
	/// < number of audio channels
	public int channels;
	/**
	 * audio sample format<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by libavcodec.<br>
	 * @see SampleFormat<br>
	 * < sample format<br>
	 * C type : SampleFormat
	 */
	public int sample_fmt;
	/// Samples per packet, initialized when calling 'init'.
	public int frame_size;
	/// < audio or video frame number
	public int frame_number;
	/// < Returns the real picture number of previous encoded frame.
	public int real_pict_num;
	/**
	 * Number of frames the decoded output will be delayed relative to<br>
	 * the encoded input.<br>
	 * - encoding: Set by libavcodec.<br>
	 * - decoding: unused
	 */
	public int delay;
	/**
	 * - encoding parameters<br>
	 * < amount of qscale change between easy & hard scenes (0.0-1.0)
	 */
	public float qcompress;
	/// < amount of qscale smoothing over time (0.0-1.0)
	public float qblur;
	/**
	 * minimum quantizer<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int qmin;
	/**
	 * maximum quantizer<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int qmax;
	/**
	 * maximum quantizer difference between frames<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int max_qdiff;
	/**
	 * maximum number of B-frames between non-B-frames<br>
	 * Note: The output will be delayed by max_b_frames+1 relative to the input.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int max_b_frames;
	/**
	 * qscale factor between IP and B-frames<br>
	 * If > 0 then the last P-frame quantizer will be used (q= lastp_q*factor+offset).<br>
	 * If < 0 then normal ratecontrol will be done (q= -normal_q*factor+offset).<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public float b_quant_factor;
	/// obsolete FIXME remove
	public int rc_strategy;
	public int b_frame_strategy;
	/**
	 * hurry up amount<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user. 1-> Skip B-frames, 2-> Skip IDCT/dequant too, 5-> Skip everything except header<br>
	 * @deprecated Deprecated in favor of skip_idct and skip_frame.
	 */
	public int hurry_up;
	/// C type : AVCodec*
	public avcodec.AVCodec.ByReference codec;
	/// C type : void*
	public Pointer priv_data;
	/// The size of the RTP payload: the coder will
	public int rtp_payload_size;
	/**
	 * encoded in the RTP payload.<br>
	 * C type : rtp_callback_callback
	 */
	public AVCodecContext.rtp_callback_callback rtp_callback;
	/// statistics, used for 2-pass encoding
	public int mv_bits;
	public int header_bits;
	public int i_tex_bits;
	public int p_tex_bits;
	public int i_count;
	public int p_count;
	public int skip_count;
	public int misc_bits;
	/**
	 * number of bits used for the previously encoded frame<br>
	 * - encoding: Set by libavcodec.<br>
	 * - decoding: unused
	 */
	public int frame_bits;
	/**
	 * Private data of the user, can be used to carry app specific stuff.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by user.<br>
	 * C type : void*
	 */
	public Pointer opaque;
	/// C type : char[32]
	public byte[] codec_name = new byte[(32)];
	/**
	 * @see avutil.AvutilLibrary#AVMediaType<br>
	 * see AVMEDIA_TYPE_xxx<br>
	 * C type : AVMediaType
	 */
	public int codec_type;
	/**
	 * @see CodecID<br>
	 * see CODEC_ID_xxx<br>
	 * C type : CodecID
	 */
	public int codec_id;
	/**
	 * fourcc (LSB first, so "ABCD" -> ('D'<<24) + ('C'<<16) + ('B'<<8) + 'A').<br>
	 * This is used to work around some encoder bugs.<br>
	 * A demuxer should set this to what is stored in the field used to identify the codec.<br>
	 * If there are multiple such fields in a container then the demuxer should choose the one<br>
	 * which maximizes the information about the used codec.<br>
	 * If the codec tag field in a container is larger then 32 bits then the demuxer should<br>
	 * remap the longer ID to 32 bits with a table or other structure. Alternatively a new<br>
	 * extra_codec_tag + size could be added but for this a clear advantage must be demonstrated<br>
	 * first.<br>
	 * - encoding: Set by user, if not then the default based on codec_id will be used.<br>
	 * - decoding: Set by user, will be converted to uppercase by libavcodec during init.
	 */
	public int codec_tag;
	/**
	 * Work around bugs in encoders which sometimes cannot be detected automatically.<br>
	 * - encoding: Set by user<br>
	 * - decoding: Set by user
	 */
	public int workaround_bugs;
	/**
	 * luma single coefficient elimination threshold<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int luma_elim_threshold;
	/**
	 * chroma single coeff elimination threshold<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int chroma_elim_threshold;
	/**
	 * strictly follow the standard (MPEG4, ...).<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by user.<br>
	 * Setting this to STRICT or higher means the encoder and decoder will<br>
	 * generally do stupid things. While setting it to inofficial or lower<br>
	 * will mean the encoder might use things that are not supported by all<br>
	 * spec compliant decoders. Decoders make no difference between normal,<br>
	 * inofficial and experimental, that is they always try to decode things<br>
	 * when they can unless they are explicitly asked to behave stupid<br>
	 * (=strictly conform to the specs)
	 */
	public int strict_std_compliance;
	/**
	 * qscale offset between IP and B-frames<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public float b_quant_offset;
	/**
	 * Error recognization; higher values will detect more errors but may<br>
	 * misdetect some more or less valid parts as errors.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.
	 */
	public int error_recognition;
	/**
	 * Called at the beginning of each frame to get a buffer for it.<br>
	 * If pic.reference is set then the frame will be read later by libavcodec.<br>
	 * avcodec_align_dimensions2() should be used to find the required width and<br>
	 * height, as they normally need to be rounded up to the next multiple of 16.<br>
	 * if CODEC_CAP_DR1 is not set then get_buffer() must call<br>
	 * avcodec_default_get_buffer() instead of providing buffers allocated by<br>
	 * some other means.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by libavcodec., user can override.<br>
	 * C type : get_buffer_callback
	 */
	public AVCodecContext.get_buffer_callback get_buffer;
	/**
	 * Called to release buffers which were allocated with get_buffer.<br>
	 * A released buffer can be reused in get_buffer().<br>
	 * pic.data[*] must be set to NULL.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by libavcodec., user can override.<br>
	 * C type : release_buffer_callback
	 */
	public AVCodecContext.release_buffer_callback release_buffer;
	/**
	 * Size of the frame reordering buffer in the decoder.<br>
	 * For MPEG-2 it is 1 IPB or 0 low delay IP.<br>
	 * - encoding: Set by libavcodec.<br>
	 * - decoding: Set by libavcodec.
	 */
	public int has_b_frames;
	/**
	 * number of bytes per packet if constant and known or 0<br>
	 * Used by some WAV based audio codecs.
	 */
	public int block_align;
	/**
	 * - decoding only: If true, only parsing is done<br>
	 * (function avcodec_parse_frame()). The frame<br>
	 * data is returned. Only MPEG codecs support this now.
	 */
	public int parse_only;
	/**
	 * 0-> h263 quant 1-> mpeg quant<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int mpeg_quant;
	/**
	 * pass1 encoding statistics output buffer<br>
	 * - encoding: Set by libavcodec.<br>
	 * - decoding: unused<br>
	 * C type : char*
	 */
	public Pointer stats_out;
	/**
	 * pass2 encoding statistics input buffer<br>
	 * Concatenated stuff from stats_out of pass1 should be placed here.<br>
	 * - encoding: Allocated/set/freed by user.<br>
	 * - decoding: unused<br>
	 * C type : char*
	 */
	public Pointer stats_in;
	/**
	 * ratecontrol qmin qmax limiting method<br>
	 * 0-> clipping, 1-> use a nice continous function to limit qscale wthin qmin/qmax.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public float rc_qsquish;
	public float rc_qmod_amp;
	public int rc_qmod_freq;
	/**
	 * ratecontrol override, see RcOverride<br>
	 * - encoding: Allocated/set/freed by user.<br>
	 * - decoding: unused<br>
	 * C type : RcOverride*
	 */
	public avcodec.RcOverride.ByReference rc_override;
	public int rc_override_count;
	/**
	 * rate control equation<br>
	 * - encoding: Set by user<br>
	 * - decoding: unused<br>
	 * C type : const char*
	 */
	public Pointer rc_eq;
	/**
	 * maximum bitrate<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int rc_max_rate;
	/**
	 * minimum bitrate<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int rc_min_rate;
	/**
	 * decoder bitstream buffer size<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int rc_buffer_size;
	public float rc_buffer_aggressivity;
	/**
	 * qscale factor between P and I-frames<br>
	 * If > 0 then the last p frame quantizer will be used (q= lastp_q*factor+offset).<br>
	 * If < 0 then normal ratecontrol will be done (q= -normal_q*factor+offset).<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public float i_quant_factor;
	/**
	 * qscale offset between P and I-frames<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public float i_quant_offset;
	/**
	 * initial complexity for pass1 ratecontrol<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public float rc_initial_cplx;
	/**
	 * DCT algorithm, see FF_DCT_* below<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int dct_algo;
	/**
	 * luminance masking (0-> disabled)<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public float lumi_masking;
	/**
	 * temporary complexity masking (0-> disabled)<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public float temporal_cplx_masking;
	/**
	 * spatial complexity masking (0-> disabled)<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public float spatial_cplx_masking;
	/**
	 * p block masking (0-> disabled)<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public float p_masking;
	/**
	 * darkness masking (0-> disabled)<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public float dark_masking;
	/**
	 * IDCT algorithm, see FF_IDCT_* below.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by user.
	 */
	public int idct_algo;
	/**
	 * slice count<br>
	 * - encoding: Set by libavcodec.<br>
	 * - decoding: Set by user (or 0).
	 */
	public int slice_count;
	/**
	 * slice offsets in the frame in bytes<br>
	 * - encoding: Set/allocated by libavcodec.<br>
	 * - decoding: Set/allocated by user (or NULL).<br>
	 * C type : int*
	 */
	public IntByReference slice_offset;
	/**
	 * error concealment flags<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.
	 */
	public int error_concealment;
	/**
	 * dsp_mask could be add used to disable unwanted CPU features<br>
	 * CPU features (i.e. MMX, SSE. ...)<br>
	 * * With the FORCE flag you may instead enable given CPU features.<br>
	 * (Dangerous: Usable in case of misdetection, improper usage however will<br>
	 * result into program crash.)
	 */
	public int dsp_mask;
	/**
	 * bits per sample/pixel from the demuxer (needed for huffyuv).<br>
	 * - encoding: Set by libavcodec.<br>
	 * - decoding: Set by user.
	 */
	public int bits_per_coded_sample;
	/**
	 * prediction method (needed for huffyuv)<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int prediction_method;
	/**
	 * sample aspect ratio (0 if unknown)<br>
	 * That is the width of a pixel divided by the height of the pixel.<br>
	 * Numerator and denominator must be relatively prime and smaller than 256 for some video standards.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by libavcodec.<br>
	 * C type : AVRational
	 */
	public AVRational sample_aspect_ratio;
	/**
	 * the picture in the bitstream<br>
	 * - encoding: Set by libavcodec.<br>
	 * - decoding: Set by libavcodec.<br>
	 * C type : AVFrame*
	 */
	public AVFrame.ByReference coded_frame;
	/**
	 * debug<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by user.
	 */
	public int debug;
	/**
	 * debug<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by user.
	 */
	public int debug_mv;
	/**
	 * error<br>
	 * - encoding: Set by libavcodec if flags&CODEC_FLAG_PSNR.<br>
	 * - decoding: unused<br>
	 * C type : uint64_t[4]
	 */
	public long[] error = new long[(4)];
	/**
	 * minimum MB quantizer<br>
	 * - encoding: unused<br>
	 * - decoding: unused
	 */
	public int mb_qmin;
	/**
	 * maximum MB quantizer<br>
	 * - encoding: unused<br>
	 * - decoding: unused
	 */
	public int mb_qmax;
	/**
	 * motion estimation comparison function<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int me_cmp;
	/**
	 * subpixel motion estimation comparison function<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int me_sub_cmp;
	/**
	 * macroblock comparison function (not supported yet)<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int mb_cmp;
	/**
	 * interlaced DCT comparison function<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int ildct_cmp;
	/**
	 * ME diamond size & shape<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int dia_size;
	/**
	 * amount of previous MV predictors (2a+1 x 2a+1 square)<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int last_predictor_count;
	/**
	 * prepass for motion estimation<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int pre_me;
	/**
	 * motion estimation prepass comparison function<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int me_pre_cmp;
	/**
	 * ME prepass diamond size & shape<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int pre_dia_size;
	/**
	 * subpel ME quality<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int me_subpel_quality;
	/**
	 * callback to negotiate the pixelFormat<br>
	 * @param fmt is the list of formats which are supported by the codec,<br>
	 * it is terminated by -1 as 0 is a valid format, the formats are ordered by quality.<br>
	 * The first is always the native one.<br>
	 * @return the chosen format<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user, if not set the native format will be chosen.<br>
	 * C type : get_format_callback
	 */
	public AVCodecContext.get_format_callback get_format;
	/**
	 * DTG active format information (additional aspect ratio<br>
	 * information only used in DVB MPEG-2 transport streams)<br>
	 * 0 if not set.<br>
	 * * - encoding: unused<br>
	 * - decoding: Set by decoder.
	 */
	public int dtg_active_format;
	/**
	 * maximum motion estimation search range in subpel units<br>
	 * If 0 then no limit.<br>
	 * * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int me_range;
	/**
	 * intra quantizer bias<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int intra_quant_bias;
	/**
	 * inter quantizer bias<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int inter_quant_bias;
	/**
	 * color table ID<br>
	 * - encoding: unused<br>
	 * - decoding: Which clrtable should be used for 8bit RGB images.<br>
	 *             Tables have to be stored somewhere. FIXME
	 */
	public int color_table_id;
	/**
	 * internal_buffer count<br>
	 * Don't touch, used by libavcodec default_get_buffer().
	 */
	public int internal_buffer_count;
	/**
	 * internal_buffers<br>
	 * Don't touch, used by libavcodec default_get_buffer().<br>
	 * C type : void*
	 */
	public Pointer internal_buffer;
	/**
	 * Global quality for codecs which cannot change it per frame.<br>
	 * This should be proportional to MPEG-1/2/4 qscale.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int global_quality;
	/**
	 * coder type<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int coder_type;
	/**
	 * context model<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int context_model;
	/**
	 * slice flags<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.
	 */
	public int slice_flags;
	/**
	 * XVideo Motion Acceleration<br>
	 * - encoding: forbidden<br>
	 * - decoding: set by decoder
	 */
	public int xvmc_acceleration;
	/**
	 * macroblock decision mode<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int mb_decision;
	/**
	 * custom intra quantization matrix<br>
	 * - encoding: Set by user, can be NULL.<br>
	 * - decoding: Set by libavcodec.<br>
	 * C type : uint16_t*
	 */
	public ShortByReference intra_matrix;
	/**
	 * custom inter quantization matrix<br>
	 * - encoding: Set by user, can be NULL.<br>
	 * - decoding: Set by libavcodec.<br>
	 * C type : uint16_t*
	 */
	public ShortByReference inter_matrix;
	/**
	 * fourcc from the AVI stream header (LSB first, so "ABCD" -> ('D'<<24) + ('C'<<16) + ('B'<<8) + 'A').<br>
	 * This is used to work around some encoder bugs.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user, will be converted to uppercase by libavcodec during init.
	 */
	public int stream_codec_tag;
	/**
	 * scene change detection threshold<br>
	 * 0 is default, larger means fewer detected scene changes.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int scenechange_threshold;
	/**
	 * minimum Lagrange multipler<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int lmin;
	/**
	 * maximum Lagrange multipler<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int lmax;
	/**
	 * palette control structure<br>
	 * - encoding: ??? (no palette-enabled encoder yet)<br>
	 * - decoding: Set by user.<br>
	 * C type : AVPaletteControl*
	 */
	public avcodec.AVPaletteControl.ByReference palctrl;
	/**
	 * noise reduction strength<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int noise_reduction;
	/**
	 * Called at the beginning of a frame to get cr buffer for it.<br>
	 * Buffer type (size, hints) must be the same. libavcodec won't check it.<br>
	 * libavcodec will pass previous buffer in pic, function should return<br>
	 * same buffer or new buffer with old frame "painted" into it.<br>
	 * If pic.data[0] == NULL must behave like get_buffer().<br>
	 * if CODEC_CAP_DR1 is not set then reget_buffer() must call<br>
	 * avcodec_default_reget_buffer() instead of providing buffers allocated by<br>
	 * some other means.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by libavcodec., user can override<br>
	 * C type : reget_buffer_callback
	 */
	public AVCodecContext.reget_buffer_callback reget_buffer;
	/**
	 * Number of bits which should be loaded into the rc buffer before decoding starts.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int rc_initial_buffer_occupancy;
	/**
	 * * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int inter_threshold;
	/**
	 * CODEC_FLAG2_*<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by user.
	 */
	public int flags2;
	/**
	 * Simulates errors in the bitstream to test error concealment.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int error_rate;
	/**
	 * MP3 antialias algorithm, see FF_AA_* below.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.
	 */
	public int antialias_algo;
	/**
	 * quantizer noise shaping<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int quantizer_noise_shaping;
	/**
	 * thread count<br>
	 * is used to decide how many independent tasks should be passed to execute()<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by user.
	 */
	public int thread_count;
	/**
	 * The codec may call this to execute several independent things.<br>
	 * It will return only after finishing all tasks.<br>
	 * The user may replace this with some multithreaded implementation,<br>
	 * the default implementation will execute the parts serially.<br>
	 * @param count the number of things to execute<br>
	 * - encoding: Set by libavcodec, user can override.<br>
	 * - decoding: Set by libavcodec, user can override.<br>
	 * C type : execute_callback
	 */
	public AVCodecContext.execute_callback execute;
	/**
	 * thread opaque<br>
	 * Can be used by execute() to store some per AVCodecContext stuff.<br>
	 * - encoding: set by execute()<br>
	 * - decoding: set by execute()<br>
	 * C type : void*
	 */
	public Pointer thread_opaque;
	/**
	 * Motion estimation threshold below which no motion estimation is<br>
	 * performed, but instead the user specified motion vectors are used.<br>
	 * * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int me_threshold;
	/**
	 * Macroblock threshold below which the user specified macroblock types will be used.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int mb_threshold;
	/**
	 * precision of the intra DC coefficient - 8<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int intra_dc_precision;
	/**
	 * noise vs. sse weight for the nsse comparsion function<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int nsse_weight;
	/**
	 * Number of macroblock rows at the top which are skipped.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.
	 */
	public int skip_top;
	/**
	 * Number of macroblock rows at the bottom which are skipped.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.
	 */
	public int skip_bottom;
	/**
	 * profile<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by libavcodec.
	 */
	public int profile;
	/**
	 * level<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by libavcodec.
	 */
	public int level;
	/**
	 * low resolution decoding, 1-> 1/2 size, 2->1/4 size<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.
	 */
	public int lowres;
	/**
	 * Bitstream width / height, may be different from width/height if lowres<br>
	 * or other things are used.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user before init if known. Codec should override / dynamically change if needed.
	 */
	public int coded_width;
	/**
	 * Bitstream width / height, may be different from width/height if lowres<br>
	 * or other things are used.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user before init if known. Codec should override / dynamically change if needed.
	 */
	public int coded_height;
	/**
	 * frame skip threshold<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int frame_skip_threshold;
	/**
	 * frame skip factor<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int frame_skip_factor;
	/**
	 * frame skip exponent<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int frame_skip_exp;
	/**
	 * frame skip comparison function<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int frame_skip_cmp;
	/**
	 * Border processing masking, raises the quantizer for mbs on the borders<br>
	 * of the picture.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public float border_masking;
	/**
	 * minimum MB lagrange multipler<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int mb_lmin;
	/**
	 * maximum MB lagrange multipler<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int mb_lmax;
	/**
	 * * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int me_penalty_compensation;
	/**
	 * * - encoding: unused<br>
	 * - decoding: Set by user.<br>
	 * @see AVDiscard<br>
	 * C type : AVDiscard
	 */
	public int skip_loop_filter;
	/**
	 * * - encoding: unused<br>
	 * - decoding: Set by user.<br>
	 * @see AVDiscard<br>
	 * C type : AVDiscard
	 */
	public int skip_idct;
	/**
	 * * - encoding: unused<br>
	 * - decoding: Set by user.<br>
	 * @see AVDiscard<br>
	 * C type : AVDiscard
	 */
	public int skip_frame;
	/**
	 * * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int bidir_refine;
	/**
	 * * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int brd_scale;
	/**
	 * constant rate factor - quality-based VBR - values ~correspond to qps<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public float crf;
	/**
	 * constant quantization parameter rate control method<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int cqp;
	/**
	 * minimum GOP size<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int keyint_min;
	/**
	 * number of reference frames<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by lavc.
	 */
	public int refs;
	/**
	 * chroma qp offset from luma<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int chromaoffset;
	/**
	 * Influences how often B-frames are used.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int bframebias;
	/**
	 * trellis RD quantization<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int trellis;
	/**
	 * Reduce fluctuations in qp (before curve compression).<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public float complexityblur;
	/**
	 * in-loop deblocking filter alphac0 parameter<br>
	 * alpha is in the range -6...6<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int deblockalpha;
	/**
	 * in-loop deblocking filter beta parameter<br>
	 * beta is in the range -6...6<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int deblockbeta;
	/**
	 * macroblock subpartition sizes to consider - p8x8, p4x4, b8x8, i8x8, i4x4<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int partitions;
	/**
	 * direct MV prediction mode - 0 (none), 1 (spatial), 2 (temporal), 3 (auto)<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int directpred;
	/**
	 * Audio cutoff bandwidth (0 means "automatic")<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int cutoff;
	/**
	 * Multiplied by qscale for each frame and added to scene_change_score.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int scenechange_factor;
	/**
	 * * Note: Value depends upon the compare function used for fullpel ME.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int mv0_threshold;
	/**
	 * Adjusts sensitivity of b_frame_strategy 1.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int b_sensitivity;
	/**
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int compression_level;
	/**
	 * Sets whether to use LPC mode - used by FLAC encoder.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int use_lpc;
	/**
	 * LPC coefficient precision - used by FLAC encoder<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int lpc_coeff_precision;
	/**
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int min_prediction_order;
	/**
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int max_prediction_order;
	/**
	 * search method for selecting prediction order<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int prediction_order_method;
	/**
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int min_partition_order;
	/**
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int max_partition_order;
	/**
	 * GOP timecode frame start number, in non drop frame format<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public long timecode_frame_start;
	/**
	 * Decoder should decode to this many channels if it can (0 for default)<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.<br>
	 * @deprecated Deprecated in favor of request_channel_layout.
	 */
	public int request_channels;
	/**
	 * Percentage of dynamic range compression to be applied by the decoder.<br>
	 * The default value is 1.0, corresponding to full compression.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.
	 */
	public float drc_scale;
	/**
	 * opaque 64bit number (generally a PTS) that will be reordered and<br>
	 * output in AVFrame.reordered_opaque<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.
	 */
	public long reordered_opaque;
	/**
	 * Bits per sample/pixel of internal libavcodec pixel/sample format.<br>
	 * This field is applicable only when sample_fmt is SAMPLE_FMT_S32.<br>
	 * - encoding: set by user.<br>
	 * - decoding: set by libavcodec.
	 */
	public int bits_per_raw_sample;
	/**
	 * Audio channel layout.<br>
	 * - encoding: set by user.<br>
	 * - decoding: set by libavcodec.
	 */
	public long channel_layout;
	/**
	 * Request decoder to use this channel layout if it can (0 for default)<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.
	 */
	public long request_channel_layout;
	/**
	 * Ratecontrol attempt to use, at maximum, <value> of what can be used without an underflow.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused.
	 */
	public float rc_max_available_vbv_use;
	/**
	 * Ratecontrol attempt to use, at least, <value> times the amount needed to prevent a vbv overflow.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused.
	 */
	public float rc_min_vbv_overflow_use;
	/**
	 * Hardware accelerator in use<br>
	 * - encoding: unused.<br>
	 * - decoding: Set by libavcodec<br>
	 * C type : AVHWAccel*
	 */
	public avcodec.AVHWAccel.ByReference hwaccel;
	/**
	 * For some codecs, the time base is closer to the field rate than the frame rate.<br>
	 * Most notably, H.264 and MPEG-2 specify time_base as half of frame duration<br>
	 * if no telecine is used ...<br>
	 * * Set to time_base ticks per frame. Default 1, e.g., H.264/MPEG-2 set it to 2.
	 */
	public int ticks_per_frame;
	/**
	 * Hardware accelerator context.<br>
	 * For some hardware accelerators, a global context needs to be<br>
	 * provided by the user. In that case, this holds display-dependent<br>
	 * data FFmpeg cannot instantiate itself. Please refer to the<br>
	 * FFmpeg HW accelerator documentation to know how to fill this<br>
	 * is. e.g. for VA API, this is a struct vaapi_context.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user<br>
	 * C type : void*
	 */
	public Pointer hwaccel_context;
	/**
	 * Chromaticity coordinates of the source primaries.<br>
	 * - encoding: Set by user<br>
	 * - decoding: Set by libavcodec<br>
	 * @see AVColorPrimaries<br>
	 * C type : AVColorPrimaries
	 */
	public int color_primaries;
	/**
	 * Color Transfer Characteristic.<br>
	 * - encoding: Set by user<br>
	 * - decoding: Set by libavcodec<br>
	 * @see AVColorTransferCharacteristic<br>
	 * C type : AVColorTransferCharacteristic
	 */
	public int color_trc;
	/**
	 * YUV colorspace type.<br>
	 * - encoding: Set by user<br>
	 * - decoding: Set by libavcodec<br>
	 * @see AVColorSpace<br>
	 * C type : AVColorSpace
	 */
	public int colorspace;
	/**
	 * MPEG vs JPEG YUV range.<br>
	 * - encoding: Set by user<br>
	 * - decoding: Set by libavcodec<br>
	 * @see AVColorRange<br>
	 * C type : AVColorRange
	 */
	public int color_range;
	/**
	 * This defines the location of chroma samples.<br>
	 * - encoding: Set by user<br>
	 * - decoding: Set by libavcodec<br>
	 * @see AVChromaLocation<br>
	 * C type : AVChromaLocation
	 */
	public int chroma_sample_location;
	/**
	 * The codec may call this to execute several independent things.<br>
	 * It will return only after finishing all tasks.<br>
	 * The user may replace this with some multithreaded implementation,<br>
	 * the default implementation will execute the parts serially.<br>
	 * Also see avcodec_thread_init and e.g. the --enable-pthread configure option.<br>
	 * @param c context passed also to func<br>
	 * @param count the number of things to execute<br>
	 * @param arg2 argument passed unchanged to func<br>
	 * @param ret return values of executed functions, must have space for "count" values. May be NULL.<br>
	 * @param func function that will be called count times, with jobnr from 0 to count-1.<br>
	 *             threadnr will be in the range 0 to c->thread_count-1 < MAX_THREADS and so that no<br>
	 *             two instances of func executing at the same time will have the same threadnr.<br>
	 * @return always 0 currently, but code should handle a future improvement where when any call to func<br>
	 *         returns < 0 no further calls to func may be done and < 0 is returned.<br>
	 * - encoding: Set by libavcodec, user can override.<br>
	 * - decoding: Set by libavcodec, user can override.<br>
	 * C type : execute2_callback
	 */
	public AVCodecContext.execute2_callback execute2;
	/**
	 * explicit P-frame weighted prediction analysis method<br>
	 * 0: off<br>
	 * 1: fast blind weighting (one reference duplicate with -1 offset)<br>
	 * 2: smart weighting (full fade detection analysis)<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	public int weighted_p_pred;
	/**
	 * AQ mode<br>
	 * 0: Disabled<br>
	 * 1: Variance AQ (complexity mask)<br>
	 * 2: Auto-variance AQ (experimental)<br>
	 * - encoding: Set by user<br>
	 * - decoding: unused
	 */
	public int aq_mode;
	/**
	 * AQ strength<br>
	 * Reduces blocking and blurring in flat and textured areas.<br>
	 * - encoding: Set by user<br>
	 * - decoding: unused
	 */
	public float aq_strength;
	/**
	 * PSY RD<br>
	 * Strength of psychovisual optimization<br>
	 * - encoding: Set by user<br>
	 * - decoding: unused
	 */
	public float psy_rd;
	/**
	 * PSY trellis<br>
	 * Strength of psychovisual optimization<br>
	 * - encoding: Set by user<br>
	 * - decoding: unused
	 */
	public float psy_trellis;
	/**
	 * RC lookahead<br>
	 * Number of frames for frametype and ratecontrol lookahead<br>
	 * - encoding: Set by user<br>
	 * - decoding: unused
	 */
	public int rc_lookahead;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public interface draw_horiz_band_callback extends Callback {
		void apply(AVCodecContext s, AVFrame src, IntByReference offset, int y, int type, int height);
	};
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public interface rtp_callback_callback extends Callback {
		void apply(AVCodecContext avctx, Pointer data, int size, int mb_nb);
	};
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public interface get_buffer_callback extends Callback {
		int apply(AVCodecContext c, AVFrame pic);
	};
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public interface release_buffer_callback extends Callback {
		void apply(AVCodecContext c, AVFrame pic);
	};
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public interface get_format_callback extends Callback {
		PixelFormat apply(AVCodecContext s, Pointer fmt);
	};
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public interface reget_buffer_callback extends Callback {
		int apply(AVCodecContext c, AVFrame pic);
	};
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:2087</i>
	public interface execute_callback_arg1_func_callback extends Callback {
		int apply(AVCodecContext c2, Pointer arg);
	};
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public interface execute_callback extends Callback {
		int apply(AVCodecContext c, AVCodecContext.execute_callback_arg1_func_callback arg1, Pointer arg2, IntByReference ret, int count, int size);
	};
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:2600</i>
	public interface execute2_callback_arg1_func_callback extends Callback {
		int apply(AVCodecContext c2, Pointer arg, int jobnr, int threadnr);
	};
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public interface execute2_callback extends Callback {
		int apply(AVCodecContext c, AVCodecContext.execute2_callback_arg1_func_callback arg1, Pointer arg2, IntByReference ret, int count);
	};
	public AVCodecContext() {
		super();
		initFieldOrder();
	}
	protected void initFieldOrder() {
		setFieldOrder(new java.lang.String[]{"av_class", "bit_rate", "bit_rate_tolerance", "flags", "sub_id", "me_method", "extradata", "extradata_size", "time_base", "width", "height", "gop_size", "pix_fmt", "rate_emu", "draw_horiz_band", "sample_rate", "channels", "sample_fmt", "frame_size", "frame_number", "real_pict_num", "delay", "qcompress", "qblur", "qmin", "qmax", "max_qdiff", "max_b_frames", "b_quant_factor", "rc_strategy", "b_frame_strategy", "hurry_up", "codec", "priv_data", "rtp_payload_size", "rtp_callback", "mv_bits", "header_bits", "i_tex_bits", "p_tex_bits", "i_count", "p_count", "skip_count", "misc_bits", "frame_bits", "opaque", "codec_name", "codec_type", "codec_id", "codec_tag", "workaround_bugs", "luma_elim_threshold", "chroma_elim_threshold", "strict_std_compliance", "b_quant_offset", "error_recognition", "get_buffer", "release_buffer", "has_b_frames", "block_align", "parse_only", "mpeg_quant", "stats_out", "stats_in", "rc_qsquish", "rc_qmod_amp", "rc_qmod_freq", "rc_override", "rc_override_count", "rc_eq", "rc_max_rate", "rc_min_rate", "rc_buffer_size", "rc_buffer_aggressivity", "i_quant_factor", "i_quant_offset", "rc_initial_cplx", "dct_algo", "lumi_masking", "temporal_cplx_masking", "spatial_cplx_masking", "p_masking", "dark_masking", "idct_algo", "slice_count", "slice_offset", "error_concealment", "dsp_mask", "bits_per_coded_sample", "prediction_method", "sample_aspect_ratio", "coded_frame", "debug", "debug_mv", "error", "mb_qmin", "mb_qmax", "me_cmp", "me_sub_cmp", "mb_cmp", "ildct_cmp", "dia_size", "last_predictor_count", "pre_me", "me_pre_cmp", "pre_dia_size", "me_subpel_quality", "get_format", "dtg_active_format", "me_range", "intra_quant_bias", "inter_quant_bias", "color_table_id", "internal_buffer_count", "internal_buffer", "global_quality", "coder_type", "context_model", "slice_flags", "xvmc_acceleration", "mb_decision", "intra_matrix", "inter_matrix", "stream_codec_tag", "scenechange_threshold", "lmin", "lmax", "palctrl", "noise_reduction", "reget_buffer", "rc_initial_buffer_occupancy", "inter_threshold", "flags2", "error_rate", "antialias_algo", "quantizer_noise_shaping", "thread_count", "execute", "thread_opaque", "me_threshold", "mb_threshold", "intra_dc_precision", "nsse_weight", "skip_top", "skip_bottom", "profile", "level", "lowres", "coded_width", "coded_height", "frame_skip_threshold", "frame_skip_factor", "frame_skip_exp", "frame_skip_cmp", "border_masking", "mb_lmin", "mb_lmax", "me_penalty_compensation", "skip_loop_filter", "skip_idct", "skip_frame", "bidir_refine", "brd_scale", "crf", "cqp", "keyint_min", "refs", "chromaoffset", "bframebias", "trellis", "complexityblur", "deblockalpha", "deblockbeta", "partitions", "directpred", "cutoff", "scenechange_factor", "mv0_threshold", "b_sensitivity", "compression_level", "use_lpc", "lpc_coeff_precision", "min_prediction_order", "max_prediction_order", "prediction_order_method", "min_partition_order", "max_partition_order", "timecode_frame_start", "request_channels", "drc_scale", "reordered_opaque", "bits_per_raw_sample", "channel_layout", "request_channel_layout", "rc_max_available_vbv_use", "rc_min_vbv_overflow_use", "hwaccel", "ticks_per_frame", "hwaccel_context", "color_primaries", "color_trc", "colorspace", "color_range", "chroma_sample_location", "execute2", "weighted_p_pred", "aq_mode", "aq_strength", "psy_rd", "psy_trellis", "rc_lookahead"});
	}
	protected ByReference newByReference() { return new ByReference(); }
	protected ByValue newByValue() { return new ByValue(); }
	protected AVCodecContext newInstance() { return new AVCodecContext(); }
	public static AVCodecContext[] newArray(int arrayLength) {
		return Structure.newArray(AVCodecContext.class, arrayLength);
	}
	public static class ByReference extends AVCodecContext implements Structure.ByReference {
		
	};
	public static class ByValue extends AVCodecContext implements Structure.ByValue {
		
	};
}
