package avcodec;
import com.ochafik.lang.jnaerator.runtime.Structure;
import com.sun.jna.Callback;
import com.sun.jna.Pointer;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.LongByReference;
/**
 * <i>native declaration : src/main/headers/libavcodec/avcodec.h</i><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.free.fr/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public class AVCodec extends Structure<AVCodec, AVCodec.ByValue, AVCodec.ByReference > {
	/**
	 * Name of the codec implementation.<br>
	 * The name is globally unique among encoders and among decoders (but an<br>
	 * encoder and a decoder can share the same name).<br>
	 * This is the primary way to find a codec from the user perspective.<br>
	 * C type : const char*
	 */
	public Pointer name;
	/**
	 * @see AVMediaType<br>
	 * C type : AVMediaType
	 */
	public int type;
	/**
	 * @see CodecID<br>
	 * C type : CodecID
	 */
	public int id;
	public int priv_data_size;
	/// C type : init_callback
	public AVCodec.init_callback init;
	/// C type : encode_callback
	public AVCodec.encode_callback encode;
	/// C type : close_callback
	public avcodec.AVBitStreamFilter.close_callback close;
	/// C type : decode_callback
	public AVCodec.decode_callback decode;
	/**
	 * Codec capabilities.<br>
	 * see CODEC_CAP_*
	 */
	public int capabilities;
	/// C type : AVCodec*
	public AVCodec.ByReference next;
	/**
	 * Flush buffers.<br>
	 * Will be called when seeking<br>
	 * C type : flush_callback
	 */
	public AVCodec.flush_callback flush;
	/**
	 * < array of supported framerates, or NULL if any, array is terminated by {0,0}<br>
	 * C type : const AVRational*
	 */
	public avutil.AVRational.ByReference supported_framerates;
	/**
	 * < array of supported pixel formats, or NULL if unknown, array is terminated by -1<br>
	 * C type : PixelFormat*
	 */
	public IntByReference pix_fmts;
	/**
	 * Descriptive name for the codec, meant to be more human readable than name.<br>
	 * You should use the NULL_IF_CONFIG_SMALL() macro to define it.<br>
	 * C type : const char*
	 */
	public Pointer long_name;
	/**
	 * < array of supported audio samplerates, or NULL if unknown, array is terminated by 0<br>
	 * C type : const int*
	 */
	public IntByReference supported_samplerates;
	/**
	 * < array of supported sample formats, or NULL if unknown, array is terminated by -1<br>
	 * C type : SampleFormat*
	 */
	public IntByReference sample_fmts;
	/**
	 * < array of support channel layouts, or NULL if unknown. array is terminated by 0<br>
	 * C type : const int64_t*
	 */
	public LongByReference channel_layouts;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public interface init_callback extends Callback {
		int apply(AVCodecContext AVCodecContextPtr1);
	};
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public interface encode_callback extends Callback {
		int apply(AVCodecContext AVCodecContextPtr1, Pointer buf, int buf_size, Pointer data);
	};
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public interface close_callback extends Callback {
		int apply(AVCodecContext AVCodecContextPtr1);
	};
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public interface decode_callback extends Callback {
		int apply(AVCodecContext AVCodecContextPtr1, Pointer outdata, IntByReference outdata_size, AVPacket avpkt);
	};
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public interface flush_callback extends Callback {
		void apply(AVCodecContext AVCodecContextPtr1);
	};
	public AVCodec() {
		super();
		initFieldOrder();
	}
	protected void initFieldOrder() {
		setFieldOrder(new java.lang.String[]{"name", "type", "id", "priv_data_size", "init", "encode", "close", "decode", "capabilities", "next", "flush", "supported_framerates", "pix_fmts", "long_name", "supported_samplerates", "sample_fmts", "channel_layouts"});
	}
	protected ByReference newByReference() { return new ByReference(); }
	protected ByValue newByValue() { return new ByValue(); }
	protected AVCodec newInstance() { return new AVCodec(); }
	public static AVCodec[] newArray(int arrayLength) {
		return Structure.newArray(AVCodec.class, arrayLength);
	}
	public static class ByReference extends AVCodec implements Structure.ByReference {
		
	};
	public static class ByValue extends AVCodec implements Structure.ByValue {
		
	};
}
