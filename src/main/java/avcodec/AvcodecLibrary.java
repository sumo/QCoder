package avcodec;
import avcodec.AVOption.ByReference;
import avutil.AVRational.ByValue;
import avutil.AVRational;
import com.ochafik.lang.jnaerator.runtime.LibraryExtractor;
import com.ochafik.lang.jnaerator.runtime.MangledFunctionMapper;
import com.ochafik.lang.jnaerator.runtime.Mangling;
import com.sun.jna.Callback;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.Pointer;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;
import com.sun.jna.ptr.ShortByReference;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.nio.ShortBuffer;
/**
 * JNA Wrapper for library <b>avcodec</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.free.fr/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface AvcodecLibrary extends Library {
	public static final String JNA_LIBRARY_NAME = LibraryExtractor.getLibraryPath("avcodec", true, avcodec.AvcodecLibrary.class);
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(avcodec.AvcodecLibrary.JNA_LIBRARY_NAME, com.ochafik.lang.jnaerator.runtime.MangledFunctionMapper.DEFAULT_OPTIONS);
	public static final AvcodecLibrary INSTANCE = (AvcodecLibrary)Native.loadLibrary(avcodec.AvcodecLibrary.JNA_LIBRARY_NAME, avcodec.AvcodecLibrary.class, com.ochafik.lang.jnaerator.runtime.MangledFunctionMapper.DEFAULT_OPTIONS);
	/**
	 * <i>native declaration : src/main/headers/libavutil/avutil.h:71</i><br>
	 * enum values
	 */
	public static interface AVMediaType {
		/// <i>native declaration : src/main/headers/libavutil/avutil.h:72</i>
		public static final int AVMEDIA_TYPE_UNKNOWN = -1;
		/// <i>native declaration : src/main/headers/libavutil/avutil.h:73</i>
		public static final int AVMEDIA_TYPE_VIDEO = 0;
		/// <i>native declaration : src/main/headers/libavutil/avutil.h:74</i>
		public static final int AVMEDIA_TYPE_AUDIO = 1;
		/// <i>native declaration : src/main/headers/libavutil/avutil.h:75</i>
		public static final int AVMEDIA_TYPE_DATA = 2;
		/// <i>native declaration : src/main/headers/libavutil/avutil.h:76</i>
		public static final int AVMEDIA_TYPE_SUBTITLE = 3;
		/// <i>native declaration : src/main/headers/libavutil/avutil.h:77</i>
		public static final int AVMEDIA_TYPE_ATTACHMENT = 4;
		/// <i>native declaration : src/main/headers/libavutil/avutil.h:78</i>
		public static final int AVMEDIA_TYPE_NB = 5;
	};
	/**
	 * <i>native declaration : src/main/headers/libavcodec/opt.h:32</i><br>
	 * enum values
	 */
	public static interface AVOptionType {
		/// <i>native declaration : src/main/headers/libavcodec/opt.h:33</i>
		public static final int FF_OPT_TYPE_FLAGS = 0;
		/// <i>native declaration : src/main/headers/libavcodec/opt.h:34</i>
		public static final int FF_OPT_TYPE_INT = 1;
		/// <i>native declaration : src/main/headers/libavcodec/opt.h:35</i>
		public static final int FF_OPT_TYPE_INT64 = 2;
		/// <i>native declaration : src/main/headers/libavcodec/opt.h:36</i>
		public static final int FF_OPT_TYPE_DOUBLE = 3;
		/// <i>native declaration : src/main/headers/libavcodec/opt.h:37</i>
		public static final int FF_OPT_TYPE_FLOAT = 4;
		/// <i>native declaration : src/main/headers/libavcodec/opt.h:38</i>
		public static final int FF_OPT_TYPE_STRING = 5;
		/// <i>native declaration : src/main/headers/libavcodec/opt.h:39</i>
		public static final int FF_OPT_TYPE_RATIONAL = 6;
		/**
		 * < offset must point to a pointer immediately followed by an int for the length<br>
		 * <i>native declaration : src/main/headers/libavcodec/opt.h:40</i>
		 */
		public static final int FF_OPT_TYPE_BINARY = 7;
		/// <i>native declaration : src/main/headers/libavcodec/opt.h:41</i>
		public static final int FF_OPT_TYPE_CONST = 128;
	};
	/**
	 * Identifies the syntax and semantics of the bitstream.<br>
	 * The principle is roughly:<br>
	 * Two decoders with the same ID can decode the same streams.<br>
	 * Two encoders with the same ID can encode compatible streams.<br>
	 * There may be slight deviations from the principle due to implementation<br>
	 * details.<br>
	 * * If you add a codec ID to this list, add it so that<br>
	 * 1. no value of a existing codec ID changes (that would break ABI),<br>
	 * 2. it is as close as possible to similar codecs.<br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:61</i><br>
	 * enum values
	 */
	public static interface CodecID {
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:62</i>
		public static final int CODEC_ID_NONE = 0;
		/**
		 * video codecs<br>
		 * video codecs<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:65</i>
		 */
		public static final int CODEC_ID_MPEG1VIDEO = 1;
		/**
		 * < preferred ID for MPEG-1/2 video decoding<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:66</i>
		 */
		public static final int CODEC_ID_MPEG2VIDEO = 2;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:67</i>
		public static final int CODEC_ID_MPEG2VIDEO_XVMC = 3;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:68</i>
		public static final int CODEC_ID_H261 = 4;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:69</i>
		public static final int CODEC_ID_H263 = 5;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:70</i>
		public static final int CODEC_ID_RV10 = 6;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:71</i>
		public static final int CODEC_ID_RV20 = 7;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:72</i>
		public static final int CODEC_ID_MJPEG = 8;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:73</i>
		public static final int CODEC_ID_MJPEGB = 9;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:74</i>
		public static final int CODEC_ID_LJPEG = 10;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:75</i>
		public static final int CODEC_ID_SP5X = 11;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:76</i>
		public static final int CODEC_ID_JPEGLS = 12;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:77</i>
		public static final int CODEC_ID_MPEG4 = 13;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:78</i>
		public static final int CODEC_ID_RAWVIDEO = 14;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:79</i>
		public static final int CODEC_ID_MSMPEG4V1 = 15;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:80</i>
		public static final int CODEC_ID_MSMPEG4V2 = 16;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:81</i>
		public static final int CODEC_ID_MSMPEG4V3 = 17;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:82</i>
		public static final int CODEC_ID_WMV1 = 18;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:83</i>
		public static final int CODEC_ID_WMV2 = 19;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:84</i>
		public static final int CODEC_ID_H263P = 20;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:85</i>
		public static final int CODEC_ID_H263I = 21;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:86</i>
		public static final int CODEC_ID_FLV1 = 22;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:87</i>
		public static final int CODEC_ID_SVQ1 = 23;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:88</i>
		public static final int CODEC_ID_SVQ3 = 24;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:89</i>
		public static final int CODEC_ID_DVVIDEO = 25;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:90</i>
		public static final int CODEC_ID_HUFFYUV = 26;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:91</i>
		public static final int CODEC_ID_CYUV = 27;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:92</i>
		public static final int CODEC_ID_H264 = 28;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:93</i>
		public static final int CODEC_ID_INDEO3 = 29;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:94</i>
		public static final int CODEC_ID_VP3 = 30;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:95</i>
		public static final int CODEC_ID_THEORA = 31;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:96</i>
		public static final int CODEC_ID_ASV1 = 32;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:97</i>
		public static final int CODEC_ID_ASV2 = 33;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:98</i>
		public static final int CODEC_ID_FFV1 = 34;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:99</i>
		public static final int CODEC_ID_4XM = 35;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:100</i>
		public static final int CODEC_ID_VCR1 = 36;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:101</i>
		public static final int CODEC_ID_CLJR = 37;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:102</i>
		public static final int CODEC_ID_MDEC = 38;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:103</i>
		public static final int CODEC_ID_ROQ = 39;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:104</i>
		public static final int CODEC_ID_INTERPLAY_VIDEO = 40;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:105</i>
		public static final int CODEC_ID_XAN_WC3 = 41;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:106</i>
		public static final int CODEC_ID_XAN_WC4 = 42;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:107</i>
		public static final int CODEC_ID_RPZA = 43;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:108</i>
		public static final int CODEC_ID_CINEPAK = 44;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:109</i>
		public static final int CODEC_ID_WS_VQA = 45;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:110</i>
		public static final int CODEC_ID_MSRLE = 46;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:111</i>
		public static final int CODEC_ID_MSVIDEO1 = 47;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:112</i>
		public static final int CODEC_ID_IDCIN = 48;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:113</i>
		public static final int CODEC_ID_8BPS = 49;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:114</i>
		public static final int CODEC_ID_SMC = 50;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:115</i>
		public static final int CODEC_ID_FLIC = 51;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:116</i>
		public static final int CODEC_ID_TRUEMOTION1 = 52;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:117</i>
		public static final int CODEC_ID_VMDVIDEO = 53;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:118</i>
		public static final int CODEC_ID_MSZH = 54;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:119</i>
		public static final int CODEC_ID_ZLIB = 55;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:120</i>
		public static final int CODEC_ID_QTRLE = 56;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:121</i>
		public static final int CODEC_ID_SNOW = 57;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:122</i>
		public static final int CODEC_ID_TSCC = 58;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:123</i>
		public static final int CODEC_ID_ULTI = 59;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:124</i>
		public static final int CODEC_ID_QDRAW = 60;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:125</i>
		public static final int CODEC_ID_VIXL = 61;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:126</i>
		public static final int CODEC_ID_QPEG = 62;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:128</i>
		public static final int CODEC_ID_XVID = 63;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:130</i>
		public static final int CODEC_ID_PNG = 64;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:131</i>
		public static final int CODEC_ID_PPM = 65;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:132</i>
		public static final int CODEC_ID_PBM = 66;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:133</i>
		public static final int CODEC_ID_PGM = 67;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:134</i>
		public static final int CODEC_ID_PGMYUV = 68;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:135</i>
		public static final int CODEC_ID_PAM = 69;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:136</i>
		public static final int CODEC_ID_FFVHUFF = 70;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:137</i>
		public static final int CODEC_ID_RV30 = 71;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:138</i>
		public static final int CODEC_ID_RV40 = 72;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:139</i>
		public static final int CODEC_ID_VC1 = 73;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:140</i>
		public static final int CODEC_ID_WMV3 = 74;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:141</i>
		public static final int CODEC_ID_LOCO = 75;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:142</i>
		public static final int CODEC_ID_WNV1 = 76;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:143</i>
		public static final int CODEC_ID_AASC = 77;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:144</i>
		public static final int CODEC_ID_INDEO2 = 78;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:145</i>
		public static final int CODEC_ID_FRAPS = 79;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:146</i>
		public static final int CODEC_ID_TRUEMOTION2 = 80;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:147</i>
		public static final int CODEC_ID_BMP = 81;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:148</i>
		public static final int CODEC_ID_CSCD = 82;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:149</i>
		public static final int CODEC_ID_MMVIDEO = 83;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:150</i>
		public static final int CODEC_ID_ZMBV = 84;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:151</i>
		public static final int CODEC_ID_AVS = 85;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:152</i>
		public static final int CODEC_ID_SMACKVIDEO = 86;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:153</i>
		public static final int CODEC_ID_NUV = 87;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:154</i>
		public static final int CODEC_ID_KMVC = 88;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:155</i>
		public static final int CODEC_ID_FLASHSV = 89;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:156</i>
		public static final int CODEC_ID_CAVS = 90;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:157</i>
		public static final int CODEC_ID_JPEG2000 = 91;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:158</i>
		public static final int CODEC_ID_VMNC = 92;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:159</i>
		public static final int CODEC_ID_VP5 = 93;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:160</i>
		public static final int CODEC_ID_VP6 = 94;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:161</i>
		public static final int CODEC_ID_VP6F = 95;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:162</i>
		public static final int CODEC_ID_TARGA = 96;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:163</i>
		public static final int CODEC_ID_DSICINVIDEO = 97;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:164</i>
		public static final int CODEC_ID_TIERTEXSEQVIDEO = 98;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:165</i>
		public static final int CODEC_ID_TIFF = 99;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:166</i>
		public static final int CODEC_ID_GIF = 100;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:167</i>
		public static final int CODEC_ID_FFH264 = 101;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:168</i>
		public static final int CODEC_ID_DXA = 102;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:169</i>
		public static final int CODEC_ID_DNXHD = 103;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:170</i>
		public static final int CODEC_ID_THP = 104;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:171</i>
		public static final int CODEC_ID_SGI = 105;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:172</i>
		public static final int CODEC_ID_C93 = 106;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:173</i>
		public static final int CODEC_ID_BETHSOFTVID = 107;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:174</i>
		public static final int CODEC_ID_PTX = 108;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:175</i>
		public static final int CODEC_ID_TXD = 109;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:176</i>
		public static final int CODEC_ID_VP6A = 110;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:177</i>
		public static final int CODEC_ID_AMV = 111;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:178</i>
		public static final int CODEC_ID_VB = 112;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:179</i>
		public static final int CODEC_ID_PCX = 113;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:180</i>
		public static final int CODEC_ID_SUNRAST = 114;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:181</i>
		public static final int CODEC_ID_INDEO4 = 115;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:182</i>
		public static final int CODEC_ID_INDEO5 = 116;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:183</i>
		public static final int CODEC_ID_MIMIC = 117;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:184</i>
		public static final int CODEC_ID_RL2 = 118;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:185</i>
		public static final int CODEC_ID_8SVX_EXP = 119;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:186</i>
		public static final int CODEC_ID_8SVX_FIB = 120;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:187</i>
		public static final int CODEC_ID_ESCAPE124 = 121;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:188</i>
		public static final int CODEC_ID_DIRAC = 122;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:189</i>
		public static final int CODEC_ID_BFI = 123;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:190</i>
		public static final int CODEC_ID_CMV = 124;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:191</i>
		public static final int CODEC_ID_MOTIONPIXELS = 125;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:192</i>
		public static final int CODEC_ID_TGV = 126;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:193</i>
		public static final int CODEC_ID_TGQ = 127;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:194</i>
		public static final int CODEC_ID_TQI = 128;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:195</i>
		public static final int CODEC_ID_AURA = 129;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:196</i>
		public static final int CODEC_ID_AURA2 = 130;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:197</i>
		public static final int CODEC_ID_V210X = 131;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:198</i>
		public static final int CODEC_ID_TMV = 132;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:199</i>
		public static final int CODEC_ID_V210 = 133;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:200</i>
		public static final int CODEC_ID_DPX = 134;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:201</i>
		public static final int CODEC_ID_MAD = 135;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:202</i>
		public static final int CODEC_ID_FRWU = 136;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:203</i>
		public static final int CODEC_ID_FLASHSV2 = 137;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:204</i>
		public static final int CODEC_ID_CDGRAPHICS = 138;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:205</i>
		public static final int CODEC_ID_R210 = 139;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:206</i>
		public static final int CODEC_ID_ANM = 140;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:207</i>
		public static final int CODEC_ID_BINKVIDEO = 141;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:208</i>
		public static final int CODEC_ID_IFF_ILBM = 142;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:209</i>
		public static final int CODEC_ID_IFF_BYTERUN1 = 143;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:210</i>
		public static final int CODEC_ID_KGV1 = 144;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:211</i>
		public static final int CODEC_ID_YOP = 145;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:212</i>
		public static final int CODEC_ID_VP8 = 146;
		/**
		 * various PCM "codecs"<br>
		 * various PCM "codecs"<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:215</i>
		 */
		public static final int CODEC_ID_PCM_S16LE = 65536;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:216</i>
		public static final int CODEC_ID_PCM_S16BE = 65537;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:217</i>
		public static final int CODEC_ID_PCM_U16LE = 65538;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:218</i>
		public static final int CODEC_ID_PCM_U16BE = 65539;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:219</i>
		public static final int CODEC_ID_PCM_S8 = 65540;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:220</i>
		public static final int CODEC_ID_PCM_U8 = 65541;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:221</i>
		public static final int CODEC_ID_PCM_MULAW = 65542;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:222</i>
		public static final int CODEC_ID_PCM_ALAW = 65543;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:223</i>
		public static final int CODEC_ID_PCM_S32LE = 65544;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:224</i>
		public static final int CODEC_ID_PCM_S32BE = 65545;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:225</i>
		public static final int CODEC_ID_PCM_U32LE = 65546;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:226</i>
		public static final int CODEC_ID_PCM_U32BE = 65547;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:227</i>
		public static final int CODEC_ID_PCM_S24LE = 65548;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:228</i>
		public static final int CODEC_ID_PCM_S24BE = 65549;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:229</i>
		public static final int CODEC_ID_PCM_U24LE = 65550;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:230</i>
		public static final int CODEC_ID_PCM_U24BE = 65551;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:231</i>
		public static final int CODEC_ID_PCM_S24DAUD = 65552;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:232</i>
		public static final int CODEC_ID_PCM_ZORK = 65553;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:233</i>
		public static final int CODEC_ID_PCM_S16LE_PLANAR = 65554;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:234</i>
		public static final int CODEC_ID_PCM_DVD = 65555;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:235</i>
		public static final int CODEC_ID_PCM_F32BE = 65556;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:236</i>
		public static final int CODEC_ID_PCM_F32LE = 65557;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:237</i>
		public static final int CODEC_ID_PCM_F64BE = 65558;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:238</i>
		public static final int CODEC_ID_PCM_F64LE = 65559;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:239</i>
		public static final int CODEC_ID_PCM_BLURAY = 65560;
		/**
		 * various ADPCM codecs<br>
		 * various ADPCM codecs<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:242</i>
		 */
		public static final int CODEC_ID_ADPCM_IMA_QT = 69632;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:243</i>
		public static final int CODEC_ID_ADPCM_IMA_WAV = 69633;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:244</i>
		public static final int CODEC_ID_ADPCM_IMA_DK3 = 69634;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:245</i>
		public static final int CODEC_ID_ADPCM_IMA_DK4 = 69635;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:246</i>
		public static final int CODEC_ID_ADPCM_IMA_WS = 69636;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:247</i>
		public static final int CODEC_ID_ADPCM_IMA_SMJPEG = 69637;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:248</i>
		public static final int CODEC_ID_ADPCM_MS = 69638;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:249</i>
		public static final int CODEC_ID_ADPCM_4XM = 69639;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:250</i>
		public static final int CODEC_ID_ADPCM_XA = 69640;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:251</i>
		public static final int CODEC_ID_ADPCM_ADX = 69641;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:252</i>
		public static final int CODEC_ID_ADPCM_EA = 69642;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:253</i>
		public static final int CODEC_ID_ADPCM_G726 = 69643;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:254</i>
		public static final int CODEC_ID_ADPCM_CT = 69644;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:255</i>
		public static final int CODEC_ID_ADPCM_SWF = 69645;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:256</i>
		public static final int CODEC_ID_ADPCM_YAMAHA = 69646;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:257</i>
		public static final int CODEC_ID_ADPCM_SBPRO_4 = 69647;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:258</i>
		public static final int CODEC_ID_ADPCM_SBPRO_3 = 69648;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:259</i>
		public static final int CODEC_ID_ADPCM_SBPRO_2 = 69649;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:260</i>
		public static final int CODEC_ID_ADPCM_THP = 69650;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:261</i>
		public static final int CODEC_ID_ADPCM_IMA_AMV = 69651;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:262</i>
		public static final int CODEC_ID_ADPCM_EA_R1 = 69652;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:263</i>
		public static final int CODEC_ID_ADPCM_EA_R3 = 69653;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:264</i>
		public static final int CODEC_ID_ADPCM_EA_R2 = 69654;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:265</i>
		public static final int CODEC_ID_ADPCM_IMA_EA_SEAD = 69655;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:266</i>
		public static final int CODEC_ID_ADPCM_IMA_EA_EACS = 69656;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:267</i>
		public static final int CODEC_ID_ADPCM_EA_XAS = 69657;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:268</i>
		public static final int CODEC_ID_ADPCM_EA_MAXIS_XA = 69658;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:269</i>
		public static final int CODEC_ID_ADPCM_IMA_ISS = 69659;
		/**
		 * AMR<br>
		 * AMR<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:272</i>
		 */
		public static final int CODEC_ID_AMR_NB = 73728;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:273</i>
		public static final int CODEC_ID_AMR_WB = 73729;
		/**
		 * RealAudio codecs<br>
		 * RealAudio codecs<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:276</i>
		 */
		public static final int CODEC_ID_RA_144 = 77824;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:277</i>
		public static final int CODEC_ID_RA_288 = 77825;
		/**
		 * various DPCM codecs<br>
		 * various DPCM codecs<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:280</i>
		 */
		public static final int CODEC_ID_ROQ_DPCM = 81920;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:281</i>
		public static final int CODEC_ID_INTERPLAY_DPCM = 81921;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:282</i>
		public static final int CODEC_ID_XAN_DPCM = 81922;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:283</i>
		public static final int CODEC_ID_SOL_DPCM = 81923;
		/**
		 * audio codecs<br>
		 * audio codecs<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:286</i>
		 */
		public static final int CODEC_ID_MP2 = 86016;
		/**
		 * < preferred ID for decoding MPEG audio layer 1, 2 or 3<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:287</i>
		 */
		public static final int CODEC_ID_MP3 = 86017;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:288</i>
		public static final int CODEC_ID_AAC = 86018;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:289</i>
		public static final int CODEC_ID_AC3 = 86019;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:290</i>
		public static final int CODEC_ID_DTS = 86020;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:291</i>
		public static final int CODEC_ID_VORBIS = 86021;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:292</i>
		public static final int CODEC_ID_DVAUDIO = 86022;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:293</i>
		public static final int CODEC_ID_WMAV1 = 86023;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:294</i>
		public static final int CODEC_ID_WMAV2 = 86024;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:295</i>
		public static final int CODEC_ID_MACE3 = 86025;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:296</i>
		public static final int CODEC_ID_MACE6 = 86026;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:297</i>
		public static final int CODEC_ID_VMDAUDIO = 86027;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:298</i>
		public static final int CODEC_ID_SONIC = 86028;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:299</i>
		public static final int CODEC_ID_SONIC_LS = 86029;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:300</i>
		public static final int CODEC_ID_FLAC = 86030;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:301</i>
		public static final int CODEC_ID_MP3ADU = 86031;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:302</i>
		public static final int CODEC_ID_MP3ON4 = 86032;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:303</i>
		public static final int CODEC_ID_SHORTEN = 86033;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:304</i>
		public static final int CODEC_ID_ALAC = 86034;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:305</i>
		public static final int CODEC_ID_WESTWOOD_SND1 = 86035;
		/**
		 * < as in Berlin toast format<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:306</i>
		 */
		public static final int CODEC_ID_GSM = 86036;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:307</i>
		public static final int CODEC_ID_QDM2 = 86037;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:308</i>
		public static final int CODEC_ID_COOK = 86038;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:309</i>
		public static final int CODEC_ID_TRUESPEECH = 86039;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:310</i>
		public static final int CODEC_ID_TTA = 86040;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:311</i>
		public static final int CODEC_ID_SMACKAUDIO = 86041;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:312</i>
		public static final int CODEC_ID_QCELP = 86042;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:313</i>
		public static final int CODEC_ID_WAVPACK = 86043;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:314</i>
		public static final int CODEC_ID_DSICINAUDIO = 86044;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:315</i>
		public static final int CODEC_ID_IMC = 86045;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:316</i>
		public static final int CODEC_ID_MUSEPACK7 = 86046;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:317</i>
		public static final int CODEC_ID_MLP = 86047;
		/**
		 * as found in WAV<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:318</i>
		 */
		public static final int CODEC_ID_GSM_MS = 86048;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:319</i>
		public static final int CODEC_ID_ATRAC3 = 86049;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:320</i>
		public static final int CODEC_ID_VOXWARE = 86050;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:321</i>
		public static final int CODEC_ID_APE = 86051;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:322</i>
		public static final int CODEC_ID_NELLYMOSER = 86052;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:323</i>
		public static final int CODEC_ID_MUSEPACK8 = 86053;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:324</i>
		public static final int CODEC_ID_SPEEX = 86054;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:325</i>
		public static final int CODEC_ID_WMAVOICE = 86055;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:326</i>
		public static final int CODEC_ID_WMAPRO = 86056;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:327</i>
		public static final int CODEC_ID_WMALOSSLESS = 86057;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:328</i>
		public static final int CODEC_ID_ATRAC3P = 86058;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:329</i>
		public static final int CODEC_ID_EAC3 = 86059;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:330</i>
		public static final int CODEC_ID_SIPR = 86060;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:331</i>
		public static final int CODEC_ID_MP1 = 86061;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:332</i>
		public static final int CODEC_ID_TWINVQ = 86062;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:333</i>
		public static final int CODEC_ID_TRUEHD = 86063;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:334</i>
		public static final int CODEC_ID_MP4ALS = 86064;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:335</i>
		public static final int CODEC_ID_ATRAC1 = 86065;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:336</i>
		public static final int CODEC_ID_BINKAUDIO_RDFT = 86066;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:337</i>
		public static final int CODEC_ID_BINKAUDIO_DCT = 86067;
		/**
		 * subtitle codecs<br>
		 * subtitle codecs<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:340</i>
		 */
		public static final int CODEC_ID_DVD_SUBTITLE = 94208;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:341</i>
		public static final int CODEC_ID_DVB_SUBTITLE = 94209;
		/**
		 * < raw UTF-8 text<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:342</i>
		 */
		public static final int CODEC_ID_TEXT = 94210;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:343</i>
		public static final int CODEC_ID_XSUB = 94211;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:344</i>
		public static final int CODEC_ID_SSA = 94212;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:345</i>
		public static final int CODEC_ID_MOV_TEXT = 94213;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:346</i>
		public static final int CODEC_ID_HDMV_PGS_SUBTITLE = 94214;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:347</i>
		public static final int CODEC_ID_DVB_TELETEXT = 94215;
		/**
		 * other specific kind of codecs (generally used for attachments)<br>
		 * other specific kind of codecs (generally used for attachments)<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:350</i>
		 */
		public static final int CODEC_ID_TTF = 98304;
		/**
		 * < codec_id is not known (like CODEC_ID_NONE) but lavf should attempt to identify it<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:352</i>
		 */
		public static final int CODEC_ID_PROBE = 102400;
		/**
		 * < _FAKE_ codec to indicate a raw MPEG-2 TS<br>
		 * stream (only used by libavformat)<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:354</i>
		 */
		public static final int CODEC_ID_MPEG2TS = 131072;
	};
	/**
	 * all in native-endian format<br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:373</i><br>
	 * enum values
	 */
	public static interface SampleFormat {
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:374</i>
		public static final int SAMPLE_FMT_NONE = -1;
		/**
		 * < unsigned 8 bits<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:375</i>
		 */
		public static final int SAMPLE_FMT_U8 = 0;
		/**
		 * < signed 16 bits<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:376</i>
		 */
		public static final int SAMPLE_FMT_S16 = 1;
		/**
		 * < signed 32 bits<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:377</i>
		 */
		public static final int SAMPLE_FMT_S32 = 2;
		/**
		 * < float<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:378</i>
		 */
		public static final int SAMPLE_FMT_FLT = 3;
		/**
		 * < double<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:379</i>
		 */
		public static final int SAMPLE_FMT_DBL = 4;
		/**
		 * < Number of sample formats. DO NOT USE if dynamically linking to libavcodec<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:380</i>
		 */
		public static final int SAMPLE_FMT_NB = 5;
	};
	/**
	 * motion estimation type.<br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:450</i><br>
	 * enum values
	 */
	public static interface Motion_Est_ID {
		/**
		 * < no search, that is use 0,0 vector whenever one is needed<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:451</i>
		 */
		public static final int ME_ZERO = 1;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:452</i>
		public static final int ME_FULL = 2;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:453</i>
		public static final int ME_LOG = 3;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:454</i>
		public static final int ME_PHODS = 4;
		/**
		 * < enhanced predictive zonal search<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:455</i>
		 */
		public static final int ME_EPZS = 5;
		/**
		 * < reserved for experiments<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:456</i>
		 */
		public static final int ME_X1 = 6;
		/**
		 * < hexagon based search<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:457</i>
		 */
		public static final int ME_HEX = 7;
		/**
		 * < uneven multi-hexagon search<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:458</i>
		 */
		public static final int ME_UMH = 8;
		/**
		 * < iterative search<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:459</i>
		 */
		public static final int ME_ITER = 9;
		/**
		 * < transformed exhaustive search algorithm<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:460</i>
		 */
		public static final int ME_TESA = 10;
	};
	/**
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:463</i><br>
	 * enum values
	 */
	public static interface AVDiscard {
		/**
		 * We leave some space between them for extensions (drop some<br>
		 * keyframes for intra-only or drop just some bidir frames).<br>
		 * We leave some space between them for extensions (drop some<br>
		 * keyframes for intra-only or drop just some bidir frames).<br>
		 * < discard nothing<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:466</i>
		 */
		public static final int AVDISCARD_NONE = -16;
		/**
		 * < discard useless packets like 0 size packets in avi<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:467</i>
		 */
		public static final int AVDISCARD_DEFAULT = 0;
		/**
		 * < discard all non reference<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:468</i>
		 */
		public static final int AVDISCARD_NONREF = 8;
		/**
		 * < discard all bidirectional frames<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:469</i>
		 */
		public static final int AVDISCARD_BIDIR = 16;
		/**
		 * < discard all frames except keyframes<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:470</i>
		 */
		public static final int AVDISCARD_NONKEY = 32;
		/**
		 * < discard all<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:471</i>
		 */
		public static final int AVDISCARD_ALL = 48;
	};
	/**
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:474</i><br>
	 * enum values
	 */
	public static interface AVColorPrimaries {
		/**
		 * < also ITU-R BT1361 / IEC 61966-2-4 / SMPTE RP177 Annex B<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:475</i>
		 */
		public static final int AVCOL_PRI_BT709 = 1;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:476</i>
		public static final int AVCOL_PRI_UNSPECIFIED = 2;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:477</i>
		public static final int AVCOL_PRI_BT470M = 4;
		/**
		 * < also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:478</i>
		 */
		public static final int AVCOL_PRI_BT470BG = 5;
		/**
		 * < also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:479</i>
		 */
		public static final int AVCOL_PRI_SMPTE170M = 6;
		/**
		 * < functionally identical to above<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:480</i>
		 */
		public static final int AVCOL_PRI_SMPTE240M = 7;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:481</i>
		public static final int AVCOL_PRI_FILM = 8;
		/**
		 * < Not part of ABI<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:482</i>
		 */
		public static final int AVCOL_PRI_NB = 9;
	};
	/**
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:485</i><br>
	 * enum values
	 */
	public static interface AVColorTransferCharacteristic {
		/**
		 * < also ITU-R BT1361<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:486</i>
		 */
		public static final int AVCOL_TRC_BT709 = 1;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:487</i>
		public static final int AVCOL_TRC_UNSPECIFIED = 2;
		/**
		 * < also ITU-R BT470M / ITU-R BT1700 625 PAL & SECAM<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:488</i>
		 */
		public static final int AVCOL_TRC_GAMMA22 = 4;
		/**
		 * < also ITU-R BT470BG<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:489</i>
		 */
		public static final int AVCOL_TRC_GAMMA28 = 5;
		/**
		 * < Not part of ABI<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:490</i>
		 */
		public static final int AVCOL_TRC_NB = 6;
	};
	/**
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:493</i><br>
	 * enum values
	 */
	public static interface AVColorSpace {
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:494</i>
		public static final int AVCOL_SPC_RGB = 0;
		/**
		 * < also ITU-R BT1361 / IEC 61966-2-4 xvYCC709 / SMPTE RP177 Annex B<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:495</i>
		 */
		public static final int AVCOL_SPC_BT709 = 1;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:496</i>
		public static final int AVCOL_SPC_UNSPECIFIED = 2;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:497</i>
		public static final int AVCOL_SPC_FCC = 4;
		/**
		 * < also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM / IEC 61966-2-4 xvYCC601<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:498</i>
		 */
		public static final int AVCOL_SPC_BT470BG = 5;
		/**
		 * < also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC / functionally identical to above<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:499</i>
		 */
		public static final int AVCOL_SPC_SMPTE170M = 6;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:500</i>
		public static final int AVCOL_SPC_SMPTE240M = 7;
		/**
		 * < Not part of ABI<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:501</i>
		 */
		public static final int AVCOL_SPC_NB = 8;
	};
	/**
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:504</i><br>
	 * enum values
	 */
	public static interface AVColorRange {
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:505</i>
		public static final int AVCOL_RANGE_UNSPECIFIED = 0;
		/**
		 * < the normal 219*2^(n-8) "MPEG" YUV ranges<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:506</i>
		 */
		public static final int AVCOL_RANGE_MPEG = 1;
		/**
		 * < the normal     2^n-1   "JPEG" YUV ranges<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:507</i>
		 */
		public static final int AVCOL_RANGE_JPEG = 2;
		/**
		 * < Not part of ABI<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:508</i>
		 */
		public static final int AVCOL_RANGE_NB = 3;
	};
	/**
	 * X   X      3 4 X      X are luma samples,<br>
	 *             1 2        1-6 are possible chroma positions<br>
	 *  X   X      5 6 X      0 is undefined/unknown position<br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:516</i><br>
	 * enum values
	 */
	public static interface AVChromaLocation {
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:517</i>
		public static final int AVCHROMA_LOC_UNSPECIFIED = 0;
		/**
		 * < mpeg2/4, h264 default<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:518</i>
		 */
		public static final int AVCHROMA_LOC_LEFT = 1;
		/**
		 * < mpeg1, jpeg, h263<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:519</i>
		 */
		public static final int AVCHROMA_LOC_CENTER = 2;
		/**
		 * < DV<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:520</i>
		 */
		public static final int AVCHROMA_LOC_TOPLEFT = 3;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:521</i>
		public static final int AVCHROMA_LOC_TOP = 4;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:522</i>
		public static final int AVCHROMA_LOC_BOTTOMLEFT = 5;
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:523</i>
		public static final int AVCHROMA_LOC_BOTTOM = 6;
		/**
		 * < Not part of ABI<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:524</i>
		 */
		public static final int AVCHROMA_LOC_NB = 7;
	};
	/**
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:2821</i><br>
	 * enum values
	 */
	public static interface AVSubtitleType {
		/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:2822</i>
		public static final int SUBTITLE_NONE = 0;
		/**
		 * < A bitmap, pict will be set<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:2824</i>
		 */
		public static final int SUBTITLE_BITMAP = 1;
		/**
		 * Plain text, the text field must be set by the decoder and is<br>
		 * authoritative. ass and pict fields may contain approximations.<br>
		 * Plain text, the text field must be set by the decoder and is<br>
		 * authoritative. ass and pict fields may contain approximations.<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:2830</i>
		 */
		public static final int SUBTITLE_TEXT = 2;
		/**
		 * Formatted text, the ass field must be set by the decoder and is<br>
		 * authoritative. pict and text fields may contain approximations.<br>
		 * Formatted text, the ass field must be set by the decoder and is<br>
		 * authoritative. pict and text fields may contain approximations.<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:2836</i>
		 */
		public static final int SUBTITLE_ASS = 3;
	};
	/**
	 * Lock operation used by lockmgr<br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3944</i><br>
	 * enum values
	 */
	public static interface AVLockOp {
		/**
		 * < Create a mutex<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3945</i>
		 */
		public static final int AV_LOCK_CREATE = 0;
		/**
		 * < Lock the mutex<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3946</i>
		 */
		public static final int AV_LOCK_OBTAIN = 1;
		/**
		 * < Unlock the mutex<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3947</i>
		 */
		public static final int AV_LOCK_RELEASE = 2;
		/**
		 * < Free mutex resources<br>
		 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3948</i>
		 */
		public static final int AV_LOCK_DESTROY = 3;
	};
	/**
	 * Conversion Error : a.num<br>
	 * SKIPPED:<br>
	 * <i>native declaration : src/main/headers/libavutil/rational.h</i><br>
	 * const int64_t tmp = a.num * (int64_t)b.den - b.num * (int64_t)a.den;
	 */
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG_CLOSED_GOP = -2147483648;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG2_STRICT_GOP = 2;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_IDCT_ALTIVEC = 8;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_CMP_CHROMA = 256;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DEBUG_BUFFERS = 32768;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG_CBP_RD = 67108864;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DEBUG_BUGS = 4096;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CH_TOP_FRONT_CENTER = 8192;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int X264_PART_I8X8 = 2;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_AA_FLOAT = 3;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_BUG_AMV = 32;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_S_TYPE = 4;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DEBUG_ER = 1024;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG_GRAY = 8192;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int MB_TYPE_16x8 = 16;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_CODER_TYPE_RLE = 3;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_MB_DECISION_BITS = 1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_CODER_TYPE_VLC = 0;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int AVPALETTE_SIZE = 1024;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_BUG_QPEL_CHROMA2 = 256;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG_EMU_EDGE = 16384;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_IDCT_MLIB = 6;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int X264_PART_P4X4 = 32;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_MB_DECISION_SIMPLE = 0;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG_SVCD_SCAN_OFFSET = 1073741824;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_ER_CAREFUL = 1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_SP_TYPE = 6;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG2_MIXED_REFS = 64;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CH_FRONT_LEFT_OF_CENTER = 64;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG2_AUD = 512;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_COMPLIANCE_VERY_STRICT = 2;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_LAMBDA_MAX = (256 * 128 - 1);
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DTG_AFD_16_9_SP_14_9 = 14;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_BUFFER_TYPE_INTERNAL = 1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int MB_TYPE_P0L1 = 16384;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int MB_TYPE_8x16 = 32;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_PROFILE_H264_HIGH_444 = 244;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_PROFILE_H264_HIGH = 100;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int SLICE_FLAG_ALLOW_PLANE = 4;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_LOSS_RESOLUTION = 1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_CMP_SSE = 1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG_TRUNCATED = 65536;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DEBUG_STARTCODE = 256;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_CMP_PSNR = 4;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_BUFFER_HINTS_PRESERVE = 4;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG_PART = 128;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_PROFILE_H264_HIGH_422 = 122;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_B_TYPE = 3;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_LEVEL_UNKNOWN = -99;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DTG_AFD_14_9 = 11;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG2_NO_OUTPUT = 4;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG_BITEXACT = 8388608;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_IDCT_SH4 = 9;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_LOSS_CHROMA = 32;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_IDCT_INT = 1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_INPUT_BUFFER_PADDING_SIZE = 8;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DTG_AFD_16_9 = 10;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_IDCT_AUTO = 0;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CH_BACK_RIGHT = 32;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG_H263P_SLICE_STRUCT = 268435456;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG_INTERLACED_DCT = 262144;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_MM_MMX2 = 2;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG_LOW_DELAY = 524288;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DEBUG_MV = 32;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int MB_TYPE_P0L0 = 4096;
	/// <i>native declaration : src/main/headers/libavutil/avutil.h</i>
	public static final int LIBAVUTIL_VERSION_MICRO = 1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_MM_ALTIVEC = 1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG_INTERLACED_ME = 536870912;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG_PASS2 = 1024;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG_PASS1 = 512;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_LOSS_DEPTH = 2;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_IDCT_SIMPLEMMX = 3;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_PRED_PLANE = 1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DEBUG_VIS_MB_TYPE = 16384;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CH_BACK_CENTER = 256;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_ER_COMPLIANT = 2;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_IDCT_EA = 21;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_CMP_VSSE = 9;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_IDCT_SIMPLEARMV5TE = 16;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_CMP_NSSE = 10;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DEBUG_QP = 16;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_MM_SSE42 = 512;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_QSCALE_TYPE_MPEG1 = 0;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_QSCALE_TYPE_MPEG2 = 1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_IDCT_ARM = 7;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DEBUG_RC = 2;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_IDCT_IPP = 13;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DCT_MMX = 3;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int PARSER_FLAG_COMPLETE_FRAMES = 1;
	/// <i>native declaration : src/main/headers/libavcodec/opt.h</i>
	public static final int AV_OPT_FLAG_DECODING_PARAM = 2;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_IDCT_XVIDMMX = 14;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int MB_TYPE_QUANT = 65536;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_CMP_SATD = 2;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CH_SIDE_LEFT = 512;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_CMP_RD = 6;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG2_WPRED = 32;
	/// <i>native declaration : src/main/headers/libavcodec/opt.h</i>
	public static final int AV_OPT_FLAG_ENCODING_PARAM = 1;
	/// <i>native declaration : src/main/headers/libavcodec/opt.h</i>
	public static final int AV_OPT_FLAG_METADATA = 4;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int X264_PART_I4X4 = 1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CH_FRONT_CENTER = 4;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CH_STEREO_RIGHT = 1073741824;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_CAP_DRAW_HORIZ_BAND = 1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DEBUG_DCT_COEFF = 64;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_MM_MMX = 1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_CMP_SAD = 0;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_BUG_TRUNCATED = 16384;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DCT_MLIB = 4;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG2_SKIP_RD = 16384;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_BUG_XVID_ILACE = 4;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_IDCT_CAVS = 15;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_LOSS_COLORQUANT = 16;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_CODER_TYPE_RAW = 2;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int SLICE_FLAG_ALLOW_FIELD = 2;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_BUFFER_HINTS_REUSABLE = 8;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DEBUG_MB_TYPE = 8;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DCT_AUTO = 0;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_RC_STRATEGY_XVID = 1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int MB_TYPE_INTRA4x4 = 1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_MM_3DNOWEXT = 32;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG2_SSIM = 1048576;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_CODER_TYPE_DEFLATE = 4;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_PROFILE_AAC_LTP = 3;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_ER_AGGRESSIVE = 3;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int MB_TYPE_CBP = 131072;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_IDCT_SIMPLEVIS = 18;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int AV_TIME_BASE = 1000000;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_CAP_TRUNCATED = 8;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG_ALT_SCAN = 1048576;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_AA_AUTO = 0;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int AV_PARSER_PTS_NB = 4;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_QSCALE_TYPE_VP56 = 3;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_LOSS_ALPHA = 8;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DEFAULT_QUANT_BIAS = 999999;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_MM_SSSE3 = 128;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_PROFILE_AAC_LOW = 1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_PROFILE_H264_BASELINE = 66;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CH_TOP_BACK_RIGHT = 131072;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int MB_TYPE_GMC = 1024;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_CAP_SUBFRAMES = 256;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_MM_SSE2 = 16;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_MM_SSE3 = 64;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_MM_SSE4 = 256;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG2_MBTREE = 262144;
	/// <i>native declaration : src/main/headers/libavcodec/opt.h</i>
	public static final int AV_OPT_FLAG_VIDEO_PARAM = 16;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int AVCODEC_MAX_AUDIO_FRAME_SIZE = 192000;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG_EXTERN_HUFF = 4096;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG_4MV = 4;
	/// <i>native declaration : src/main/headers/libavutil/avutil.h</i>
	public static final int LIBAVUTIL_VERSION_MAJOR = 50;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG2_LOCAL_HEADER = 8;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_CAP_EXPERIMENTAL = 512;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG2_INTRA_VLC = 2048;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_AA_FASTINT = 1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_BUG_OLD_MSMPEG4 = 2;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DEBUG_PICT_INFO = 1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DCT_INT = 2;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_IDCT_SIMPLENEON = 22;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DEBUG_VIS_MV_B_BACK = 4;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_IDCT_PS2 = 5;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_MM_IWMMXT = 256;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG2_BRDO = 1024;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_SI_TYPE = 5;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG_NORMALIZE_AQP = 131072;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CH_TOP_BACK_CENTER = 65536;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_ASPECT_EXTENDED = 15;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_MAX_B_FRAMES = 16;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int LIBAVCODEC_VERSION_MINOR = 72;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_MIN_BUFFER_SIZE = 16384;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_MB_DECISION_RD = 2;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_BUG_DC_CLIP = 4096;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_CMP_W97 = 12;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_IDCT_SIMPLEARMV6 = 17;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int MB_TYPE_8x8 = 64;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_QP2LAMBDA = 118;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_CODER_TYPE_AC = 1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG2_PSY = 524288;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_PROFILE_H264_CAVLC_444 = 44;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_COMPLIANCE_INOFFICIAL = -1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int SLICE_FLAG_CODED_ORDER = 1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG2_NON_LINEAR_QUANT = 65536;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int MB_TYPE_P1L1 = 32768;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int MB_TYPE_P1L0 = 8192;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CH_TOP_CENTER = 2048;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_CAP_DR1 = 2;
	/// <i>native declaration : src/main/headers/libavcodec/opt.h</i>
	public static final int AV_OPT_FLAG_SUBTITLE_PARAM = 32;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_PROFILE_H264_HIGH_10 = 110;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final String LIBAVCODEC_IDENT = "Lavc";
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_IDCT_BINK = 24;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG_MV0 = 64;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int MB_TYPE_INTERLACED = 128;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CH_STEREO_LEFT = 536870912;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_BUG_QPEL_CHROMA = 64;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DEBUG_VIS_MV_B_FOR = 2;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_CMP_W53 = 11;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_MM_SSE = 8;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int AV_PKT_FLAG_KEY = 1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG2_MEMC_ONLY = 4096;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_BUG_STD_QPEL = 128;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DTG_AFD_SP_4_3 = 15;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DEBUG_MMCO = 2048;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_IDCT_WMV2 = 19;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_AA_INT = 2;
	/// <i>native declaration : src/main/headers/libavcodec/opt.h</i>
	public static final int AV_OPT_FLAG_AUDIO_PARAM = 8;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_COMPLIANCE_STRICT = 1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_BUG_HPEL_CHROMA = 2048;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int MB_TYPE_INTRA16x16 = 2;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DEBUG_VIS_QP = 8192;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DEBUG_BITSTREAM = 4;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_CMP_DCT264 = 14;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_EC_DEBLOCK = 2;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int MB_TYPE_16x16 = 8;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_PROFILE_AAC_MAIN = 0;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_BUG_EDGE = 1024;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_IDCT_VP3 = 12;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_CAP_HWACCEL_VDPAU = 128;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DTG_AFD_SAME = 8;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG2_FAST = 1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_BUFFER_TYPE_USER = 2;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG2_CHUNKS = 32768;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG_H263P_UMV = 33554432;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_IDCT_SIMPLEALPHA = 23;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_BUG_MS = 8192;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_P_TYPE = 2;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG2_BIT_RESERVOIR = 131072;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG_QSCALE = 2;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int MB_TYPE_ACPRED = 512;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG_QP_RD = 134217728;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_IDCT_FAAN = 20;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_BUFFER_TYPE_COPY = 8;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_BUFFER_HINTS_VALID = 1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int MB_TYPE_DIRECT2 = 256;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_PRED_LEFT = 0;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG_INPUT_PRESERVED = 256;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int AVPALETTE_COUNT = 256;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_COMPRESSION_DEFAULT = -1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_BUFFER_HINTS_READABLE = 2;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_ER_VERY_AGGRESSIVE = 4;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_I_TYPE = 1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_PROFILE_H264_EXTENDED = 88;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG_QPEL = 16;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_IDCT_LIBMPEG2MMX = 4;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_COMPLIANCE_NORMAL = 0;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_CAP_HWACCEL = 16;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CH_FRONT_LEFT = 1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_PROFILE_H264_MAIN = 77;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_BUFFER_TYPE_SHARED = 4;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_CAP_DELAY = 32;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG2_FASTPSKIP = 256;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_MM_MMXEXT = 2;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_BUG_AUTODETECT = 1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG_OBMC = 1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_MM_FORCE = -2147483648;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CH_TOP_BACK_LEFT = 32768;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_COMPLIANCE_EXPERIMENTAL = -2;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CH_SIDE_RIGHT = 1024;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DEBUG_VIS_MV_P_FOR = 1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_CMP_DCT = 3;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_IDCT_SIMPLEARM = 10;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_MM_3DNOW = 4;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG2_BPYRAMID = 16;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_PROFILE_AAC_SSR = 2;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG_GLOBAL_HEADER = 4194304;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CH_BACK_LEFT = 16;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int LIBAVCODEC_VERSION_MAJOR = 52;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG_PSNR = 32768;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_CAP_SMALL_LAST_FRAME = 64;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int MB_TYPE_SKIP = 2048;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int X264_PART_P8X8 = 16;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG_H263P_AIV = 8;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_LOSS_COLORSPACE = 4;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DCT_FAAN = 6;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_IDCT_H264 = 11;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CH_FRONT_RIGHT = 2;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG2_8X8DCT = 128;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CH_LOW_FREQUENCY = 8;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_ALPHA_SEMI_TRANSP = 2;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_QSCALE_TYPE_H264 = 2;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CH_TOP_FRONT_RIGHT = 16384;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DEBUG_SKIP = 128;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DTG_AFD_4_3_SP_14_9 = 13;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DCT_ALTIVEC = 5;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_CMP_BIT = 5;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_BUG_AC_VLC = 0;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DEBUG_PTS = 512;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DTG_AFD_4_3 = 9;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_BUG_NO_PADDING = 16;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG_LOOP_FILTER = 2048;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_CMP_DCTMAX = 13;
	/// <i>native declaration : src/main/headers/libavutil/avutil.h</i>
	public static final int LIBAVUTIL_VERSION_MINOR = 15;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_IDCT_SIMPLE = 2;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_PROFILE_UNKNOWN = -99;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_CMP_VSAD = 8;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CH_TOP_FRONT_LEFT = 4096;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int MB_TYPE_INTRA_PCM = 4;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_CAP_PARSE_ONLY = 4;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG2_DROP_FRAME_TIMECODE = 8192;
	/// <i>native declaration : src/main/headers/libavutil/avutil.h</i>
	public static final String LIBAVUTIL_IDENT = "Lavu";
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_DCT_FASTINT = 1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG_AC_PRED = 16777216;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_BUG_UMP4 = 8;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int X264_PART_B8X8 = 256;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_CMP_ZERO = 7;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_PRED_MEDIAN = 2;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_LAMBDA_SHIFT = 7;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CODEC_FLAG_GMC = 32;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_BUG_DIRECT_BLOCKSIZE = 512;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CH_FRONT_RIGHT_OF_CENTER = 128;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_BI_TYPE = 7;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_ALPHA_TRANSP = 1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_EC_GUESS_MVS = 1;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int LIBAVCODEC_VERSION_MICRO = 2;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int MB_TYPE_L0 = (AvcodecLibrary.MB_TYPE_P0L0 | AvcodecLibrary.MB_TYPE_P1L0);
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CH_LAYOUT_STEREO_DOWNMIX = (AvcodecLibrary.CH_STEREO_LEFT | AvcodecLibrary.CH_STEREO_RIGHT);
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CH_LAYOUT_MONO = (AvcodecLibrary.CH_FRONT_CENTER);
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int CH_LAYOUT_STEREO = (AvcodecLibrary.CH_FRONT_LEFT | AvcodecLibrary.CH_FRONT_RIGHT);
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int PKT_FLAG_KEY = AvcodecLibrary.AV_PKT_FLAG_KEY;
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int MB_TYPE_L1 = (AvcodecLibrary.MB_TYPE_P0L1 | AvcodecLibrary.MB_TYPE_P1L1);
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h</i>
	public static final int FF_LAMBDA_SCALE = (1 << AvcodecLibrary.FF_LAMBDA_SHIFT);
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:3341</i>
	public interface avcodec_default_execute_arg1_func_callback extends Callback {
		int apply(AVCodecContext c2, Pointer arg2);
	};
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:3342</i>
	public interface avcodec_default_execute2_arg1_func_callback extends Callback {
		int apply(AVCodecContext c2, Pointer arg2, int int1, int int2);
	};
	/// <i>native declaration : src/main/headers/libavcodec/avcodec.h:3964</i>
	public interface av_lockmgr_register_arg1_cb_callback extends Callback {
		/// @param op @see AVLockOp
		int apply(PointerByReference mutex, int op);
	};
	/**
	 * Returns the LIBAVUTIL_VERSION_INT constant.<br>
	 * Original signature : <code>avutil_version()</code><br>
	 * <i>native declaration : src/main/headers/libavutil/avutil.h:59</i>
	 */
	@Mangling({"_Z14avutil_versionv", "?avutil_version@@YAXXZ"}) 
	int avutil_version();
	/**
	 * Returns the libavutil build-time configuration.<br>
	 * Original signature : <code>char* avutil_configuration()</code><br>
	 * <i>native declaration : src/main/headers/libavutil/avutil.h:64</i>
	 */
	@Mangling({"_Z20avutil_configurationv", "?avutil_configuration@@YAQBDXZ"}) 
	String avutil_configuration();
	/**
	 * Returns the libavutil license.<br>
	 * Original signature : <code>char* avutil_license()</code><br>
	 * <i>native declaration : src/main/headers/libavutil/avutil.h:69</i>
	 */
	@Mangling({"_Z14avutil_licensev", "?avutil_license@@YAQBDXZ"}) 
	String avutil_license();
	/**
	 * Looks for an option in obj. Looks only for the options which<br>
	 * have the flags set as specified in mask and flags (that is,<br>
	 * for which it is the case that opt->flags & mask == flags).<br>
	 * * @param[in] obj a pointer to a struct whose first element is a<br>
	 * pointer to an AVClass<br>
	 * @param[in] name the name of the option to look for<br>
	 * @param[in] unit the unit of the option to look for, or any if NULL<br>
	 * @return a pointer to the option found, or NULL if no option<br>
	 * has been found<br>
	 * Original signature : <code>AVOption* av_find_opt(void*, const char*, const char*, int, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/opt.h:152</i><br>
	 * @deprecated use the safer methods {@link #av_find_opt(com.sun.jna.Pointer, java.lang.String, java.lang.String, int, int)} and {@link #av_find_opt(com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.Pointer, int, int)} instead
	 */
	@Mangling({"_Z11av_find_optPvPKcPKcii", "?av_find_opt@@YAQBUAVOption@@PAXPADPADHH@Z"}) 
	@Deprecated 
	AVOption av_find_opt(Pointer obj, Pointer name, Pointer unit, int mask, int flags);
	/**
	 * Looks for an option in obj. Looks only for the options which<br>
	 * have the flags set as specified in mask and flags (that is,<br>
	 * for which it is the case that opt->flags & mask == flags).<br>
	 * * @param[in] obj a pointer to a struct whose first element is a<br>
	 * pointer to an AVClass<br>
	 * @param[in] name the name of the option to look for<br>
	 * @param[in] unit the unit of the option to look for, or any if NULL<br>
	 * @return a pointer to the option found, or NULL if no option<br>
	 * has been found<br>
	 * Original signature : <code>AVOption* av_find_opt(void*, const char*, const char*, int, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/opt.h:152</i>
	 */
	@Mangling({"_Z11av_find_optPvPKcPKcii", "?av_find_opt@@YAQBUAVOption@@PAXPADPADHH@Z"}) 
	AVOption av_find_opt(Pointer obj, String name, String unit, int mask, int flags);
	/**
	 * @see av_set_string2()<br>
	 * Original signature : <code>AVOption* av_set_string(void*, const char*, const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/opt.h:158</i><br>
	 * @deprecated use the safer methods {@link #av_set_string(com.sun.jna.Pointer, java.lang.String, java.lang.String)} and {@link #av_set_string(com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z13av_set_stringPvPKcPKc", "?av_set_string@@YAQBUAVOption@@PAXPADPAD@Z"}) 
	@Deprecated 
	AVOption av_set_string(Pointer obj, Pointer name, Pointer val);
	/**
	 * @see av_set_string2()<br>
	 * Original signature : <code>AVOption* av_set_string(void*, const char*, const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/opt.h:158</i>
	 */
	@Mangling({"_Z13av_set_stringPvPKcPKc", "?av_set_string@@YAQBUAVOption@@PAXPADPAD@Z"}) 
	AVOption av_set_string(Pointer obj, String name, String val);
	/**
	 * @return a pointer to the AVOption corresponding to the field set or<br>
	 * NULL if no matching AVOption exists, or if the value val is not<br>
	 * valid<br>
	 * @see av_set_string3()<br>
	 * Original signature : <code>AVOption* av_set_string2(void*, const char*, const char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/opt.h:166</i><br>
	 * @deprecated use the safer methods {@link #av_set_string2(com.sun.jna.Pointer, java.lang.String, java.lang.String, int)} and {@link #av_set_string2(com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.Pointer, int)} instead
	 */
	@Mangling({"_Z14av_set_string2PvPKcPKci", "?av_set_string2@@YAQBUAVOption@@PAXPADPADH@Z"}) 
	@Deprecated 
	AVOption av_set_string2(Pointer obj, Pointer name, Pointer val, int alloc);
	/**
	 * @return a pointer to the AVOption corresponding to the field set or<br>
	 * NULL if no matching AVOption exists, or if the value val is not<br>
	 * valid<br>
	 * @see av_set_string3()<br>
	 * Original signature : <code>AVOption* av_set_string2(void*, const char*, const char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/opt.h:166</i>
	 */
	@Mangling({"_Z14av_set_string2PvPKcPKci", "?av_set_string2@@YAQBUAVOption@@PAXPADPADH@Z"}) 
	AVOption av_set_string2(Pointer obj, String name, String val, int alloc);
	/**
	 * Sets the field of obj with the given name to value.<br>
	 * * @param[in] obj A struct whose first element is a pointer to an<br>
	 * AVClass.<br>
	 * @param[in] name the name of the field to set<br>
	 * @param[in] val The value to set. If the field is not of a string<br>
	 * type, then the given string is parsed.<br>
	 * SI postfixes and some named scalars are supported.<br>
	 * If the field is of a numeric type, it has to be a numeric or named<br>
	 * scalar. Behavior with more than one scalar and +- infix operators<br>
	 * is undefined.<br>
	 * If the field is of a flags type, it has to be a sequence of numeric<br>
	 * scalars or named flags separated by '+' or '-'. Prefixing a flag<br>
	 * with '+' causes it to be set without affecting the other flags;<br>
	 * similarly, '-' unsets a flag.<br>
	 * @param[out] o_out if non-NULL put here a pointer to the AVOption<br>
	 * found<br>
	 * @param alloc when 1 then the old value will be av_freed() and the<br>
	 *                     new av_strduped()<br>
	 *              when 0 then no av_free() nor av_strdup() will be used<br>
	 * @return 0 if the value has been set, or an AVERROR code in case of<br>
	 * error:<br>
	 * AVERROR(ENOENT) if no matching option exists<br>
	 * AVERROR(ERANGE) if the value is out of range<br>
	 * AVERROR(EINVAL) if the value is not valid<br>
	 * Original signature : <code>int av_set_string3(void*, const char*, const char*, int, const AVOption**)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/opt.h:196</i><br>
	 * @deprecated use the safer methods {@link #av_set_string3(com.sun.jna.Pointer, java.lang.String, java.lang.String, int, avcodec.AVOption.ByReference[])} and {@link #av_set_string3(com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.Pointer, int, avcodec.AVOption.ByReference[])} instead
	 */
	@Mangling({"_Z14av_set_string3PvPKcPKciPPK8AVOption", "?av_set_string3@@YAHPAXPADPADHPAPAUAVOption@@@Z"}) 
	@Deprecated 
	int av_set_string3(Pointer obj, Pointer name, Pointer val, int alloc, PointerByReference o_out);
	/**
	 * Sets the field of obj with the given name to value.<br>
	 * * @param[in] obj A struct whose first element is a pointer to an<br>
	 * AVClass.<br>
	 * @param[in] name the name of the field to set<br>
	 * @param[in] val The value to set. If the field is not of a string<br>
	 * type, then the given string is parsed.<br>
	 * SI postfixes and some named scalars are supported.<br>
	 * If the field is of a numeric type, it has to be a numeric or named<br>
	 * scalar. Behavior with more than one scalar and +- infix operators<br>
	 * is undefined.<br>
	 * If the field is of a flags type, it has to be a sequence of numeric<br>
	 * scalars or named flags separated by '+' or '-'. Prefixing a flag<br>
	 * with '+' causes it to be set without affecting the other flags;<br>
	 * similarly, '-' unsets a flag.<br>
	 * @param[out] o_out if non-NULL put here a pointer to the AVOption<br>
	 * found<br>
	 * @param alloc when 1 then the old value will be av_freed() and the<br>
	 *                     new av_strduped()<br>
	 *              when 0 then no av_free() nor av_strdup() will be used<br>
	 * @return 0 if the value has been set, or an AVERROR code in case of<br>
	 * error:<br>
	 * AVERROR(ENOENT) if no matching option exists<br>
	 * AVERROR(ERANGE) if the value is out of range<br>
	 * AVERROR(EINVAL) if the value is not valid<br>
	 * Original signature : <code>int av_set_string3(void*, const char*, const char*, int, const AVOption**)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/opt.h:196</i>
	 */
	@Mangling({"_Z14av_set_string3PvPKcPKciPPK8AVOption", "?av_set_string3@@YAHPAXPADPADHPAPAUAVOption@@@Z"}) 
	int av_set_string3(Pointer obj, String name, String val, int alloc, AVOption.ByReference o_out[]);
	/**
	 * Sets the field of obj with the given name to value.<br>
	 * * @param[in] obj A struct whose first element is a pointer to an<br>
	 * AVClass.<br>
	 * @param[in] name the name of the field to set<br>
	 * @param[in] val The value to set. If the field is not of a string<br>
	 * type, then the given string is parsed.<br>
	 * SI postfixes and some named scalars are supported.<br>
	 * If the field is of a numeric type, it has to be a numeric or named<br>
	 * scalar. Behavior with more than one scalar and +- infix operators<br>
	 * is undefined.<br>
	 * If the field is of a flags type, it has to be a sequence of numeric<br>
	 * scalars or named flags separated by '+' or '-'. Prefixing a flag<br>
	 * with '+' causes it to be set without affecting the other flags;<br>
	 * similarly, '-' unsets a flag.<br>
	 * @param[out] o_out if non-NULL put here a pointer to the AVOption<br>
	 * found<br>
	 * @param alloc when 1 then the old value will be av_freed() and the<br>
	 *                     new av_strduped()<br>
	 *              when 0 then no av_free() nor av_strdup() will be used<br>
	 * @return 0 if the value has been set, or an AVERROR code in case of<br>
	 * error:<br>
	 * AVERROR(ENOENT) if no matching option exists<br>
	 * AVERROR(ERANGE) if the value is out of range<br>
	 * AVERROR(EINVAL) if the value is not valid<br>
	 * Original signature : <code>int av_set_string3(void*, const char*, const char*, int, const AVOption**)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/opt.h:196</i>
	 */
	@Mangling({"_Z14av_set_string3PvPKcPKciPPK8AVOption", "?av_set_string3@@YAHPAXPADPADHPAPAUAVOption@@@Z"}) 
	int av_set_string3(Pointer obj, Pointer name, Pointer val, int alloc, AVOption.ByReference o_out[]);
	/**
	 * Original signature : <code>AVOption* av_set_double(void*, const char*, double)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/opt.h:198</i><br>
	 * @deprecated use the safer methods {@link #av_set_double(com.sun.jna.Pointer, java.lang.String, double)} and {@link #av_set_double(com.sun.jna.Pointer, com.sun.jna.Pointer, double)} instead
	 */
	@Mangling({"_Z13av_set_doublePvPKcd", "?av_set_double@@YAQBUAVOption@@PAXPADN@Z"}) 
	@Deprecated 
	AVOption av_set_double(Pointer obj, Pointer name, double n);
	/**
	 * Original signature : <code>AVOption* av_set_double(void*, const char*, double)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/opt.h:198</i>
	 */
	@Mangling({"_Z13av_set_doublePvPKcd", "?av_set_double@@YAQBUAVOption@@PAXPADN@Z"}) 
	AVOption av_set_double(Pointer obj, String name, double n);
	/**
	 * Original signature : <code>AVOption* av_set_q(void*, const char*, AVRational)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/opt.h:199</i><br>
	 * @deprecated use the safer methods {@link #av_set_q(com.sun.jna.Pointer, java.lang.String, avutil.AVRational.ByValue)} and {@link #av_set_q(com.sun.jna.Pointer, com.sun.jna.Pointer, avutil.AVRational.ByValue)} instead
	 */
	@Mangling({"_Z8av_set_qPvPKc10AVRational", "?av_set_q@@YAQBUAVOption@@PAXPADUAVRational@@@Z"}) 
	@Deprecated 
	AVOption av_set_q(Pointer obj, Pointer name, AVRational.ByValue n);
	/**
	 * Original signature : <code>AVOption* av_set_q(void*, const char*, AVRational)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/opt.h:199</i>
	 */
	@Mangling({"_Z8av_set_qPvPKc10AVRational", "?av_set_q@@YAQBUAVOption@@PAXPADUAVRational@@@Z"}) 
	AVOption av_set_q(Pointer obj, String name, AVRational.ByValue n);
	/**
	 * Original signature : <code>AVOption* av_set_int(void*, const char*, int64_t)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/opt.h:200</i><br>
	 * @deprecated use the safer methods {@link #av_set_int(com.sun.jna.Pointer, java.lang.String, long)} and {@link #av_set_int(com.sun.jna.Pointer, com.sun.jna.Pointer, long)} instead
	 */
	@Mangling({"_Z10av_set_intPvPKc7int64_t", "?av_set_int@@YAQBUAVOption@@PAXPAD7int64_t@Z"}) 
	@Deprecated 
	AVOption av_set_int(Pointer obj, Pointer name, long n);
	/**
	 * Original signature : <code>AVOption* av_set_int(void*, const char*, int64_t)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/opt.h:200</i>
	 */
	@Mangling({"_Z10av_set_intPvPKc7int64_t", "?av_set_int@@YAQBUAVOption@@PAXPAD7int64_t@Z"}) 
	AVOption av_set_int(Pointer obj, String name, long n);
	/**
	 * Original signature : <code>double av_get_double(void*, const char*, const AVOption**)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/opt.h:201</i><br>
	 * @deprecated use the safer methods {@link #av_get_double(com.sun.jna.Pointer, java.lang.String, avcodec.AVOption.ByReference[])} and {@link #av_get_double(com.sun.jna.Pointer, com.sun.jna.Pointer, avcodec.AVOption.ByReference[])} instead
	 */
	@Mangling({"_Z13av_get_doublePvPKcPPK8AVOption", "?av_get_double@@YANPAXPADPAPAUAVOption@@@Z"}) 
	@Deprecated 
	double av_get_double(Pointer obj, Pointer name, PointerByReference o_out);
	/**
	 * Original signature : <code>double av_get_double(void*, const char*, const AVOption**)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/opt.h:201</i>
	 */
	@Mangling({"_Z13av_get_doublePvPKcPPK8AVOption", "?av_get_double@@YANPAXPADPAPAUAVOption@@@Z"}) 
	double av_get_double(Pointer obj, String name, AVOption.ByReference o_out[]);
	/**
	 * Original signature : <code>double av_get_double(void*, const char*, const AVOption**)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/opt.h:201</i>
	 */
	@Mangling({"_Z13av_get_doublePvPKcPPK8AVOption", "?av_get_double@@YANPAXPADPAPAUAVOption@@@Z"}) 
	double av_get_double(Pointer obj, Pointer name, AVOption.ByReference o_out[]);
	/**
	 * Original signature : <code>AVRational av_get_q(void*, const char*, const AVOption**)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/opt.h:202</i><br>
	 * @deprecated use the safer methods {@link #av_get_q(com.sun.jna.Pointer, java.lang.String, avcodec.AVOption.ByReference[])} and {@link #av_get_q(com.sun.jna.Pointer, com.sun.jna.Pointer, avcodec.AVOption.ByReference[])} instead
	 */
	@Mangling({"_Z8av_get_qPvPKcPPK8AVOption", "?av_get_q@@YAUAVRational@@PAXPADPAPAUAVOption@@@Z"}) 
	@Deprecated 
	AVRational.ByValue av_get_q(Pointer obj, Pointer name, PointerByReference o_out);
	/**
	 * Original signature : <code>AVRational av_get_q(void*, const char*, const AVOption**)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/opt.h:202</i>
	 */
	@Mangling({"_Z8av_get_qPvPKcPPK8AVOption", "?av_get_q@@YAUAVRational@@PAXPADPAPAUAVOption@@@Z"}) 
	AVRational.ByValue av_get_q(Pointer obj, String name, AVOption.ByReference o_out[]);
	/**
	 * Original signature : <code>AVRational av_get_q(void*, const char*, const AVOption**)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/opt.h:202</i>
	 */
	@Mangling({"_Z8av_get_qPvPKcPPK8AVOption", "?av_get_q@@YAUAVRational@@PAXPADPAPAUAVOption@@@Z"}) 
	AVRational.ByValue av_get_q(Pointer obj, Pointer name, AVOption.ByReference o_out[]);
	/**
	 * Original signature : <code>int64_t av_get_int(void*, const char*, const AVOption**)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/opt.h:203</i><br>
	 * @deprecated use the safer methods {@link #av_get_int(com.sun.jna.Pointer, java.lang.String, avcodec.AVOption.ByReference[])} and {@link #av_get_int(com.sun.jna.Pointer, com.sun.jna.Pointer, avcodec.AVOption.ByReference[])} instead
	 */
	@Mangling({"_Z10av_get_intPvPKcPPK8AVOption", "?av_get_int@@YA7int64_tPAXPADPAPAUAVOption@@@Z"}) 
	@Deprecated 
	long av_get_int(Pointer obj, Pointer name, PointerByReference o_out);
	/**
	 * Original signature : <code>int64_t av_get_int(void*, const char*, const AVOption**)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/opt.h:203</i>
	 */
	@Mangling({"_Z10av_get_intPvPKcPPK8AVOption", "?av_get_int@@YA7int64_tPAXPADPAPAUAVOption@@@Z"}) 
	long av_get_int(Pointer obj, String name, AVOption.ByReference o_out[]);
	/**
	 * Original signature : <code>int64_t av_get_int(void*, const char*, const AVOption**)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/opt.h:203</i>
	 */
	@Mangling({"_Z10av_get_intPvPKcPPK8AVOption", "?av_get_int@@YA7int64_tPAXPADPAPAUAVOption@@@Z"}) 
	long av_get_int(Pointer obj, Pointer name, AVOption.ByReference o_out[]);
	/**
	 * Original signature : <code>char* av_get_string(void*, const char*, const AVOption**, char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/opt.h:204</i><br>
	 * @deprecated use the safer methods {@link #av_get_string(com.sun.jna.Pointer, java.lang.String, avcodec.AVOption.ByReference[], java.nio.ByteBuffer, int)} and {@link #av_get_string(com.sun.jna.Pointer, com.sun.jna.Pointer, avcodec.AVOption.ByReference[], com.sun.jna.Pointer, int)} instead
	 */
	@Mangling({"_Z13av_get_stringPvPKcPPK8AVOptionPci", "?av_get_string@@YAQBDPAXPADPAPAUAVOption@@PADH@Z"}) 
	@Deprecated 
	String av_get_string(Pointer obj, Pointer name, PointerByReference o_out, Pointer buf, int buf_len);
	/**
	 * Original signature : <code>char* av_get_string(void*, const char*, const AVOption**, char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/opt.h:204</i>
	 */
	@Mangling({"_Z13av_get_stringPvPKcPPK8AVOptionPci", "?av_get_string@@YAQBDPAXPADPAPAUAVOption@@PADH@Z"}) 
	String av_get_string(Pointer obj, String name, AVOption.ByReference o_out[], ByteBuffer buf, int buf_len);
	/**
	 * Original signature : <code>char* av_get_string(void*, const char*, const AVOption**, char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/opt.h:204</i>
	 */
	@Mangling({"_Z13av_get_stringPvPKcPPK8AVOptionPci", "?av_get_string@@YAQBDPAXPADPAPAUAVOption@@PADH@Z"}) 
	String av_get_string(Pointer obj, Pointer name, AVOption.ByReference o_out[], Pointer buf, int buf_len);
	/**
	 * Original signature : <code>AVOption* av_next_option(void*, const AVOption*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/opt.h:205</i>
	 */
	@Mangling({"_Z14av_next_optionPvPK8AVOption", "?av_next_option@@YAQBUAVOption@@PAXPAUAVOption@@@Z"}) 
	AVOption av_next_option(Pointer obj, AVOption last);
	/**
	 * Original signature : <code>int av_opt_show(void*, void*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/opt.h:206</i>
	 */
	@Mangling({"_Z11av_opt_showPvPv", "?av_opt_show@@YAHPAXPAX@Z"}) 
	int av_opt_show(Pointer obj, Pointer av_log_obj);
	/**
	 * Original signature : <code>void av_opt_set_defaults(void*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/opt.h:207</i>
	 */
	@Mangling({"_Z19av_opt_set_defaultsPv", "?av_opt_set_defaults@@YAXPAX@Z"}) 
	void av_opt_set_defaults(Pointer s);
	/**
	 * Original signature : <code>void av_opt_set_defaults2(void*, int, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/opt.h:208</i>
	 */
	@Mangling({"_Z20av_opt_set_defaults2Pvii", "?av_opt_set_defaults2@@YAXPAXHH@Z"}) 
	void av_opt_set_defaults2(Pointer s, int mask, int flags);
	/**
	 * @deprecated use NULL instead<br>
	 * Original signature : <code>void av_destruct_packet_nofree(AVPacket*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:2877</i>
	 */
	@Mangling({"_Z25av_destruct_packet_nofreeP8AVPacket", "?av_destruct_packet_nofree@@YAXPAUAVPacket@@@Z"}) 
	void av_destruct_packet_nofree(AVPacket pkt);
	/**
	 * Default packet destructor.<br>
	 * Original signature : <code>void av_destruct_packet(AVPacket*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:2882</i>
	 */
	@Mangling({"_Z18av_destruct_packetP8AVPacket", "?av_destruct_packet@@YAXPAUAVPacket@@@Z"}) 
	void av_destruct_packet(AVPacket pkt);
	/**
	 * Initialize optional fields of a packet with default values.<br>
	 * * @param pkt packet<br>
	 * Original signature : <code>void av_init_packet(AVPacket*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:2889</i>
	 */
	@Mangling({"_Z14av_init_packetP8AVPacket", "?av_init_packet@@YAXPAUAVPacket@@@Z"}) 
	void av_init_packet(AVPacket pkt);
	/**
	 * Allocate the payload of a packet and initialize its fields with<br>
	 * default values.<br>
	 * * @param pkt packet<br>
	 * @param size wanted payload size<br>
	 * @return 0 if OK, AVERROR_xxx otherwise<br>
	 * Original signature : <code>int av_new_packet(AVPacket*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:2899</i>
	 */
	@Mangling({"_Z13av_new_packetP8AVPacketi", "?av_new_packet@@YAHPAUAVPacket@@H@Z"}) 
	int av_new_packet(AVPacket pkt, int size);
	/**
	 * Reduce packet size, correctly zeroing padding<br>
	 * * @param pkt packet<br>
	 * @param size new size<br>
	 * Original signature : <code>void av_shrink_packet(AVPacket*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:2907</i>
	 */
	@Mangling({"_Z16av_shrink_packetP8AVPacketi", "?av_shrink_packet@@YAXPAUAVPacket@@H@Z"}) 
	void av_shrink_packet(AVPacket pkt, int size);
	/**
	 * @warning This is a hack - the packet memory allocation stuff is broken. The<br>
	 * packet is allocated if it was not really allocated.<br>
	 * Original signature : <code>int av_dup_packet(AVPacket*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:2913</i>
	 */
	@Mangling({"_Z13av_dup_packetP8AVPacket", "?av_dup_packet@@YAHPAUAVPacket@@@Z"}) 
	int av_dup_packet(AVPacket pkt);
	/**
	 * Free a packet.<br>
	 * * @param pkt packet to free<br>
	 * Original signature : <code>void av_free_packet(AVPacket*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:2920</i>
	 */
	@Mangling({"_Z14av_free_packetP8AVPacket", "?av_free_packet@@YAXPAUAVPacket@@@Z"}) 
	void av_free_packet(AVPacket pkt);
	/**
	 * @deprecated Use av_audio_resample_init() instead.<br>
	 * Original signature : <code>ReSampleContext* audio_resample_init(int, int, int, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:2933</i>
	 */
	@Mangling({"_Z19audio_resample_initiiii", "?audio_resample_init@@YAPA15ReSampleContextHHHH@Z"}) 
	Pointer audio_resample_init(int output_channels, int input_channels, int output_rate, int input_rate);
	/**
	 * Initializes audio resampling context<br>
	 * * @param output_channels  number of output channels<br>
	 * @param input_channels   number of input channels<br>
	 * @param output_rate      output sample rate<br>
	 * @param input_rate       input sample rate<br>
	 * @param sample_fmt_out   requested output sample format<br>
	 * @param sample_fmt_in    input sample format<br>
	 * @param filter_length    length of each FIR filter in the filterbank relative to the cutoff freq<br>
	 * @param log2_phase_count log2 of the number of entries in the polyphase filterbank<br>
	 * @param linear           If 1 then the used FIR filter will be linearly interpolated<br>
	 * between the 2 closest, if 0 the closest will be used<br>
	 * @param cutoff           cutoff frequency, 1.0 corresponds to half the output sampling rate<br>
	 * @return allocated ReSampleContext, NULL if error occured<br>
	 * Original signature : <code>ReSampleContext* av_audio_resample_init(int, int, int, int, SampleFormat, SampleFormat, int, int, int, double)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:2952</i><br>
	 * @param sample_fmt_out @see SampleFormat<br>
	 * @param sample_fmt_in @see SampleFormat
	 */
	@Mangling({"_Z22av_audio_resample_initiiii12SampleFormat12SampleFormatiiid", "?av_audio_resample_init@@YAPA15ReSampleContextHHHH12SampleFormat12SampleFormatHHHN@Z"}) 
	Pointer av_audio_resample_init(int output_channels, int input_channels, int output_rate, int input_rate, int sample_fmt_out, int sample_fmt_in, int filter_length, int log2_phase_count, int linear, double cutoff);
	/**
	 * Original signature : <code>int audio_resample(ReSampleContext*, short*, short*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:2959</i><br>
	 * @deprecated use the safer methods {@link #audio_resample(com.sun.jna.Pointer, java.nio.ShortBuffer, java.nio.ShortBuffer, int)} and {@link #audio_resample(com.sun.jna.Pointer, com.sun.jna.ptr.ShortByReference, com.sun.jna.ptr.ShortByReference, int)} instead
	 */
	@Mangling({"_Z14audio_resampleP15ReSampleContextPiPii", "?audio_resample@@YAHPA15ReSampleContextPAHPAHH@Z"}) 
	@Deprecated 
	int audio_resample(Pointer s, ShortByReference output, ShortByReference input, int nb_samples);
	/**
	 * Original signature : <code>int audio_resample(ReSampleContext*, short*, short*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:2959</i>
	 */
	@Mangling({"_Z14audio_resampleP15ReSampleContextPiPii", "?audio_resample@@YAHPA15ReSampleContextPAHPAHH@Z"}) 
	int audio_resample(Pointer s, ShortBuffer output, ShortBuffer input, int nb_samples);
	/**
	 * Original signature : <code>void audio_resample_close(ReSampleContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:2960</i>
	 */
	@Mangling({"_Z20audio_resample_closeP15ReSampleContext", "?audio_resample_close@@YAXPA15ReSampleContext@Z"}) 
	void audio_resample_close(Pointer s);
	/**
	 * Initializes an audio resampler.<br>
	 * Note, if either rate is not an integer then simply scale both rates up so they are.<br>
	 * @param filter_length length of each FIR filter in the filterbank relative to the cutoff freq<br>
	 * @param log2_phase_count log2 of the number of entries in the polyphase filterbank<br>
	 * @param linear If 1 then the used FIR filter will be linearly interpolated<br>
	 * between the 2 closest, if 0 the closest will be used<br>
	 * @param cutoff cutoff frequency, 1.0 corresponds to half the output sampling rate<br>
	 * Original signature : <code>AVResampleContext* av_resample_init(int, int, int, int, int, double)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:2972</i>
	 */
	@Mangling({"_Z16av_resample_initiiiiid", "?av_resample_init@@YAPA17AVResampleContextHHHHHN@Z"}) 
	Pointer av_resample_init(int out_rate, int in_rate, int filter_length, int log2_phase_count, int linear, double cutoff);
	/**
	 * resamples.<br>
	 * @param src an array of unconsumed samples<br>
	 * @param consumed the number of samples of src which have been consumed are returned here<br>
	 * @param src_size the number of unconsumed samples available<br>
	 * @param dst_size the amount of space in samples available in dst<br>
	 * @param update_ctx If this is 0 then the context will not be modified, that way several channels can be resampled with the same context.<br>
	 * @return the number of samples written in dst or -1 if an error occurred<br>
	 * Original signature : <code>int av_resample(AVResampleContext*, short*, short*, int*, int, int, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:2983</i><br>
	 * @deprecated use the safer methods {@link #av_resample(com.sun.jna.Pointer, java.nio.ShortBuffer, java.nio.ShortBuffer, java.nio.IntBuffer, int, int, int)} and {@link #av_resample(com.sun.jna.Pointer, com.sun.jna.ptr.ShortByReference, com.sun.jna.ptr.ShortByReference, com.sun.jna.ptr.IntByReference, int, int, int)} instead
	 */
	@Mangling({"_Z11av_resampleP17AVResampleContextPiPiPiiii", "?av_resample@@YAHPA17AVResampleContextPAHPAHPAHHHH@Z"}) 
	@Deprecated 
	int av_resample(Pointer c, ShortByReference dst, ShortByReference src, IntByReference consumed, int src_size, int dst_size, int update_ctx);
	/**
	 * resamples.<br>
	 * @param src an array of unconsumed samples<br>
	 * @param consumed the number of samples of src which have been consumed are returned here<br>
	 * @param src_size the number of unconsumed samples available<br>
	 * @param dst_size the amount of space in samples available in dst<br>
	 * @param update_ctx If this is 0 then the context will not be modified, that way several channels can be resampled with the same context.<br>
	 * @return the number of samples written in dst or -1 if an error occurred<br>
	 * Original signature : <code>int av_resample(AVResampleContext*, short*, short*, int*, int, int, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:2983</i>
	 */
	@Mangling({"_Z11av_resampleP17AVResampleContextPiPiPiiii", "?av_resample@@YAHPA17AVResampleContextPAHPAHPAHHHH@Z"}) 
	int av_resample(Pointer c, ShortBuffer dst, ShortBuffer src, IntBuffer consumed, int src_size, int dst_size, int update_ctx);
	/**
	 * Compensates samplerate/timestamp drift. The compensation is done by changing<br>
	 * the resampler parameters, so no audible clicks or similar distortions occur<br>
	 * @param compensation_distance distance in output samples over which the compensation should be performed<br>
	 * @param sample_delta number of output samples which should be output less<br>
	 * * example: av_resample_compensate(c, 10, 500)<br>
	 * here instead of 510 samples only 500 samples would be output<br>
	 * * note, due to rounding the actual compensation might be slightly different,<br>
	 * especially if the compensation_distance is large and the in_rate used during init is small<br>
	 * Original signature : <code>void av_resample_compensate(AVResampleContext*, int, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:2998</i>
	 */
	@Mangling({"_Z22av_resample_compensateP17AVResampleContextii", "?av_resample_compensate@@YAXPA17AVResampleContextHH@Z"}) 
	void av_resample_compensate(Pointer c, int sample_delta, int compensation_distance);
	/**
	 * Original signature : <code>void av_resample_close(AVResampleContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:2999</i>
	 */
	@Mangling({"_Z17av_resample_closeP17AVResampleContext", "?av_resample_close@@YAXPA17AVResampleContext@Z"}) 
	void av_resample_close(Pointer c);
	/**
	 * Allocate memory for a picture.  Call avpicture_free to free it.<br>
	 * * @param picture the picture to be filled in<br>
	 * @param pix_fmt the format of the picture<br>
	 * @param width the width of the picture<br>
	 * @param height the height of the picture<br>
	 * @return zero if successful, a negative value if not<br>
	 * Original signature : <code>int avpicture_alloc(AVPicture*, PixelFormat, int, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3010</i><br>
	 * @param pix_fmt @see PixelFormat
	 */
	@Mangling({"_Z15avpicture_allocP9AVPicture11PixelFormatii", "?avpicture_alloc@@YAHPAUAVPicture@@11PixelFormatHH@Z"}) 
	int avpicture_alloc(AVPicture picture, int pix_fmt, int width, int height);
	/**
	 * Free a picture previously allocated by avpicture_alloc().<br>
	 * * @param picture the AVPicture to be freed<br>
	 * Original signature : <code>void avpicture_free(AVPicture*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3017</i>
	 */
	@Mangling({"_Z14avpicture_freeP9AVPicture", "?avpicture_free@@YAXPAUAVPicture@@@Z"}) 
	void avpicture_free(AVPicture picture);
	/**
	 * Fill in the AVPicture fields.<br>
	 * The fields of the given AVPicture are filled in by using the 'ptr' address<br>
	 * which points to the image data buffer. Depending on the specified picture<br>
	 * format, one or multiple image data pointers and line sizes will be set.<br>
	 * If a planar format is specified, several pointers will be set pointing to<br>
	 * the different picture planes and the line sizes of the different planes<br>
	 * will be stored in the lines_sizes array.<br>
	 * Call with ptr == NULL to get the required size for the ptr buffer.<br>
	 * * @param picture AVPicture whose fields are to be filled in<br>
	 * @param ptr Buffer which will contain or contains the actual image data<br>
	 * @param pix_fmt The format in which the picture data is stored.<br>
	 * @param width the width of the image in pixels<br>
	 * @param height the height of the image in pixels<br>
	 * @return size of the image data in bytes<br>
	 * Original signature : <code>int avpicture_fill(AVPicture*, uint8_t*, PixelFormat, int, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3036</i><br>
	 * @deprecated use the safer methods {@link #avpicture_fill(avcodec.AVPicture, java.nio.ByteBuffer, int, int, int)} and {@link #avpicture_fill(avcodec.AVPicture, com.sun.jna.Pointer, int, int, int)} instead<br>
	 * @param pix_fmt @see PixelFormat
	 */
	@Mangling({"_Z14avpicture_fillP9AVPictureP7uint8_t11PixelFormatii", "?avpicture_fill@@YAHPAUAVPicture@@PA7uint8_t11PixelFormatHH@Z"}) 
	@Deprecated 
	int avpicture_fill(AVPicture picture, Pointer ptr, int pix_fmt, int width, int height);
	/**
	 * Fill in the AVPicture fields.<br>
	 * The fields of the given AVPicture are filled in by using the 'ptr' address<br>
	 * which points to the image data buffer. Depending on the specified picture<br>
	 * format, one or multiple image data pointers and line sizes will be set.<br>
	 * If a planar format is specified, several pointers will be set pointing to<br>
	 * the different picture planes and the line sizes of the different planes<br>
	 * will be stored in the lines_sizes array.<br>
	 * Call with ptr == NULL to get the required size for the ptr buffer.<br>
	 * * @param picture AVPicture whose fields are to be filled in<br>
	 * @param ptr Buffer which will contain or contains the actual image data<br>
	 * @param pix_fmt The format in which the picture data is stored.<br>
	 * @param width the width of the image in pixels<br>
	 * @param height the height of the image in pixels<br>
	 * @return size of the image data in bytes<br>
	 * Original signature : <code>int avpicture_fill(AVPicture*, uint8_t*, PixelFormat, int, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3036</i><br>
	 * @param pix_fmt @see PixelFormat
	 */
	@Mangling({"_Z14avpicture_fillP9AVPictureP7uint8_t11PixelFormatii", "?avpicture_fill@@YAHPAUAVPicture@@PA7uint8_t11PixelFormatHH@Z"}) 
	int avpicture_fill(AVPicture picture, ByteBuffer ptr, int pix_fmt, int width, int height);
	/**
	 * Original signature : <code>int avpicture_layout(const AVPicture*, PixelFormat, int, int, unsigned char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3038</i><br>
	 * @deprecated use the safer methods {@link #avpicture_layout(avcodec.AVPicture, int, int, int, java.nio.ByteBuffer, int)} and {@link #avpicture_layout(avcodec.AVPicture, int, int, int, com.sun.jna.Pointer, int)} instead<br>
	 * @param pix_fmt @see PixelFormat
	 */
	@Mangling({"_Z16avpicture_layoutPK9AVPicture11PixelFormatiiPhi", "?avpicture_layout@@YAHPAUAVPicture@@11PixelFormatHHPAEH@Z"}) 
	@Deprecated 
	int avpicture_layout(AVPicture src, int pix_fmt, int width, int height, Pointer dest, int dest_size);
	/**
	 * Original signature : <code>int avpicture_layout(const AVPicture*, PixelFormat, int, int, unsigned char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3038</i><br>
	 * @param pix_fmt @see PixelFormat
	 */
	@Mangling({"_Z16avpicture_layoutPK9AVPicture11PixelFormatiiPhi", "?avpicture_layout@@YAHPAUAVPicture@@11PixelFormatHHPAEH@Z"}) 
	int avpicture_layout(AVPicture src, int pix_fmt, int width, int height, ByteBuffer dest, int dest_size);
	/**
	 * Calculate the size in bytes that a picture of the given width and height<br>
	 * would occupy if stored in the given picture format.<br>
	 * Note that this returns the size of a compact representation as generated<br>
	 * by avpicture_layout, which can be smaller than the size required for e.g.<br>
	 * avpicture_fill.<br>
	 * * @param pix_fmt the given picture format<br>
	 * @param width the width of the image<br>
	 * @param height the height of the image<br>
	 * @return Image data size in bytes or -1 on error (e.g. too large dimensions).<br>
	 * Original signature : <code>int avpicture_get_size(PixelFormat, int, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3053</i><br>
	 * @param pix_fmt @see PixelFormat
	 */
	@Mangling({"_Z18avpicture_get_size11PixelFormatii", "?avpicture_get_size@@YAH11PixelFormatHH@Z"}) 
	int avpicture_get_size(int pix_fmt, int width, int height);
	/**
	 * Original signature : <code>void avcodec_get_chroma_sub_sample(PixelFormat, int*, int*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3054</i><br>
	 * @deprecated use the safer methods {@link #avcodec_get_chroma_sub_sample(int, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #avcodec_get_chroma_sub_sample(int, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead<br>
	 * @param pix_fmt @see PixelFormat
	 */
	@Mangling({"_Z29avcodec_get_chroma_sub_sample11PixelFormatPiPi", "?avcodec_get_chroma_sub_sample@@YAX11PixelFormatPAHPAH@Z"}) 
	@Deprecated 
	void avcodec_get_chroma_sub_sample(int pix_fmt, IntByReference h_shift, IntByReference v_shift);
	/**
	 * Original signature : <code>void avcodec_get_chroma_sub_sample(PixelFormat, int*, int*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3054</i><br>
	 * @param pix_fmt @see PixelFormat
	 */
	@Mangling({"_Z29avcodec_get_chroma_sub_sample11PixelFormatPiPi", "?avcodec_get_chroma_sub_sample@@YAX11PixelFormatPAHPAH@Z"}) 
	void avcodec_get_chroma_sub_sample(int pix_fmt, IntBuffer h_shift, IntBuffer v_shift);
	/**
	 * Original signature : <code>char* avcodec_get_pix_fmt_name(PixelFormat)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3055</i><br>
	 * @param pix_fmt @see PixelFormat
	 */
	@Mangling({"_Z24avcodec_get_pix_fmt_name11PixelFormat", "?avcodec_get_pix_fmt_name@@YAQBD11PixelFormat@Z"}) 
	String avcodec_get_pix_fmt_name(int pix_fmt);
	/**
	 * Original signature : <code>void avcodec_set_dimensions(AVCodecContext*, int, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3056</i>
	 */
	@Mangling({"_Z22avcodec_set_dimensionsP14AVCodecContextii", "?avcodec_set_dimensions@@YAXPAUAVCodecContext@@HH@Z"}) 
	void avcodec_set_dimensions(AVCodecContext s, int width, int height);
	/**
	 * Returns the pixel format corresponding to the name name.<br>
	 * * If there is no pixel format with name name, then looks for a<br>
	 * pixel format with the name corresponding to the native endian<br>
	 * format of name.<br>
	 * For example in a little-endian system, first looks for "gray16",<br>
	 * then for "gray16le".<br>
	 * * Finally if no pixel format has been found, returns PIX_FMT_NONE.<br>
	 * * @deprecated Deprecated in favor of av_get_pix_fmt().<br>
	 * Original signature : <code>PixelFormat avcodec_get_pix_fmt(const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3072</i><br>
	 * @deprecated use the safer methods {@link #avcodec_get_pix_fmt(java.lang.String)} and {@link #avcodec_get_pix_fmt(com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z19avcodec_get_pix_fmtPKc", "?avcodec_get_pix_fmt@@YA11PixelFormatPAD@Z"}) 
	@Deprecated 
	/**
	 * @see PixelFormat
	 */int avcodec_get_pix_fmt(Pointer name);
	/**
	 * Returns the pixel format corresponding to the name name.<br>
	 * * If there is no pixel format with name name, then looks for a<br>
	 * pixel format with the name corresponding to the native endian<br>
	 * format of name.<br>
	 * For example in a little-endian system, first looks for "gray16",<br>
	 * then for "gray16le".<br>
	 * * Finally if no pixel format has been found, returns PIX_FMT_NONE.<br>
	 * * @deprecated Deprecated in favor of av_get_pix_fmt().<br>
	 * Original signature : <code>PixelFormat avcodec_get_pix_fmt(const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3072</i>
	 */
	@Mangling({"_Z19avcodec_get_pix_fmtPKc", "?avcodec_get_pix_fmt@@YA11PixelFormatPAD@Z"}) 
	/**
	 * @see PixelFormat
	 */int avcodec_get_pix_fmt(String name);
	/**
	 * Returns a value representing the fourCC code associated to the<br>
	 * pixel format pix_fmt, or 0 if no associated fourCC code can be<br>
	 * found.<br>
	 * Original signature : <code>int avcodec_pix_fmt_to_codec_tag(PixelFormat)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3080</i><br>
	 * @param pix_fmt @see PixelFormat
	 */
	@Mangling({"_Z28avcodec_pix_fmt_to_codec_tag11PixelFormat", "?avcodec_pix_fmt_to_codec_tag@@YAI11PixelFormat@Z"}) 
	int avcodec_pix_fmt_to_codec_tag(int pix_fmt);
	/**
	 * Computes what kind of losses will occur when converting from one specific<br>
	 * pixel format to another.<br>
	 * When converting from one pixel format to another, information loss may occur.<br>
	 * For example, when converting from RGB24 to GRAY, the color information will<br>
	 * be lost. Similarly, other losses occur when converting from some formats to<br>
	 * other formats. These losses can involve loss of chroma, but also loss of<br>
	 * resolution, loss of color depth, loss due to the color space conversion, loss<br>
	 * of the alpha bits or loss due to color quantization.<br>
	 * avcodec_get_fix_fmt_loss() informs you about the various types of losses<br>
	 * which will occur when converting from one pixel format to another.<br>
	 * * @param[in] dst_pix_fmt destination pixel format<br>
	 * @param[in] src_pix_fmt source pixel format<br>
	 * @param[in] has_alpha Whether the source pixel format alpha channel is used.<br>
	 * @return Combination of flags informing you what kind of losses will occur.<br>
	 * Original signature : <code>int avcodec_get_pix_fmt_loss(PixelFormat, PixelFormat, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3106</i><br>
	 * @param dst_pix_fmt @see PixelFormat<br>
	 * @param src_pix_fmt @see PixelFormat
	 */
	@Mangling({"_Z24avcodec_get_pix_fmt_loss11PixelFormat11PixelFormati", "?avcodec_get_pix_fmt_loss@@YAH11PixelFormat11PixelFormatH@Z"}) 
	int avcodec_get_pix_fmt_loss(int dst_pix_fmt, int src_pix_fmt, int has_alpha);
	/**
	 * Finds the best pixel format to convert to given a certain source pixel<br>
	 * format.  When converting from one pixel format to another, information loss<br>
	 * may occur.  For example, when converting from RGB24 to GRAY, the color<br>
	 * information will be lost. Similarly, other losses occur when converting from<br>
	 * some formats to other formats. avcodec_find_best_pix_fmt() searches which of<br>
	 * the given pixel formats should be used to suffer the least amount of loss.<br>
	 * The pixel formats from which it chooses one, are determined by the<br>
	 * pix_fmt_mask parameter.<br>
	 * * @code<br>
	 * src_pix_fmt = PIX_FMT_YUV420P;<br>
	 * pix_fmt_mask = (1 << PIX_FMT_YUV422P) || (1 << PIX_FMT_RGB24);<br>
	 * dst_pix_fmt = avcodec_find_best_pix_fmt(pix_fmt_mask, src_pix_fmt, alpha, &loss);<br>
	 * @endcode<br>
	 * * @param[in] pix_fmt_mask bitmask determining which pixel format to choose from<br>
	 * @param[in] src_pix_fmt source pixel format<br>
	 * @param[in] has_alpha Whether the source pixel format alpha channel is used.<br>
	 * @param[out] loss_ptr Combination of flags informing you what kind of losses will occur.<br>
	 * @return The best pixel format to convert to or -1 if none was found.<br>
	 * Original signature : <code>PixelFormat avcodec_find_best_pix_fmt(int64_t, PixelFormat, int, int*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3131</i><br>
	 * @deprecated use the safer methods {@link #avcodec_find_best_pix_fmt(long, int, int, java.nio.IntBuffer)} and {@link #avcodec_find_best_pix_fmt(long, int, int, com.sun.jna.ptr.IntByReference)} instead<br>
	 * @param src_pix_fmt @see PixelFormat
	 */
	@Mangling({"_Z25avcodec_find_best_pix_fmt7int64_t11PixelFormatiPi", "?avcodec_find_best_pix_fmt@@YA11PixelFormat7int64_t11PixelFormatHPAH@Z"}) 
	@Deprecated 
	/**
	 * @see PixelFormat
	 */int avcodec_find_best_pix_fmt(long pix_fmt_mask, int src_pix_fmt, int has_alpha, IntByReference loss_ptr);
	/**
	 * Finds the best pixel format to convert to given a certain source pixel<br>
	 * format.  When converting from one pixel format to another, information loss<br>
	 * may occur.  For example, when converting from RGB24 to GRAY, the color<br>
	 * information will be lost. Similarly, other losses occur when converting from<br>
	 * some formats to other formats. avcodec_find_best_pix_fmt() searches which of<br>
	 * the given pixel formats should be used to suffer the least amount of loss.<br>
	 * The pixel formats from which it chooses one, are determined by the<br>
	 * pix_fmt_mask parameter.<br>
	 * * @code<br>
	 * src_pix_fmt = PIX_FMT_YUV420P;<br>
	 * pix_fmt_mask = (1 << PIX_FMT_YUV422P) || (1 << PIX_FMT_RGB24);<br>
	 * dst_pix_fmt = avcodec_find_best_pix_fmt(pix_fmt_mask, src_pix_fmt, alpha, &loss);<br>
	 * @endcode<br>
	 * * @param[in] pix_fmt_mask bitmask determining which pixel format to choose from<br>
	 * @param[in] src_pix_fmt source pixel format<br>
	 * @param[in] has_alpha Whether the source pixel format alpha channel is used.<br>
	 * @param[out] loss_ptr Combination of flags informing you what kind of losses will occur.<br>
	 * @return The best pixel format to convert to or -1 if none was found.<br>
	 * Original signature : <code>PixelFormat avcodec_find_best_pix_fmt(int64_t, PixelFormat, int, int*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3131</i><br>
	 * @param src_pix_fmt @see PixelFormat
	 */
	@Mangling({"_Z25avcodec_find_best_pix_fmt7int64_t11PixelFormatiPi", "?avcodec_find_best_pix_fmt@@YA11PixelFormat7int64_t11PixelFormatHPAH@Z"}) 
	/**
	 * @see PixelFormat
	 */int avcodec_find_best_pix_fmt(long pix_fmt_mask, int src_pix_fmt, int has_alpha, IntBuffer loss_ptr);
	/**
	 * Print in buf the string corresponding to the pixel format with<br>
	 * number pix_fmt, or an header if pix_fmt is negative.<br>
	 * * @param[in] buf the buffer where to write the string<br>
	 * @param[in] buf_size the size of buf<br>
	 * @param[in] pix_fmt the number of the pixel format to print the corresponding info string, or<br>
	 * a negative value to print the corresponding header.<br>
	 * Meaningful values for obtaining a pixel format info vary from 0 to PIX_FMT_NB -1.<br>
	 * Original signature : <code>void avcodec_pix_fmt_string(char*, int, PixelFormat)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3145</i><br>
	 * @deprecated use the safer methods {@link #avcodec_pix_fmt_string(java.nio.ByteBuffer, int, int)} and {@link #avcodec_pix_fmt_string(com.sun.jna.Pointer, int, int)} instead<br>
	 * @param pix_fmt @see PixelFormat
	 */
	@Mangling({"_Z22avcodec_pix_fmt_stringPci11PixelFormat", "?avcodec_pix_fmt_string@@YAXPADH11PixelFormat@Z"}) 
	@Deprecated 
	void avcodec_pix_fmt_string(Pointer buf, int buf_size, int pix_fmt);
	/**
	 * Print in buf the string corresponding to the pixel format with<br>
	 * number pix_fmt, or an header if pix_fmt is negative.<br>
	 * * @param[in] buf the buffer where to write the string<br>
	 * @param[in] buf_size the size of buf<br>
	 * @param[in] pix_fmt the number of the pixel format to print the corresponding info string, or<br>
	 * a negative value to print the corresponding header.<br>
	 * Meaningful values for obtaining a pixel format info vary from 0 to PIX_FMT_NB -1.<br>
	 * Original signature : <code>void avcodec_pix_fmt_string(char*, int, PixelFormat)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3145</i><br>
	 * @param pix_fmt @see PixelFormat
	 */
	@Mangling({"_Z22avcodec_pix_fmt_stringPci11PixelFormat", "?avcodec_pix_fmt_string@@YAXPADH11PixelFormat@Z"}) 
	void avcodec_pix_fmt_string(ByteBuffer buf, int buf_size, int pix_fmt);
	/**
	 * Tell if an image really has transparent alpha values.<br>
	 * @return ored mask of FF_ALPHA_xxx constants<br>
	 * Original signature : <code>int img_get_alpha_info(const AVPicture*, PixelFormat, int, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3154</i><br>
	 * @param pix_fmt @see PixelFormat
	 */
	@Mangling({"_Z18img_get_alpha_infoPK9AVPicture11PixelFormatii", "?img_get_alpha_info@@YAHPAUAVPicture@@11PixelFormatHH@Z"}) 
	int img_get_alpha_info(AVPicture src, int pix_fmt, int width, int height);
	/**
	 * deinterlace - if not supported return -1<br>
	 * Original signature : <code>int avpicture_deinterlace(AVPicture*, const AVPicture*, PixelFormat, int, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3159</i><br>
	 * @param pix_fmt @see PixelFormat
	 */
	@Mangling({"_Z21avpicture_deinterlaceP9AVPicturePK9AVPicture11PixelFormatii", "?avpicture_deinterlace@@YAHPAUAVPicture@@PAUAVPicture@@11PixelFormatHH@Z"}) 
	int avpicture_deinterlace(AVPicture dst, AVPicture src, int pix_fmt, int width, int height);
	/**
	 * If c is NULL, returns the first registered codec,<br>
	 * if c is non-NULL, returns the next registered codec after c,<br>
	 * or NULL if c is the last one.<br>
	 * Original signature : <code>AVCodec* av_codec_next(AVCodec*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3169</i>
	 */
	@Mangling({"_Z13av_codec_nextP7AVCodec", "?av_codec_next@@YAPAUAVCodec@@PAUAVCodec@@@Z"}) 
	AVCodec av_codec_next(AVCodec c);
	/**
	 * Returns the LIBAVCODEC_VERSION_INT constant.<br>
	 * Original signature : <code>avcodec_version()</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3174</i>
	 */
	@Mangling({"_Z15avcodec_versionv", "?avcodec_version@@YAXXZ"}) 
	int avcodec_version();
	/**
	 * Returns the libavcodec build-time configuration.<br>
	 * Original signature : <code>char* avcodec_configuration()</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3179</i>
	 */
	@Mangling({"_Z21avcodec_configurationv", "?avcodec_configuration@@YAQBDXZ"}) 
	String avcodec_configuration();
	/**
	 * Returns the libavcodec license.<br>
	 * Original signature : <code>char* avcodec_license()</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3184</i>
	 */
	@Mangling({"_Z15avcodec_licensev", "?avcodec_license@@YAQBDXZ"}) 
	String avcodec_license();
	/**
	 * Initializes libavcodec.<br>
	 * * @warning This function must be called before any other libavcodec<br>
	 * function.<br>
	 * Original signature : <code>void avcodec_init()</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3192</i>
	 */
	@Mangling({"_Z12avcodec_initv", "?avcodec_init@@YAXXZ"}) 
	void avcodec_init();
	/**
	 * @deprecated Deprecated in favor of avcodec_register().<br>
	 * Original signature : <code>void register_avcodec(AVCodec*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3198</i>
	 */
	@Mangling({"_Z16register_avcodecP7AVCodec", "?register_avcodec@@YAXPAUAVCodec@@@Z"}) 
	void register_avcodec(AVCodec codec);
	/**
	 * Register the codec codec and initialize libavcodec.<br>
	 * * @see avcodec_init()<br>
	 * Original signature : <code>void avcodec_register(AVCodec*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3206</i>
	 */
	@Mangling({"_Z16avcodec_registerP7AVCodec", "?avcodec_register@@YAXPAUAVCodec@@@Z"}) 
	void avcodec_register(AVCodec codec);
	/**
	 * Finds a registered encoder with a matching codec ID.<br>
	 * * @param id CodecID of the requested encoder<br>
	 * @return An encoder if one was found, NULL otherwise.<br>
	 * Original signature : <code>AVCodec* avcodec_find_encoder(CodecID)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3214</i><br>
	 * @param id @see CodecID
	 */
	@Mangling({"_Z20avcodec_find_encoder7CodecID", "?avcodec_find_encoder@@YAPAUAVCodec@@7CodecID@Z"}) 
	AVCodec avcodec_find_encoder(int id);
	/**
	 * Finds a registered encoder with the specified name.<br>
	 * * @param name name of the requested encoder<br>
	 * @return An encoder if one was found, NULL otherwise.<br>
	 * Original signature : <code>AVCodec* avcodec_find_encoder_by_name(const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3222</i><br>
	 * @deprecated use the safer methods {@link #avcodec_find_encoder_by_name(java.lang.String)} and {@link #avcodec_find_encoder_by_name(com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z28avcodec_find_encoder_by_namePKc", "?avcodec_find_encoder_by_name@@YAPAUAVCodec@@PAD@Z"}) 
	@Deprecated 
	AVCodec avcodec_find_encoder_by_name(Pointer name);
	/**
	 * Finds a registered encoder with the specified name.<br>
	 * * @param name name of the requested encoder<br>
	 * @return An encoder if one was found, NULL otherwise.<br>
	 * Original signature : <code>AVCodec* avcodec_find_encoder_by_name(const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3222</i>
	 */
	@Mangling({"_Z28avcodec_find_encoder_by_namePKc", "?avcodec_find_encoder_by_name@@YAPAUAVCodec@@PAD@Z"}) 
	AVCodec avcodec_find_encoder_by_name(String name);
	/**
	 * Finds a registered decoder with a matching codec ID.<br>
	 * * @param id CodecID of the requested decoder<br>
	 * @return A decoder if one was found, NULL otherwise.<br>
	 * Original signature : <code>AVCodec* avcodec_find_decoder(CodecID)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3230</i><br>
	 * @param id @see CodecID
	 */
	@Mangling({"_Z20avcodec_find_decoder7CodecID", "?avcodec_find_decoder@@YAPAUAVCodec@@7CodecID@Z"}) 
	AVCodec avcodec_find_decoder(int id);
	/**
	 * Finds a registered decoder with the specified name.<br>
	 * * @param name name of the requested decoder<br>
	 * @return A decoder if one was found, NULL otherwise.<br>
	 * Original signature : <code>AVCodec* avcodec_find_decoder_by_name(const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3238</i><br>
	 * @deprecated use the safer methods {@link #avcodec_find_decoder_by_name(java.lang.String)} and {@link #avcodec_find_decoder_by_name(com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z28avcodec_find_decoder_by_namePKc", "?avcodec_find_decoder_by_name@@YAPAUAVCodec@@PAD@Z"}) 
	@Deprecated 
	AVCodec avcodec_find_decoder_by_name(Pointer name);
	/**
	 * Finds a registered decoder with the specified name.<br>
	 * * @param name name of the requested decoder<br>
	 * @return A decoder if one was found, NULL otherwise.<br>
	 * Original signature : <code>AVCodec* avcodec_find_decoder_by_name(const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3238</i>
	 */
	@Mangling({"_Z28avcodec_find_decoder_by_namePKc", "?avcodec_find_decoder_by_name@@YAPAUAVCodec@@PAD@Z"}) 
	AVCodec avcodec_find_decoder_by_name(String name);
	/**
	 * Original signature : <code>void avcodec_string(char*, int, AVCodecContext*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3239</i><br>
	 * @deprecated use the safer methods {@link #avcodec_string(java.nio.ByteBuffer, int, avcodec.AVCodecContext, int)} and {@link #avcodec_string(com.sun.jna.Pointer, int, avcodec.AVCodecContext, int)} instead
	 */
	@Mangling({"_Z14avcodec_stringPciP14AVCodecContexti", "?avcodec_string@@YAXPADHPAUAVCodecContext@@H@Z"}) 
	@Deprecated 
	void avcodec_string(Pointer buf, int buf_size, AVCodecContext enc, int encode);
	/**
	 * Original signature : <code>void avcodec_string(char*, int, AVCodecContext*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3239</i>
	 */
	@Mangling({"_Z14avcodec_stringPciP14AVCodecContexti", "?avcodec_string@@YAXPADHPAUAVCodecContext@@H@Z"}) 
	void avcodec_string(ByteBuffer buf, int buf_size, AVCodecContext enc, int encode);
	/**
	 * Sets the fields of the given AVCodecContext to default values.<br>
	 * * @param s The AVCodecContext of which the fields should be set to default values.<br>
	 * Original signature : <code>void avcodec_get_context_defaults(AVCodecContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3246</i>
	 */
	@Mangling({"_Z28avcodec_get_context_defaultsP14AVCodecContext", "?avcodec_get_context_defaults@@YAXPAUAVCodecContext@@@Z"}) 
	void avcodec_get_context_defaults(AVCodecContext s);
	/**
	 * THIS FUNCTION IS NOT YET PART OF THE PUBLIC API!<br>
	 *  we WILL change its arguments and name a few times!<br>
	 * Original signature : <code>void avcodec_get_context_defaults2(AVCodecContext*, AVMediaType)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3250</i><br>
	 * @param arg1 @see AVMediaType
	 */
	@Mangling({"_Z29avcodec_get_context_defaults2P14AVCodecContext11AVMediaType", "?avcodec_get_context_defaults2@@YAXPAUAVCodecContext@@11AVMediaType@Z"}) 
	void avcodec_get_context_defaults2(AVCodecContext s, int arg1);
	/**
	 * Allocates an AVCodecContext and sets its fields to default values.  The<br>
	 * resulting struct can be deallocated by simply calling av_free().<br>
	 * * @return An AVCodecContext filled with default values or NULL on failure.<br>
	 * @see avcodec_get_context_defaults<br>
	 * Original signature : <code>AVCodecContext* avcodec_alloc_context()</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3259</i>
	 */
	@Mangling({"_Z21avcodec_alloc_contextv", "?avcodec_alloc_context@@YAPAUAVCodecContext@@XZ"}) 
	AVCodecContext avcodec_alloc_context();
	/**
	 * THIS FUNCTION IS NOT YET PART OF THE PUBLIC API!<br>
	 *  we WILL change its arguments and name a few times!<br>
	 * Original signature : <code>AVCodecContext* avcodec_alloc_context2(AVMediaType)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3263</i><br>
	 * @param arg1 @see AVMediaType
	 */
	@Mangling({"_Z22avcodec_alloc_context211AVMediaType", "?avcodec_alloc_context2@@YAPAUAVCodecContext@@11AVMediaType@Z"}) 
	AVCodecContext avcodec_alloc_context2(int arg1);
	/**
	 * Copy the settings of the source AVCodecContext into the destination<br>
	 * AVCodecContext. The resulting destination codec context will be<br>
	 * unopened, i.e. you are required to call avcodec_open() before you<br>
	 * can use this AVCodecContext to decode/encode video/audio data.<br>
	 * * @param dest target codec context, should be initialized with<br>
	 *             avcodec_alloc_context(), but otherwise uninitialized<br>
	 * @param src source codec context<br>
	 * @return AVERROR() on error (e.g. memory allocation error), 0 on success<br>
	 * Original signature : <code>int avcodec_copy_context(AVCodecContext*, const AVCodecContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3276</i>
	 */
	@Mangling({"_Z20avcodec_copy_contextP14AVCodecContextPK14AVCodecContext", "?avcodec_copy_context@@YAHPAUAVCodecContext@@PAUAVCodecContext@@@Z"}) 
	int avcodec_copy_context(AVCodecContext dest, AVCodecContext src);
	/**
	 * Sets the fields of the given AVFrame to default values.<br>
	 * * @param pic The AVFrame of which the fields should be set to default values.<br>
	 * Original signature : <code>void avcodec_get_frame_defaults(AVFrame*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3283</i>
	 */
	@Mangling({"_Z26avcodec_get_frame_defaultsP7AVFrame", "?avcodec_get_frame_defaults@@YAXPAUAVFrame@@@Z"}) 
	void avcodec_get_frame_defaults(AVFrame pic);
	/**
	 * Allocates an AVFrame and sets its fields to default values.  The resulting<br>
	 * struct can be deallocated by simply calling av_free().<br>
	 * * @return An AVFrame filled with default values or NULL on failure.<br>
	 * @see avcodec_get_frame_defaults<br>
	 * Original signature : <code>AVFrame* avcodec_alloc_frame()</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3292</i>
	 */
	@Mangling({"_Z19avcodec_alloc_framev", "?avcodec_alloc_frame@@YAPAUAVFrame@@XZ"}) 
	AVFrame avcodec_alloc_frame();
	/**
	 * Original signature : <code>int avcodec_default_get_buffer(AVCodecContext*, AVFrame*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3294</i>
	 */
	@Mangling({"_Z26avcodec_default_get_bufferP14AVCodecContextP7AVFrame", "?avcodec_default_get_buffer@@YAHPAUAVCodecContext@@PAUAVFrame@@@Z"}) 
	int avcodec_default_get_buffer(AVCodecContext s, AVFrame pic);
	/**
	 * Original signature : <code>void avcodec_default_release_buffer(AVCodecContext*, AVFrame*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3295</i>
	 */
	@Mangling({"_Z30avcodec_default_release_bufferP14AVCodecContextP7AVFrame", "?avcodec_default_release_buffer@@YAXPAUAVCodecContext@@PAUAVFrame@@@Z"}) 
	void avcodec_default_release_buffer(AVCodecContext s, AVFrame pic);
	/**
	 * Original signature : <code>int avcodec_default_reget_buffer(AVCodecContext*, AVFrame*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3296</i>
	 */
	@Mangling({"_Z28avcodec_default_reget_bufferP14AVCodecContextP7AVFrame", "?avcodec_default_reget_buffer@@YAHPAUAVCodecContext@@PAUAVFrame@@@Z"}) 
	int avcodec_default_reget_buffer(AVCodecContext s, AVFrame pic);
	/**
	 * Returns the amount of padding in pixels which the get_buffer callback must<br>
	 * provide around the edge of the image for codecs which do not have the<br>
	 * CODEC_FLAG_EMU_EDGE flag.<br>
	 * * @return Required padding in pixels.<br>
	 * Original signature : <code>avcodec_get_edge_width()</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3305</i>
	 */
	@Mangling({"_Z22avcodec_get_edge_widthv", "?avcodec_get_edge_width@@YAXXZ"}) 
	int avcodec_get_edge_width();
	/**
	 * Modifies width and height values so that they will result in a memory<br>
	 * buffer that is acceptable for the codec if you do not use any horizontal<br>
	 * padding.<br>
	 * * May only be used if a codec with CODEC_CAP_DR1 has been opened.<br>
	 * If CODEC_FLAG_EMU_EDGE is not set, the dimensions must have been increased<br>
	 * according to avcodec_get_edge_width() before.<br>
	 * Original signature : <code>void avcodec_align_dimensions(AVCodecContext*, int*, int*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3315</i><br>
	 * @deprecated use the safer methods {@link #avcodec_align_dimensions(avcodec.AVCodecContext, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #avcodec_align_dimensions(avcodec.AVCodecContext, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Mangling({"_Z24avcodec_align_dimensionsP14AVCodecContextPiPi", "?avcodec_align_dimensions@@YAXPAUAVCodecContext@@PAHPAH@Z"}) 
	@Deprecated 
	void avcodec_align_dimensions(AVCodecContext s, IntByReference width, IntByReference height);
	/**
	 * Modifies width and height values so that they will result in a memory<br>
	 * buffer that is acceptable for the codec if you do not use any horizontal<br>
	 * padding.<br>
	 * * May only be used if a codec with CODEC_CAP_DR1 has been opened.<br>
	 * If CODEC_FLAG_EMU_EDGE is not set, the dimensions must have been increased<br>
	 * according to avcodec_get_edge_width() before.<br>
	 * Original signature : <code>void avcodec_align_dimensions(AVCodecContext*, int*, int*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3315</i>
	 */
	@Mangling({"_Z24avcodec_align_dimensionsP14AVCodecContextPiPi", "?avcodec_align_dimensions@@YAXPAUAVCodecContext@@PAHPAH@Z"}) 
	void avcodec_align_dimensions(AVCodecContext s, IntBuffer width, IntBuffer height);
	/**
	 * Modifies width and height values so that they will result in a memory<br>
	 * buffer that is acceptable for the codec if you also ensure that all<br>
	 * line sizes are a multiple of the respective linesize_align[i].<br>
	 * * May only be used if a codec with CODEC_CAP_DR1 has been opened.<br>
	 * If CODEC_FLAG_EMU_EDGE is not set, the dimensions must have been increased<br>
	 * according to avcodec_get_edge_width() before.<br>
	 * Original signature : <code>void avcodec_align_dimensions2(AVCodecContext*, int*, int*, int[4])</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3325</i><br>
	 * @deprecated use the safer methods {@link #avcodec_align_dimensions2(avcodec.AVCodecContext, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #avcodec_align_dimensions2(avcodec.AVCodecContext, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Mangling({"_Z25avcodec_align_dimensions2P14AVCodecContextPiPiPi", "?avcodec_align_dimensions2@@YAXPAUAVCodecContext@@PAHPAHQAH@Z"}) 
	@Deprecated 
	void avcodec_align_dimensions2(AVCodecContext s, IntByReference width, IntByReference height, IntByReference linesize_align);
	/**
	 * Modifies width and height values so that they will result in a memory<br>
	 * buffer that is acceptable for the codec if you also ensure that all<br>
	 * line sizes are a multiple of the respective linesize_align[i].<br>
	 * * May only be used if a codec with CODEC_CAP_DR1 has been opened.<br>
	 * If CODEC_FLAG_EMU_EDGE is not set, the dimensions must have been increased<br>
	 * according to avcodec_get_edge_width() before.<br>
	 * Original signature : <code>void avcodec_align_dimensions2(AVCodecContext*, int*, int*, int[4])</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3325</i>
	 */
	@Mangling({"_Z25avcodec_align_dimensions2P14AVCodecContextPiPiPi", "?avcodec_align_dimensions2@@YAXPAUAVCodecContext@@PAHPAHQAH@Z"}) 
	void avcodec_align_dimensions2(AVCodecContext s, IntBuffer width, IntBuffer height, IntBuffer linesize_align);
	/**
	 * Checks if the given dimension of a picture is valid, meaning that all<br>
	 * bytes of the picture can be addressed with a signed int.<br>
	 * * @param[in] w Width of the picture.<br>
	 * @param[in] h Height of the picture.<br>
	 * @return Zero if valid, a negative value if invalid.<br>
	 * Original signature : <code>int avcodec_check_dimensions(void*, unsigned int, unsigned int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3336</i>
	 */
	@Mangling({"_Z24avcodec_check_dimensionsPvjj", "?avcodec_check_dimensions@@YAHPAXII@Z"}) 
	int avcodec_check_dimensions(Pointer av_log_ctx, int w, int h);
	/**
	 * Original signature : <code>PixelFormat avcodec_default_get_format(AVCodecContext*, PixelFormat*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3337</i><br>
	 * @deprecated use the safer methods {@link #avcodec_default_get_format(avcodec.AVCodecContext, java.nio.IntBuffer)} and {@link #avcodec_default_get_format(avcodec.AVCodecContext, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Mangling({"_Z26avcodec_default_get_formatP14AVCodecContextP11PixelFormat", "?avcodec_default_get_format@@YA11PixelFormatPAUAVCodecContext@@PA11PixelFormat@Z"}) 
	@Deprecated 
	/**
	 * @see PixelFormat
	 */int avcodec_default_get_format(AVCodecContext s, IntByReference fmt);
	/**
	 * Original signature : <code>PixelFormat avcodec_default_get_format(AVCodecContext*, PixelFormat*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3337</i>
	 */
	@Mangling({"_Z26avcodec_default_get_formatP14AVCodecContextP11PixelFormat", "?avcodec_default_get_format@@YA11PixelFormatPAUAVCodecContext@@PA11PixelFormat@Z"}) 
	/**
	 * @see PixelFormat
	 */int avcodec_default_get_format(AVCodecContext s, IntBuffer fmt);
	/**
	 * Original signature : <code>int avcodec_thread_init(AVCodecContext*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3339</i>
	 */
	@Mangling({"_Z19avcodec_thread_initP14AVCodecContexti", "?avcodec_thread_init@@YAHPAUAVCodecContext@@H@Z"}) 
	int avcodec_thread_init(AVCodecContext s, int thread_count);
	/**
	 * Original signature : <code>void avcodec_thread_free(AVCodecContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3340</i>
	 */
	@Mangling({"_Z19avcodec_thread_freeP14AVCodecContext", "?avcodec_thread_free@@YAXPAUAVCodecContext@@@Z"}) 
	void avcodec_thread_free(AVCodecContext s);
	/**
	 * Original signature : <code>int avcodec_default_execute(AVCodecContext*, avcodec_default_execute_arg1_func_callback, void*, int*, int, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3341</i><br>
	 * @deprecated use the safer methods {@link #avcodec_default_execute(avcodec.AVCodecContext, avcodec.AvcodecLibrary.avcodec_default_execute_arg1_func_callback, com.sun.jna.Pointer, java.nio.IntBuffer, int, int)} and {@link #avcodec_default_execute(avcodec.AVCodecContext, avcodec.AvcodecLibrary.avcodec_default_execute_arg1_func_callback, com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference, int, int)} instead
	 */
	@Mangling({"_Z23avcodec_default_executeP14AVCodecContextPFiP14AVCodecContextPvEPvPiii", "?avcodec_default_execute@@YAHPAUAVCodecContext@@PFHPAUAVCodecContext@@PAX@EPAXPAHHH@Z"}) 
	@Deprecated 
	int avcodec_default_execute(AVCodecContext c, AvcodecLibrary.avcodec_default_execute_arg1_func_callback arg1, Pointer arg, IntByReference ret, int count, int size);
	/**
	 * Original signature : <code>int avcodec_default_execute(AVCodecContext*, avcodec_default_execute_arg1_func_callback, void*, int*, int, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3341</i>
	 */
	@Mangling({"_Z23avcodec_default_executeP14AVCodecContextPFiP14AVCodecContextPvEPvPiii", "?avcodec_default_execute@@YAHPAUAVCodecContext@@PFHPAUAVCodecContext@@PAX@EPAXPAHHH@Z"}) 
	int avcodec_default_execute(AVCodecContext c, AvcodecLibrary.avcodec_default_execute_arg1_func_callback arg1, Pointer arg, IntBuffer ret, int count, int size);
	/**
	 * Original signature : <code>int avcodec_default_execute2(AVCodecContext*, avcodec_default_execute2_arg1_func_callback, void*, int*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3342</i><br>
	 * @deprecated use the safer methods {@link #avcodec_default_execute2(avcodec.AVCodecContext, avcodec.AvcodecLibrary.avcodec_default_execute2_arg1_func_callback, com.sun.jna.Pointer, java.nio.IntBuffer, int)} and {@link #avcodec_default_execute2(avcodec.AVCodecContext, avcodec.AvcodecLibrary.avcodec_default_execute2_arg1_func_callback, com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference, int)} instead
	 */
	@Mangling({"_Z24avcodec_default_execute2P14AVCodecContextPFiP14AVCodecContextPviiEPvPii", "?avcodec_default_execute2@@YAHPAUAVCodecContext@@PFHPAUAVCodecContext@@PAXHH@EPAXPAHH@Z"}) 
	@Deprecated 
	int avcodec_default_execute2(AVCodecContext c, AvcodecLibrary.avcodec_default_execute2_arg1_func_callback arg1, Pointer arg, IntByReference ret, int count);
	/**
	 * Original signature : <code>int avcodec_default_execute2(AVCodecContext*, avcodec_default_execute2_arg1_func_callback, void*, int*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3342</i>
	 */
	@Mangling({"_Z24avcodec_default_execute2P14AVCodecContextPFiP14AVCodecContextPviiEPvPii", "?avcodec_default_execute2@@YAHPAUAVCodecContext@@PFHPAUAVCodecContext@@PAXHH@EPAXPAHH@Z"}) 
	int avcodec_default_execute2(AVCodecContext c, AvcodecLibrary.avcodec_default_execute2_arg1_func_callback arg1, Pointer arg, IntBuffer ret, int count);
	/**
	 * Initializes the AVCodecContext to use the given AVCodec. Prior to using this<br>
	 * function the context has to be allocated.<br>
	 * * The functions avcodec_find_decoder_by_name(), avcodec_find_encoder_by_name(),<br>
	 * avcodec_find_decoder() and avcodec_find_encoder() provide an easy way for<br>
	 * retrieving a codec.<br>
	 * * @warning This function is not thread safe!<br>
	 * * @code<br>
	 * avcodec_register_all();<br>
	 * codec = avcodec_find_decoder(CODEC_ID_H264);<br>
	 * if (!codec)<br>
	 *     exit(1);<br>
	 * * context = avcodec_alloc_context();<br>
	 * * if (avcodec_open(context, codec) < 0)<br>
	 *     exit(1);<br>
	 * @endcode<br>
	 * * @param avctx The context which will be set up to use the given codec.<br>
	 * @param codec The codec to use within the context.<br>
	 * @return zero on success, a negative value on error<br>
	 * @see avcodec_alloc_context, avcodec_find_decoder, avcodec_find_encoder<br>
	 * Original signature : <code>int avcodec_open(AVCodecContext*, AVCodec*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3372</i>
	 */
	@Mangling({"_Z12avcodec_openP14AVCodecContextP7AVCodec", "?avcodec_open@@YAHPAUAVCodecContext@@PAUAVCodec@@@Z"}) 
	int avcodec_open(AVCodecContext avctx, AVCodec codec);
	/**
	 * Decodes an audio frame from buf into samples.<br>
	 * Wrapper function which calls avcodec_decode_audio3.<br>
	 * * @deprecated Use avcodec_decode_audio3 instead.<br>
	 * @param avctx the codec context<br>
	 * @param[out] samples the output buffer<br>
	 * @param[in,out] frame_size_ptr the output buffer size in bytes<br>
	 * @param[in] buf the input buffer<br>
	 * @param[in] buf_size the input buffer size in bytes<br>
	 * @return On error a negative value is returned, otherwise the number of bytes<br>
	 * used or zero if no frame could be decompressed.<br>
	 * Original signature : <code>int avcodec_decode_audio2(AVCodecContext*, int16_t*, int*, const uint8_t*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3388</i><br>
	 * @deprecated use the safer methods {@link #avcodec_decode_audio2(avcodec.AVCodecContext, java.nio.ShortBuffer, java.nio.IntBuffer, byte[], int)} and {@link #avcodec_decode_audio2(avcodec.AVCodecContext, com.sun.jna.ptr.ShortByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.Pointer, int)} instead
	 */
	@Mangling({"_Z21avcodec_decode_audio2P14AVCodecContextP7int16_tPiPK7uint8_ti", "?avcodec_decode_audio2@@YAHPAUAVCodecContext@@PA7int16_tPAHPA7uint8_tH@Z"}) 
	@Deprecated 
	int avcodec_decode_audio2(AVCodecContext avctx, ShortByReference samples, IntByReference frame_size_ptr, Pointer buf, int buf_size);
	/**
	 * Decodes an audio frame from buf into samples.<br>
	 * Wrapper function which calls avcodec_decode_audio3.<br>
	 * * @deprecated Use avcodec_decode_audio3 instead.<br>
	 * @param avctx the codec context<br>
	 * @param[out] samples the output buffer<br>
	 * @param[in,out] frame_size_ptr the output buffer size in bytes<br>
	 * @param[in] buf the input buffer<br>
	 * @param[in] buf_size the input buffer size in bytes<br>
	 * @return On error a negative value is returned, otherwise the number of bytes<br>
	 * used or zero if no frame could be decompressed.<br>
	 * Original signature : <code>int avcodec_decode_audio2(AVCodecContext*, int16_t*, int*, const uint8_t*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3388</i>
	 */
	@Mangling({"_Z21avcodec_decode_audio2P14AVCodecContextP7int16_tPiPK7uint8_ti", "?avcodec_decode_audio2@@YAHPAUAVCodecContext@@PA7int16_tPAHPA7uint8_tH@Z"}) 
	int avcodec_decode_audio2(AVCodecContext avctx, ShortBuffer samples, IntBuffer frame_size_ptr, byte buf[], int buf_size);
	/**
	 * Decodes the audio frame of size avpkt->size from avpkt->data into samples.<br>
	 * Some decoders may support multiple frames in a single AVPacket, such<br>
	 * decoders would then just decode the first frame. In this case,<br>
	 * avcodec_decode_audio3 has to be called again with an AVPacket that contains<br>
	 * the remaining data in order to decode the second frame etc.<br>
	 * If no frame<br>
	 * could be outputted, frame_size_ptr is zero. Otherwise, it is the<br>
	 * decompressed frame size in bytes.<br>
	 * * @warning You must set frame_size_ptr to the allocated size of the<br>
	 * output buffer before calling avcodec_decode_audio3().<br>
	 * * @warning The input buffer must be FF_INPUT_BUFFER_PADDING_SIZE larger than<br>
	 * the actual read bytes because some optimized bitstream readers read 32 or 64<br>
	 * bits at once and could read over the end.<br>
	 * * @warning The end of the input buffer avpkt->data should be set to 0 to ensure that<br>
	 * no overreading happens for damaged MPEG streams.<br>
	 * * @note You might have to align the input buffer avpkt->data and output buffer<br>
	 * samples. The alignment requirements depend on the CPU: On some CPUs it isn't<br>
	 * necessary at all, on others it won't work at all if not aligned and on others<br>
	 * it will work but it will have an impact on performance.<br>
	 * * In practice, avpkt->data should have 4 byte alignment at minimum and<br>
	 * samples should be 16 byte aligned unless the CPU doesn't need it<br>
	 * (AltiVec and SSE do).<br>
	 * * @param avctx the codec context<br>
	 * @param[out] samples the output buffer, sample type in avctx->sample_fmt<br>
	 * @param[in,out] frame_size_ptr the output buffer size in bytes<br>
	 * @param[in] avpkt The input AVPacket containing the input buffer.<br>
	 *            You can create such packet with av_init_packet() and by then setting<br>
	 *            data and size, some decoders might in addition need other fields.<br>
	 *            All decoders are designed to use the least fields possible though.<br>
	 * @return On error a negative value is returned, otherwise the number of bytes<br>
	 * used or zero if no frame data was decompressed (used) from the input AVPacket.<br>
	 * Original signature : <code>int avcodec_decode_audio3(AVCodecContext*, int16_t*, int*, AVPacket*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3432</i><br>
	 * @deprecated use the safer methods {@link #avcodec_decode_audio3(avcodec.AVCodecContext, java.nio.ShortBuffer, java.nio.IntBuffer, avcodec.AVPacket)} and {@link #avcodec_decode_audio3(avcodec.AVCodecContext, com.sun.jna.ptr.ShortByReference, com.sun.jna.ptr.IntByReference, avcodec.AVPacket)} instead
	 */
	@Mangling({"_Z21avcodec_decode_audio3P14AVCodecContextP7int16_tPiP8AVPacket", "?avcodec_decode_audio3@@YAHPAUAVCodecContext@@PA7int16_tPAHPAUAVPacket@@@Z"}) 
	@Deprecated 
	int avcodec_decode_audio3(AVCodecContext avctx, ShortByReference samples, IntByReference frame_size_ptr, AVPacket avpkt);
	/**
	 * Decodes the audio frame of size avpkt->size from avpkt->data into samples.<br>
	 * Some decoders may support multiple frames in a single AVPacket, such<br>
	 * decoders would then just decode the first frame. In this case,<br>
	 * avcodec_decode_audio3 has to be called again with an AVPacket that contains<br>
	 * the remaining data in order to decode the second frame etc.<br>
	 * If no frame<br>
	 * could be outputted, frame_size_ptr is zero. Otherwise, it is the<br>
	 * decompressed frame size in bytes.<br>
	 * * @warning You must set frame_size_ptr to the allocated size of the<br>
	 * output buffer before calling avcodec_decode_audio3().<br>
	 * * @warning The input buffer must be FF_INPUT_BUFFER_PADDING_SIZE larger than<br>
	 * the actual read bytes because some optimized bitstream readers read 32 or 64<br>
	 * bits at once and could read over the end.<br>
	 * * @warning The end of the input buffer avpkt->data should be set to 0 to ensure that<br>
	 * no overreading happens for damaged MPEG streams.<br>
	 * * @note You might have to align the input buffer avpkt->data and output buffer<br>
	 * samples. The alignment requirements depend on the CPU: On some CPUs it isn't<br>
	 * necessary at all, on others it won't work at all if not aligned and on others<br>
	 * it will work but it will have an impact on performance.<br>
	 * * In practice, avpkt->data should have 4 byte alignment at minimum and<br>
	 * samples should be 16 byte aligned unless the CPU doesn't need it<br>
	 * (AltiVec and SSE do).<br>
	 * * @param avctx the codec context<br>
	 * @param[out] samples the output buffer, sample type in avctx->sample_fmt<br>
	 * @param[in,out] frame_size_ptr the output buffer size in bytes<br>
	 * @param[in] avpkt The input AVPacket containing the input buffer.<br>
	 *            You can create such packet with av_init_packet() and by then setting<br>
	 *            data and size, some decoders might in addition need other fields.<br>
	 *            All decoders are designed to use the least fields possible though.<br>
	 * @return On error a negative value is returned, otherwise the number of bytes<br>
	 * used or zero if no frame data was decompressed (used) from the input AVPacket.<br>
	 * Original signature : <code>int avcodec_decode_audio3(AVCodecContext*, int16_t*, int*, AVPacket*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3432</i>
	 */
	@Mangling({"_Z21avcodec_decode_audio3P14AVCodecContextP7int16_tPiP8AVPacket", "?avcodec_decode_audio3@@YAHPAUAVCodecContext@@PA7int16_tPAHPAUAVPacket@@@Z"}) 
	int avcodec_decode_audio3(AVCodecContext avctx, ShortBuffer samples, IntBuffer frame_size_ptr, AVPacket avpkt);
	/**
	 * Decodes a video frame from buf into picture.<br>
	 * Wrapper function which calls avcodec_decode_video2.<br>
	 * * @deprecated Use avcodec_decode_video2 instead.<br>
	 * @param avctx the codec context<br>
	 * @param[out] picture The AVFrame in which the decoded video frame will be stored.<br>
	 * @param[in] buf the input buffer<br>
	 * @param[in] buf_size the size of the input buffer in bytes<br>
	 * @param[in,out] got_picture_ptr Zero if no frame could be decompressed, otherwise, it is nonzero.<br>
	 * @return On error a negative value is returned, otherwise the number of bytes<br>
	 * used or zero if no frame could be decompressed.<br>
	 * Original signature : <code>int avcodec_decode_video(AVCodecContext*, AVFrame*, int*, const uint8_t*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3450</i><br>
	 * @deprecated use the safer methods {@link #avcodec_decode_video(avcodec.AVCodecContext, avcodec.AVFrame, java.nio.IntBuffer, byte[], int)} and {@link #avcodec_decode_video(avcodec.AVCodecContext, avcodec.AVFrame, com.sun.jna.ptr.IntByReference, com.sun.jna.Pointer, int)} instead
	 */
	@Mangling({"_Z20avcodec_decode_videoP14AVCodecContextP7AVFramePiPK7uint8_ti", "?avcodec_decode_video@@YAHPAUAVCodecContext@@PAUAVFrame@@PAHPA7uint8_tH@Z"}) 
	@Deprecated 
	int avcodec_decode_video(AVCodecContext avctx, AVFrame picture, IntByReference got_picture_ptr, Pointer buf, int buf_size);
	/**
	 * Decodes a video frame from buf into picture.<br>
	 * Wrapper function which calls avcodec_decode_video2.<br>
	 * * @deprecated Use avcodec_decode_video2 instead.<br>
	 * @param avctx the codec context<br>
	 * @param[out] picture The AVFrame in which the decoded video frame will be stored.<br>
	 * @param[in] buf the input buffer<br>
	 * @param[in] buf_size the size of the input buffer in bytes<br>
	 * @param[in,out] got_picture_ptr Zero if no frame could be decompressed, otherwise, it is nonzero.<br>
	 * @return On error a negative value is returned, otherwise the number of bytes<br>
	 * used or zero if no frame could be decompressed.<br>
	 * Original signature : <code>int avcodec_decode_video(AVCodecContext*, AVFrame*, int*, const uint8_t*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3450</i>
	 */
	@Mangling({"_Z20avcodec_decode_videoP14AVCodecContextP7AVFramePiPK7uint8_ti", "?avcodec_decode_video@@YAHPAUAVCodecContext@@PAUAVFrame@@PAHPA7uint8_tH@Z"}) 
	int avcodec_decode_video(AVCodecContext avctx, AVFrame picture, IntBuffer got_picture_ptr, byte buf[], int buf_size);
	/**
	 * Decodes the video frame of size avpkt->size from avpkt->data into picture.<br>
	 * Some decoders may support multiple frames in a single AVPacket, such<br>
	 * decoders would then just decode the first frame.<br>
	 * * @warning The input buffer must be FF_INPUT_BUFFER_PADDING_SIZE larger than<br>
	 * the actual read bytes because some optimized bitstream readers read 32 or 64<br>
	 * bits at once and could read over the end.<br>
	 * * @warning The end of the input buffer buf should be set to 0 to ensure that<br>
	 * no overreading happens for damaged MPEG streams.<br>
	 * * @note You might have to align the input buffer avpkt->data.<br>
	 * The alignment requirements depend on the CPU: on some CPUs it isn't<br>
	 * necessary at all, on others it won't work at all if not aligned and on others<br>
	 * it will work but it will have an impact on performance.<br>
	 * * In practice, avpkt->data should have 4 byte alignment at minimum.<br>
	 * * @note Some codecs have a delay between input and output, these need to be<br>
	 * fed with avpkt->data=NULL, avpkt->size=0 at the end to return the remaining frames.<br>
	 * * @param avctx the codec context<br>
	 * @param[out] picture The AVFrame in which the decoded video frame will be stored.<br>
	 *             Use avcodec_alloc_frame to get an AVFrame, the codec will<br>
	 *             allocate memory for the actual bitmap.<br>
	 * @param[in] avpkt The input AVpacket containing the input buffer.<br>
	 *            You can create such packet with av_init_packet() and by then setting<br>
	 *            data and size, some decoders might in addition need other fields like<br>
	 *            flags&AV_PKT_FLAG_KEY. All decoders are designed to use the least<br>
	 *            fields possible.<br>
	 * @param[in,out] got_picture_ptr Zero if no frame could be decompressed, otherwise, it is nonzero.<br>
	 * @return On error a negative value is returned, otherwise the number of bytes<br>
	 * used or zero if no frame could be decompressed.<br>
	 * Original signature : <code>int avcodec_decode_video2(AVCodecContext*, AVFrame*, int*, AVPacket*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3490</i><br>
	 * @deprecated use the safer methods {@link #avcodec_decode_video2(avcodec.AVCodecContext, avcodec.AVFrame, java.nio.IntBuffer, avcodec.AVPacket)} and {@link #avcodec_decode_video2(avcodec.AVCodecContext, avcodec.AVFrame, com.sun.jna.ptr.IntByReference, avcodec.AVPacket)} instead
	 */
	@Mangling({"_Z21avcodec_decode_video2P14AVCodecContextP7AVFramePiP8AVPacket", "?avcodec_decode_video2@@YAHPAUAVCodecContext@@PAUAVFrame@@PAHPAUAVPacket@@@Z"}) 
	@Deprecated 
	int avcodec_decode_video2(AVCodecContext avctx, AVFrame picture, IntByReference got_picture_ptr, AVPacket avpkt);
	/**
	 * Decodes the video frame of size avpkt->size from avpkt->data into picture.<br>
	 * Some decoders may support multiple frames in a single AVPacket, such<br>
	 * decoders would then just decode the first frame.<br>
	 * * @warning The input buffer must be FF_INPUT_BUFFER_PADDING_SIZE larger than<br>
	 * the actual read bytes because some optimized bitstream readers read 32 or 64<br>
	 * bits at once and could read over the end.<br>
	 * * @warning The end of the input buffer buf should be set to 0 to ensure that<br>
	 * no overreading happens for damaged MPEG streams.<br>
	 * * @note You might have to align the input buffer avpkt->data.<br>
	 * The alignment requirements depend on the CPU: on some CPUs it isn't<br>
	 * necessary at all, on others it won't work at all if not aligned and on others<br>
	 * it will work but it will have an impact on performance.<br>
	 * * In practice, avpkt->data should have 4 byte alignment at minimum.<br>
	 * * @note Some codecs have a delay between input and output, these need to be<br>
	 * fed with avpkt->data=NULL, avpkt->size=0 at the end to return the remaining frames.<br>
	 * * @param avctx the codec context<br>
	 * @param[out] picture The AVFrame in which the decoded video frame will be stored.<br>
	 *             Use avcodec_alloc_frame to get an AVFrame, the codec will<br>
	 *             allocate memory for the actual bitmap.<br>
	 * @param[in] avpkt The input AVpacket containing the input buffer.<br>
	 *            You can create such packet with av_init_packet() and by then setting<br>
	 *            data and size, some decoders might in addition need other fields like<br>
	 *            flags&AV_PKT_FLAG_KEY. All decoders are designed to use the least<br>
	 *            fields possible.<br>
	 * @param[in,out] got_picture_ptr Zero if no frame could be decompressed, otherwise, it is nonzero.<br>
	 * @return On error a negative value is returned, otherwise the number of bytes<br>
	 * used or zero if no frame could be decompressed.<br>
	 * Original signature : <code>int avcodec_decode_video2(AVCodecContext*, AVFrame*, int*, AVPacket*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3490</i>
	 */
	@Mangling({"_Z21avcodec_decode_video2P14AVCodecContextP7AVFramePiP8AVPacket", "?avcodec_decode_video2@@YAHPAUAVCodecContext@@PAUAVFrame@@PAHPAUAVPacket@@@Z"}) 
	int avcodec_decode_video2(AVCodecContext avctx, AVFrame picture, IntBuffer got_picture_ptr, AVPacket avpkt);
	/**
	 * Decode a subtitle message. Return -1 if error, otherwise return the<br>
	 * number of bytes used. If no subtitle could be decompressed,<br>
	 * got_sub_ptr is zero. Otherwise, the subtitle is stored in *sub.<br>
	 * Original signature : <code>int avcodec_decode_subtitle(AVCodecContext*, AVSubtitle*, int*, const uint8_t*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3498</i><br>
	 * @deprecated use the safer methods {@link #avcodec_decode_subtitle(avcodec.AVCodecContext, avcodec.AVSubtitle, java.nio.IntBuffer, byte[], int)} and {@link #avcodec_decode_subtitle(avcodec.AVCodecContext, avcodec.AVSubtitle, com.sun.jna.ptr.IntByReference, com.sun.jna.Pointer, int)} instead
	 */
	@Mangling({"_Z23avcodec_decode_subtitleP14AVCodecContextP10AVSubtitlePiPK7uint8_ti", "?avcodec_decode_subtitle@@YAHPAUAVCodecContext@@PAUAVSubtitle@@PAHPA7uint8_tH@Z"}) 
	@Deprecated 
	int avcodec_decode_subtitle(AVCodecContext avctx, AVSubtitle sub, IntByReference got_sub_ptr, Pointer buf, int buf_size);
	/**
	 * Decode a subtitle message. Return -1 if error, otherwise return the<br>
	 * number of bytes used. If no subtitle could be decompressed,<br>
	 * got_sub_ptr is zero. Otherwise, the subtitle is stored in *sub.<br>
	 * Original signature : <code>int avcodec_decode_subtitle(AVCodecContext*, AVSubtitle*, int*, const uint8_t*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3498</i>
	 */
	@Mangling({"_Z23avcodec_decode_subtitleP14AVCodecContextP10AVSubtitlePiPK7uint8_ti", "?avcodec_decode_subtitle@@YAHPAUAVCodecContext@@PAUAVSubtitle@@PAHPA7uint8_tH@Z"}) 
	int avcodec_decode_subtitle(AVCodecContext avctx, AVSubtitle sub, IntBuffer got_sub_ptr, byte buf[], int buf_size);
	/**
	 * Decodes a subtitle message.<br>
	 * Returns a negative value on error, otherwise returns the number of bytes used.<br>
	 * If no subtitle could be decompressed, got_sub_ptr is zero.<br>
	 * Otherwise, the subtitle is stored in *sub.<br>
	 * * @param avctx the codec context<br>
	 * @param[out] sub The AVSubtitle in which the decoded subtitle will be stored.<br>
	 * @param[in,out] got_sub_ptr Zero if no subtitle could be decompressed, otherwise, it is nonzero.<br>
	 * @param[in] avpkt The input AVPacket containing the input buffer.<br>
	 * Original signature : <code>int avcodec_decode_subtitle2(AVCodecContext*, AVSubtitle*, int*, AVPacket*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3514</i><br>
	 * @deprecated use the safer methods {@link #avcodec_decode_subtitle2(avcodec.AVCodecContext, avcodec.AVSubtitle, java.nio.IntBuffer, avcodec.AVPacket)} and {@link #avcodec_decode_subtitle2(avcodec.AVCodecContext, avcodec.AVSubtitle, com.sun.jna.ptr.IntByReference, avcodec.AVPacket)} instead
	 */
	@Mangling({"_Z24avcodec_decode_subtitle2P14AVCodecContextP10AVSubtitlePiP8AVPacket", "?avcodec_decode_subtitle2@@YAHPAUAVCodecContext@@PAUAVSubtitle@@PAHPAUAVPacket@@@Z"}) 
	@Deprecated 
	int avcodec_decode_subtitle2(AVCodecContext avctx, AVSubtitle sub, IntByReference got_sub_ptr, AVPacket avpkt);
	/**
	 * Decodes a subtitle message.<br>
	 * Returns a negative value on error, otherwise returns the number of bytes used.<br>
	 * If no subtitle could be decompressed, got_sub_ptr is zero.<br>
	 * Otherwise, the subtitle is stored in *sub.<br>
	 * * @param avctx the codec context<br>
	 * @param[out] sub The AVSubtitle in which the decoded subtitle will be stored.<br>
	 * @param[in,out] got_sub_ptr Zero if no subtitle could be decompressed, otherwise, it is nonzero.<br>
	 * @param[in] avpkt The input AVPacket containing the input buffer.<br>
	 * Original signature : <code>int avcodec_decode_subtitle2(AVCodecContext*, AVSubtitle*, int*, AVPacket*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3514</i>
	 */
	@Mangling({"_Z24avcodec_decode_subtitle2P14AVCodecContextP10AVSubtitlePiP8AVPacket", "?avcodec_decode_subtitle2@@YAHPAUAVCodecContext@@PAUAVSubtitle@@PAHPAUAVPacket@@@Z"}) 
	int avcodec_decode_subtitle2(AVCodecContext avctx, AVSubtitle sub, IntBuffer got_sub_ptr, AVPacket avpkt);
	/**
	 * Original signature : <code>int avcodec_parse_frame(AVCodecContext*, uint8_t**, int*, uint8_t*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3517</i><br>
	 * @deprecated use the safer methods {@link #avcodec_parse_frame(avcodec.AVCodecContext, com.sun.jna.ptr.PointerByReference, java.nio.IntBuffer, java.nio.ByteBuffer, int)} and {@link #avcodec_parse_frame(avcodec.AVCodecContext, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.Pointer, int)} instead
	 */
	@Mangling({"_Z19avcodec_parse_frameP14AVCodecContextPP7uint8_tPiP7uint8_ti", "?avcodec_parse_frame@@YAHPAUAVCodecContext@@PAPA7uint8_tPAHPA7uint8_tH@Z"}) 
	@Deprecated 
	int avcodec_parse_frame(AVCodecContext avctx, PointerByReference pdata, IntByReference data_size_ptr, Pointer buf, int buf_size);
	/**
	 * Original signature : <code>int avcodec_parse_frame(AVCodecContext*, uint8_t**, int*, uint8_t*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3517</i>
	 */
	@Mangling({"_Z19avcodec_parse_frameP14AVCodecContextPP7uint8_tPiP7uint8_ti", "?avcodec_parse_frame@@YAHPAUAVCodecContext@@PAPA7uint8_tPAHPA7uint8_tH@Z"}) 
	int avcodec_parse_frame(AVCodecContext avctx, PointerByReference pdata, IntBuffer data_size_ptr, ByteBuffer buf, int buf_size);
	/**
	 * Encodes an audio frame from samples into buf.<br>
	 * * @note The output buffer should be at least FF_MIN_BUFFER_SIZE bytes large.<br>
	 * However, for PCM audio the user will know how much space is needed<br>
	 * because it depends on the value passed in buf_size as described<br>
	 * below. In that case a lower value can be used.<br>
	 * * @param avctx the codec context<br>
	 * @param[out] buf the output buffer<br>
	 * @param[in] buf_size the output buffer size<br>
	 * @param[in] samples the input buffer containing the samples<br>
	 * The number of samples read from this buffer is frame_size*channels,<br>
	 * both of which are defined in avctx.<br>
	 * For PCM audio the number of samples read from samples is equal to<br>
	 * buf_size * input_sample_size / output_sample_size.<br>
	 * @return On error a negative value is returned, on success zero or the number<br>
	 * of bytes used to encode the data read from the input buffer.<br>
	 * Original signature : <code>int avcodec_encode_audio(AVCodecContext*, uint8_t*, int, const short*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3540</i><br>
	 * @deprecated use the safer methods {@link #avcodec_encode_audio(avcodec.AVCodecContext, java.nio.ByteBuffer, int, short[])} and {@link #avcodec_encode_audio(avcodec.AVCodecContext, com.sun.jna.Pointer, int, com.sun.jna.ptr.ShortByReference)} instead
	 */
	@Mangling({"_Z20avcodec_encode_audioP14AVCodecContextP7uint8_tiPKi", "?avcodec_encode_audio@@YAHPAUAVCodecContext@@PA7uint8_tHPAH@Z"}) 
	@Deprecated 
	int avcodec_encode_audio(AVCodecContext avctx, Pointer buf, int buf_size, ShortByReference samples);
	/**
	 * Encodes an audio frame from samples into buf.<br>
	 * * @note The output buffer should be at least FF_MIN_BUFFER_SIZE bytes large.<br>
	 * However, for PCM audio the user will know how much space is needed<br>
	 * because it depends on the value passed in buf_size as described<br>
	 * below. In that case a lower value can be used.<br>
	 * * @param avctx the codec context<br>
	 * @param[out] buf the output buffer<br>
	 * @param[in] buf_size the output buffer size<br>
	 * @param[in] samples the input buffer containing the samples<br>
	 * The number of samples read from this buffer is frame_size*channels,<br>
	 * both of which are defined in avctx.<br>
	 * For PCM audio the number of samples read from samples is equal to<br>
	 * buf_size * input_sample_size / output_sample_size.<br>
	 * @return On error a negative value is returned, on success zero or the number<br>
	 * of bytes used to encode the data read from the input buffer.<br>
	 * Original signature : <code>int avcodec_encode_audio(AVCodecContext*, uint8_t*, int, const short*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3540</i>
	 */
	@Mangling({"_Z20avcodec_encode_audioP14AVCodecContextP7uint8_tiPKi", "?avcodec_encode_audio@@YAHPAUAVCodecContext@@PA7uint8_tHPAH@Z"}) 
	int avcodec_encode_audio(AVCodecContext avctx, ByteBuffer buf, int buf_size, short samples[]);
	/**
	 * Encodes a video frame from pict into buf.<br>
	 * The input picture should be<br>
	 * stored using a specific format, namely avctx.pix_fmt.<br>
	 * * @param avctx the codec context<br>
	 * @param[out] buf the output buffer for the bitstream of encoded frame<br>
	 * @param[in] buf_size the size of the output buffer in bytes<br>
	 * @param[in] pict the input picture to encode<br>
	 * @return On error a negative value is returned, on success zero or the number<br>
	 * of bytes used from the output buffer.<br>
	 * Original signature : <code>int avcodec_encode_video(AVCodecContext*, uint8_t*, int, const AVFrame*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3555</i><br>
	 * @deprecated use the safer methods {@link #avcodec_encode_video(avcodec.AVCodecContext, java.nio.ByteBuffer, int, avcodec.AVFrame)} and {@link #avcodec_encode_video(avcodec.AVCodecContext, com.sun.jna.Pointer, int, avcodec.AVFrame)} instead
	 */
	@Mangling({"_Z20avcodec_encode_videoP14AVCodecContextP7uint8_tiPK7AVFrame", "?avcodec_encode_video@@YAHPAUAVCodecContext@@PA7uint8_tHPAUAVFrame@@@Z"}) 
	@Deprecated 
	int avcodec_encode_video(AVCodecContext avctx, Pointer buf, int buf_size, AVFrame pict);
	/**
	 * Encodes a video frame from pict into buf.<br>
	 * The input picture should be<br>
	 * stored using a specific format, namely avctx.pix_fmt.<br>
	 * * @param avctx the codec context<br>
	 * @param[out] buf the output buffer for the bitstream of encoded frame<br>
	 * @param[in] buf_size the size of the output buffer in bytes<br>
	 * @param[in] pict the input picture to encode<br>
	 * @return On error a negative value is returned, on success zero or the number<br>
	 * of bytes used from the output buffer.<br>
	 * Original signature : <code>int avcodec_encode_video(AVCodecContext*, uint8_t*, int, const AVFrame*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3555</i>
	 */
	@Mangling({"_Z20avcodec_encode_videoP14AVCodecContextP7uint8_tiPK7AVFrame", "?avcodec_encode_video@@YAHPAUAVCodecContext@@PA7uint8_tHPAUAVFrame@@@Z"}) 
	int avcodec_encode_video(AVCodecContext avctx, ByteBuffer buf, int buf_size, AVFrame pict);
	/**
	 * Original signature : <code>int avcodec_encode_subtitle(AVCodecContext*, uint8_t*, int, const AVSubtitle*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3557</i><br>
	 * @deprecated use the safer methods {@link #avcodec_encode_subtitle(avcodec.AVCodecContext, java.nio.ByteBuffer, int, avcodec.AVSubtitle)} and {@link #avcodec_encode_subtitle(avcodec.AVCodecContext, com.sun.jna.Pointer, int, avcodec.AVSubtitle)} instead
	 */
	@Mangling({"_Z23avcodec_encode_subtitleP14AVCodecContextP7uint8_tiPK10AVSubtitle", "?avcodec_encode_subtitle@@YAHPAUAVCodecContext@@PA7uint8_tHPAUAVSubtitle@@@Z"}) 
	@Deprecated 
	int avcodec_encode_subtitle(AVCodecContext avctx, Pointer buf, int buf_size, AVSubtitle sub);
	/**
	 * Original signature : <code>int avcodec_encode_subtitle(AVCodecContext*, uint8_t*, int, const AVSubtitle*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3557</i>
	 */
	@Mangling({"_Z23avcodec_encode_subtitleP14AVCodecContextP7uint8_tiPK10AVSubtitle", "?avcodec_encode_subtitle@@YAHPAUAVCodecContext@@PA7uint8_tHPAUAVSubtitle@@@Z"}) 
	int avcodec_encode_subtitle(AVCodecContext avctx, ByteBuffer buf, int buf_size, AVSubtitle sub);
	/**
	 * Original signature : <code>int avcodec_close(AVCodecContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3560</i>
	 */
	@Mangling({"_Z13avcodec_closeP14AVCodecContext", "?avcodec_close@@YAHPAUAVCodecContext@@@Z"}) 
	int avcodec_close(AVCodecContext avctx);
	/**
	 * Register all the codecs, parsers and bitstream filters which were enabled at<br>
	 * configuration time. If you do not call this function you can select exactly<br>
	 * which formats you want to support, by using the individual registration<br>
	 * functions.<br>
	 * * @see avcodec_register<br>
	 * @see av_register_codec_parser<br>
	 * @see av_register_bitstream_filter<br>
	 * Original signature : <code>void avcodec_register_all()</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3572</i>
	 */
	@Mangling({"_Z20avcodec_register_allv", "?avcodec_register_all@@YAXXZ"}) 
	void avcodec_register_all();
	/**
	 * Flush buffers, should be called when seeking or when switching to a different stream.<br>
	 * Original signature : <code>void avcodec_flush_buffers(AVCodecContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3577</i>
	 */
	@Mangling({"_Z21avcodec_flush_buffersP14AVCodecContext", "?avcodec_flush_buffers@@YAXPAUAVCodecContext@@@Z"}) 
	void avcodec_flush_buffers(AVCodecContext avctx);
	/**
	 * Original signature : <code>void avcodec_default_free_buffers(AVCodecContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3579</i>
	 */
	@Mangling({"_Z28avcodec_default_free_buffersP14AVCodecContext", "?avcodec_default_free_buffers@@YAXPAUAVCodecContext@@@Z"}) 
	void avcodec_default_free_buffers(AVCodecContext s);
	/**
	 * Returns a single letter to describe the given picture type pict_type.<br>
	 * * @param[in] pict_type the picture type<br>
	 * @return A single character representing the picture type.<br>
	 * Original signature : <code>char av_get_pict_type_char(int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3589</i>
	 */
	@Mangling({"_Z21av_get_pict_type_chari", "?av_get_pict_type_char@@YADH@Z"}) 
	byte av_get_pict_type_char(int pict_type);
	/**
	 * Returns codec bits per sample.<br>
	 * * @param[in] codec_id the codec<br>
	 * @return Number of bits per sample or zero if unknown for the given codec.<br>
	 * Original signature : <code>int av_get_bits_per_sample(CodecID)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3597</i><br>
	 * @param codec_id @see CodecID
	 */
	@Mangling({"_Z22av_get_bits_per_sample7CodecID", "?av_get_bits_per_sample@@YAH7CodecID@Z"}) 
	int av_get_bits_per_sample(int codec_id);
	/**
	 * Returns sample format bits per sample.<br>
	 * * @param[in] sample_fmt the sample format<br>
	 * @return Number of bits per sample or zero if unknown for the given sample format.<br>
	 * Original signature : <code>int av_get_bits_per_sample_format(SampleFormat)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3605</i><br>
	 * @param sample_fmt @see SampleFormat
	 */
	@Mangling({"_Z29av_get_bits_per_sample_format12SampleFormat", "?av_get_bits_per_sample_format@@YAH12SampleFormat@Z"}) 
	int av_get_bits_per_sample_format(int sample_fmt);
	/**
	 * Original signature : <code>AVCodecParser* av_parser_next(AVCodecParser*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3744</i>
	 */
	@Mangling({"_Z14av_parser_nextP13AVCodecParser", "?av_parser_next@@YAPAUAVCodecParser@@PAUAVCodecParser@@@Z"}) 
	AVCodecParser av_parser_next(AVCodecParser c);
	/**
	 * Original signature : <code>void av_register_codec_parser(AVCodecParser*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3746</i>
	 */
	@Mangling({"_Z24av_register_codec_parserP13AVCodecParser", "?av_register_codec_parser@@YAXPAUAVCodecParser@@@Z"}) 
	void av_register_codec_parser(AVCodecParser parser);
	/**
	 * Original signature : <code>AVCodecParserContext* av_parser_init(int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3747</i>
	 */
	@Mangling({"_Z14av_parser_initi", "?av_parser_init@@YAPAUAVCodecParserContext@@H@Z"}) 
	AVCodecParserContext av_parser_init(int codec_id);
	/**
	 * Original signature : <code>int av_parser_parse(AVCodecParserContext*, AVCodecContext*, uint8_t**, int*, const uint8_t*, int, int64_t, int64_t)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3751</i><br>
	 * @deprecated use the safer methods {@link #av_parser_parse(avcodec.AVCodecParserContext, avcodec.AVCodecContext, com.sun.jna.ptr.PointerByReference, java.nio.IntBuffer, byte[], int, long, long)} and {@link #av_parser_parse(avcodec.AVCodecParserContext, avcodec.AVCodecContext, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.Pointer, int, long, long)} instead
	 */
	@Mangling({"_Z15av_parser_parseP20AVCodecParserContextP14AVCodecContextPP7uint8_tPiPK7uint8_ti7int64_t7int64_t", "?av_parser_parse@@YAHPAUAVCodecParserContext@@PAUAVCodecContext@@PAPA7uint8_tPAHPA7uint8_tH7int64_t7int64_t@Z"}) 
	@Deprecated 
	int av_parser_parse(AVCodecParserContext s, AVCodecContext avctx, PointerByReference poutbuf, IntByReference poutbuf_size, Pointer buf, int buf_size, long pts, long dts);
	/**
	 * Original signature : <code>int av_parser_parse(AVCodecParserContext*, AVCodecContext*, uint8_t**, int*, const uint8_t*, int, int64_t, int64_t)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3751</i>
	 */
	@Mangling({"_Z15av_parser_parseP20AVCodecParserContextP14AVCodecContextPP7uint8_tPiPK7uint8_ti7int64_t7int64_t", "?av_parser_parse@@YAHPAUAVCodecParserContext@@PAUAVCodecContext@@PAPA7uint8_tPAHPA7uint8_tH7int64_t7int64_t@Z"}) 
	int av_parser_parse(AVCodecParserContext s, AVCodecContext avctx, PointerByReference poutbuf, IntBuffer poutbuf_size, byte buf[], int buf_size, long pts, long dts);
	/**
	 * Parse a packet.<br>
	 * * @param s             parser context.<br>
	 * @param avctx         codec context.<br>
	 * @param poutbuf       set to pointer to parsed buffer or NULL if not yet finished.<br>
	 * @param poutbuf_size  set to size of parsed buffer or zero if not yet finished.<br>
	 * @param buf           input buffer.<br>
	 * @param buf_size      input length, to signal EOF, this should be 0 (so that the last frame can be output).<br>
	 * @param pts           input presentation timestamp.<br>
	 * @param dts           input decoding timestamp.<br>
	 * @param pos           input byte position in stream.<br>
	 * @return the number of bytes of the input bitstream used.<br>
	 * * Example:<br>
	 * @code<br>
	 *   while(in_len){<br>
	 *       len = av_parser_parse2(myparser, AVCodecContext, &data, &size,<br>
	 *                                        in_data, in_len,<br>
	 *                                        pts, dts, pos);<br>
	 *       in_data += len;<br>
	 *       in_len  -= len;<br>
	 * *       if(size)<br>
	 *          decode_frame(data, size);<br>
	 *   }<br>
	 * @endcode<br>
	 * Original signature : <code>int av_parser_parse2(AVCodecParserContext*, AVCodecContext*, uint8_t**, int*, const uint8_t*, int, int64_t, int64_t, int64_t)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3786</i><br>
	 * @deprecated use the safer methods {@link #av_parser_parse2(avcodec.AVCodecParserContext, avcodec.AVCodecContext, com.sun.jna.ptr.PointerByReference, java.nio.IntBuffer, byte[], int, long, long, long)} and {@link #av_parser_parse2(avcodec.AVCodecParserContext, avcodec.AVCodecContext, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.Pointer, int, long, long, long)} instead
	 */
	@Mangling({"_Z16av_parser_parse2P20AVCodecParserContextP14AVCodecContextPP7uint8_tPiPK7uint8_ti7int64_t7int64_t7int64_t", "?av_parser_parse2@@YAHPAUAVCodecParserContext@@PAUAVCodecContext@@PAPA7uint8_tPAHPA7uint8_tH7int64_t7int64_t7int64_t@Z"}) 
	@Deprecated 
	int av_parser_parse2(AVCodecParserContext s, AVCodecContext avctx, PointerByReference poutbuf, IntByReference poutbuf_size, Pointer buf, int buf_size, long pts, long dts, long pos);
	/**
	 * Parse a packet.<br>
	 * * @param s             parser context.<br>
	 * @param avctx         codec context.<br>
	 * @param poutbuf       set to pointer to parsed buffer or NULL if not yet finished.<br>
	 * @param poutbuf_size  set to size of parsed buffer or zero if not yet finished.<br>
	 * @param buf           input buffer.<br>
	 * @param buf_size      input length, to signal EOF, this should be 0 (so that the last frame can be output).<br>
	 * @param pts           input presentation timestamp.<br>
	 * @param dts           input decoding timestamp.<br>
	 * @param pos           input byte position in stream.<br>
	 * @return the number of bytes of the input bitstream used.<br>
	 * * Example:<br>
	 * @code<br>
	 *   while(in_len){<br>
	 *       len = av_parser_parse2(myparser, AVCodecContext, &data, &size,<br>
	 *                                        in_data, in_len,<br>
	 *                                        pts, dts, pos);<br>
	 *       in_data += len;<br>
	 *       in_len  -= len;<br>
	 * *       if(size)<br>
	 *          decode_frame(data, size);<br>
	 *   }<br>
	 * @endcode<br>
	 * Original signature : <code>int av_parser_parse2(AVCodecParserContext*, AVCodecContext*, uint8_t**, int*, const uint8_t*, int, int64_t, int64_t, int64_t)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3786</i>
	 */
	@Mangling({"_Z16av_parser_parse2P20AVCodecParserContextP14AVCodecContextPP7uint8_tPiPK7uint8_ti7int64_t7int64_t7int64_t", "?av_parser_parse2@@YAHPAUAVCodecParserContext@@PAUAVCodecContext@@PAPA7uint8_tPAHPA7uint8_tH7int64_t7int64_t7int64_t@Z"}) 
	int av_parser_parse2(AVCodecParserContext s, AVCodecContext avctx, PointerByReference poutbuf, IntBuffer poutbuf_size, byte buf[], int buf_size, long pts, long dts, long pos);
	/**
	 * Original signature : <code>int av_parser_change(AVCodecParserContext*, AVCodecContext*, uint8_t**, int*, const uint8_t*, int, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3793</i><br>
	 * @deprecated use the safer methods {@link #av_parser_change(avcodec.AVCodecParserContext, avcodec.AVCodecContext, com.sun.jna.ptr.PointerByReference, java.nio.IntBuffer, byte[], int, int)} and {@link #av_parser_change(avcodec.AVCodecParserContext, avcodec.AVCodecContext, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.Pointer, int, int)} instead
	 */
	@Mangling({"_Z16av_parser_changeP20AVCodecParserContextP14AVCodecContextPP7uint8_tPiPK7uint8_tii", "?av_parser_change@@YAHPAUAVCodecParserContext@@PAUAVCodecContext@@PAPA7uint8_tPAHPA7uint8_tHH@Z"}) 
	@Deprecated 
	int av_parser_change(AVCodecParserContext s, AVCodecContext avctx, PointerByReference poutbuf, IntByReference poutbuf_size, Pointer buf, int buf_size, int keyframe);
	/**
	 * Original signature : <code>int av_parser_change(AVCodecParserContext*, AVCodecContext*, uint8_t**, int*, const uint8_t*, int, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3793</i>
	 */
	@Mangling({"_Z16av_parser_changeP20AVCodecParserContextP14AVCodecContextPP7uint8_tPiPK7uint8_tii", "?av_parser_change@@YAHPAUAVCodecParserContext@@PAUAVCodecContext@@PAPA7uint8_tPAHPA7uint8_tHH@Z"}) 
	int av_parser_change(AVCodecParserContext s, AVCodecContext avctx, PointerByReference poutbuf, IntBuffer poutbuf_size, byte buf[], int buf_size, int keyframe);
	/**
	 * Original signature : <code>void av_parser_close(AVCodecParserContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3797</i>
	 */
	@Mangling({"_Z15av_parser_closeP20AVCodecParserContext", "?av_parser_close@@YAXPAUAVCodecParserContext@@@Z"}) 
	void av_parser_close(AVCodecParserContext s);
	/**
	 * Original signature : <code>void av_register_bitstream_filter(AVBitStreamFilter*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3819</i>
	 */
	@Mangling({"_Z28av_register_bitstream_filterP17AVBitStreamFilter", "?av_register_bitstream_filter@@YAXPAUAVBitStreamFilter@@@Z"}) 
	void av_register_bitstream_filter(AVBitStreamFilter bsf);
	/**
	 * Original signature : <code>AVBitStreamFilterContext* av_bitstream_filter_init(const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3820</i><br>
	 * @deprecated use the safer methods {@link #av_bitstream_filter_init(java.lang.String)} and {@link #av_bitstream_filter_init(com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z24av_bitstream_filter_initPKc", "?av_bitstream_filter_init@@YAPAUAVBitStreamFilterContext@@PAD@Z"}) 
	@Deprecated 
	AVBitStreamFilterContext av_bitstream_filter_init(Pointer name);
	/**
	 * Original signature : <code>AVBitStreamFilterContext* av_bitstream_filter_init(const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3820</i>
	 */
	@Mangling({"_Z24av_bitstream_filter_initPKc", "?av_bitstream_filter_init@@YAPAUAVBitStreamFilterContext@@PAD@Z"}) 
	AVBitStreamFilterContext av_bitstream_filter_init(String name);
	/**
	 * Original signature : <code>int av_bitstream_filter_filter(AVBitStreamFilterContext*, AVCodecContext*, const char*, uint8_t**, int*, const uint8_t*, int, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3821</i><br>
	 * @deprecated use the safer methods {@link #av_bitstream_filter_filter(avcodec.AVBitStreamFilterContext, avcodec.AVCodecContext, java.lang.String, com.sun.jna.ptr.PointerByReference, java.nio.IntBuffer, byte[], int, int)} and {@link #av_bitstream_filter_filter(avcodec.AVBitStreamFilterContext, avcodec.AVCodecContext, com.sun.jna.Pointer, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.Pointer, int, int)} instead
	 */
	@Mangling({"_Z26av_bitstream_filter_filterP24AVBitStreamFilterContextP14AVCodecContextPKcPP7uint8_tPiPK7uint8_tii", "?av_bitstream_filter_filter@@YAHPAUAVBitStreamFilterContext@@PAUAVCodecContext@@PADPAPA7uint8_tPAHPA7uint8_tHH@Z"}) 
	@Deprecated 
	int av_bitstream_filter_filter(AVBitStreamFilterContext bsfc, AVCodecContext avctx, Pointer args, PointerByReference poutbuf, IntByReference poutbuf_size, Pointer buf, int buf_size, int keyframe);
	/**
	 * Original signature : <code>int av_bitstream_filter_filter(AVBitStreamFilterContext*, AVCodecContext*, const char*, uint8_t**, int*, const uint8_t*, int, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3821</i>
	 */
	@Mangling({"_Z26av_bitstream_filter_filterP24AVBitStreamFilterContextP14AVCodecContextPKcPP7uint8_tPiPK7uint8_tii", "?av_bitstream_filter_filter@@YAHPAUAVBitStreamFilterContext@@PAUAVCodecContext@@PADPAPA7uint8_tPAHPA7uint8_tHH@Z"}) 
	int av_bitstream_filter_filter(AVBitStreamFilterContext bsfc, AVCodecContext avctx, String args, PointerByReference poutbuf, IntBuffer poutbuf_size, byte buf[], int buf_size, int keyframe);
	/**
	 * Original signature : <code>void av_bitstream_filter_close(AVBitStreamFilterContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3825</i>
	 */
	@Mangling({"_Z25av_bitstream_filter_closeP24AVBitStreamFilterContext", "?av_bitstream_filter_close@@YAXPAUAVBitStreamFilterContext@@@Z"}) 
	void av_bitstream_filter_close(AVBitStreamFilterContext bsf);
	/**
	 * Original signature : <code>AVBitStreamFilter* av_bitstream_filter_next(AVBitStreamFilter*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3827</i>
	 */
	@Mangling({"_Z24av_bitstream_filter_nextP17AVBitStreamFilter", "?av_bitstream_filter_next@@YAPAUAVBitStreamFilter@@PAUAVBitStreamFilter@@@Z"}) 
	AVBitStreamFilter av_bitstream_filter_next(AVBitStreamFilter f);
	/**
	 * Reallocates the given block if it is not large enough, otherwise it<br>
	 * does nothing.<br>
	 * * @see av_realloc<br>
	 * Original signature : <code>void* av_fast_realloc(void*, unsigned int*, unsigned int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3837</i><br>
	 * @deprecated use the safer methods {@link #av_fast_realloc(com.sun.jna.Pointer, java.nio.IntBuffer, int)} and {@link #av_fast_realloc(com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference, int)} instead
	 */
	@Mangling({"_Z15av_fast_reallocPvPjj", "?av_fast_realloc@@YAPAXPAXPAII@Z"}) 
	@Deprecated 
	Pointer av_fast_realloc(Pointer ptr, IntByReference size, int min_size);
	/**
	 * Reallocates the given block if it is not large enough, otherwise it<br>
	 * does nothing.<br>
	 * * @see av_realloc<br>
	 * Original signature : <code>void* av_fast_realloc(void*, unsigned int*, unsigned int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3837</i>
	 */
	@Mangling({"_Z15av_fast_reallocPvPjj", "?av_fast_realloc@@YAPAXPAXPAII@Z"}) 
	Pointer av_fast_realloc(Pointer ptr, IntBuffer size, int min_size);
	/**
	 * Allocates a buffer, reusing the given one if large enough.<br>
	 * * Contrary to av_fast_realloc the current buffer contents might not be<br>
	 * preserved and on error the old buffer is freed, thus no special<br>
	 * handling to avoid memleaks is necessary.<br>
	 * * @param ptr pointer to pointer to already allocated buffer, overwritten with pointer to new buffer<br>
	 * @param size size of the buffer *ptr points to<br>
	 * @param min_size minimum size of *ptr buffer after returning, *ptr will be NULL and<br>
	 *                 *size 0 if an error occurred.<br>
	 * Original signature : <code>void av_fast_malloc(void*, unsigned int*, unsigned int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3851</i><br>
	 * @deprecated use the safer methods {@link #av_fast_malloc(com.sun.jna.Pointer, java.nio.IntBuffer, int)} and {@link #av_fast_malloc(com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference, int)} instead
	 */
	@Mangling({"_Z14av_fast_mallocPvPjj", "?av_fast_malloc@@YAXPAXPAII@Z"}) 
	@Deprecated 
	void av_fast_malloc(Pointer ptr, IntByReference size, int min_size);
	/**
	 * Allocates a buffer, reusing the given one if large enough.<br>
	 * * Contrary to av_fast_realloc the current buffer contents might not be<br>
	 * preserved and on error the old buffer is freed, thus no special<br>
	 * handling to avoid memleaks is necessary.<br>
	 * * @param ptr pointer to pointer to already allocated buffer, overwritten with pointer to new buffer<br>
	 * @param size size of the buffer *ptr points to<br>
	 * @param min_size minimum size of *ptr buffer after returning, *ptr will be NULL and<br>
	 *                 *size 0 if an error occurred.<br>
	 * Original signature : <code>void av_fast_malloc(void*, unsigned int*, unsigned int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3851</i>
	 */
	@Mangling({"_Z14av_fast_mallocPvPjj", "?av_fast_malloc@@YAXPAXPAII@Z"}) 
	void av_fast_malloc(Pointer ptr, IntBuffer size, int min_size);
	/**
	 * Copy image 'src' to 'dst'.<br>
	 * Original signature : <code>void av_picture_copy(AVPicture*, const AVPicture*, PixelFormat, int, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3856</i><br>
	 * @param pix_fmt @see PixelFormat
	 */
	@Mangling({"_Z15av_picture_copyP9AVPicturePK9AVPicture11PixelFormatii", "?av_picture_copy@@YAXPAUAVPicture@@PAUAVPicture@@11PixelFormatHH@Z"}) 
	void av_picture_copy(AVPicture dst, AVPicture src, int pix_fmt, int width, int height);
	/**
	 * Crop image top and left side.<br>
	 * Original signature : <code>int av_picture_crop(AVPicture*, const AVPicture*, PixelFormat, int, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3862</i><br>
	 * @param pix_fmt @see PixelFormat
	 */
	@Mangling({"_Z15av_picture_cropP9AVPicturePK9AVPicture11PixelFormatii", "?av_picture_crop@@YAHPAUAVPicture@@PAUAVPicture@@11PixelFormatHH@Z"}) 
	int av_picture_crop(AVPicture dst, AVPicture src, int pix_fmt, int top_band, int left_band);
	/**
	 * Pad image.<br>
	 * Original signature : <code>int av_picture_pad(AVPicture*, const AVPicture*, int, int, PixelFormat, int, int, int, int, int*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3868</i><br>
	 * @deprecated use the safer methods {@link #av_picture_pad(avcodec.AVPicture, avcodec.AVPicture, int, int, int, int, int, int, int, java.nio.IntBuffer)} and {@link #av_picture_pad(avcodec.AVPicture, avcodec.AVPicture, int, int, int, int, int, int, int, com.sun.jna.ptr.IntByReference)} instead<br>
	 * @param pix_fmt @see PixelFormat
	 */
	@Mangling({"_Z14av_picture_padP9AVPicturePK9AVPictureii11PixelFormatiiiiPi", "?av_picture_pad@@YAHPAUAVPicture@@PAUAVPicture@@HH11PixelFormatHHHHPAH@Z"}) 
	@Deprecated 
	int av_picture_pad(AVPicture dst, AVPicture src, int height, int width, int pix_fmt, int padtop, int padbottom, int padleft, int padright, IntByReference color);
	/**
	 * Pad image.<br>
	 * Original signature : <code>int av_picture_pad(AVPicture*, const AVPicture*, int, int, PixelFormat, int, int, int, int, int*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3868</i><br>
	 * @param pix_fmt @see PixelFormat
	 */
	@Mangling({"_Z14av_picture_padP9AVPicturePK9AVPictureii11PixelFormatiiiiPi", "?av_picture_pad@@YAHPAUAVPicture@@PAUAVPicture@@HH11PixelFormatHHHHPAH@Z"}) 
	int av_picture_pad(AVPicture dst, AVPicture src, int height, int width, int pix_fmt, int padtop, int padbottom, int padleft, int padright, IntBuffer color);
	/**
	 * Encodes extradata length to a buffer. Used by xiph codecs.<br>
	 * * @param s buffer to write to; must be at least (v/255+1) bytes long<br>
	 * @param v size of extradata in bytes<br>
	 * @return number of bytes written to the buffer.<br>
	 * Original signature : <code>int av_xiphlacing(unsigned char*, unsigned int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3878</i><br>
	 * @deprecated use the safer methods {@link #av_xiphlacing(java.nio.ByteBuffer, int)} and {@link #av_xiphlacing(com.sun.jna.Pointer, int)} instead
	 */
	@Mangling({"_Z13av_xiphlacingPhj", "?av_xiphlacing@@YAIPAEI@Z"}) 
	@Deprecated 
	int av_xiphlacing(Pointer s, int v);
	/**
	 * Encodes extradata length to a buffer. Used by xiph codecs.<br>
	 * * @param s buffer to write to; must be at least (v/255+1) bytes long<br>
	 * @param v size of extradata in bytes<br>
	 * @return number of bytes written to the buffer.<br>
	 * Original signature : <code>int av_xiphlacing(unsigned char*, unsigned int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3878</i>
	 */
	@Mangling({"_Z13av_xiphlacingPhj", "?av_xiphlacing@@YAIPAEI@Z"}) 
	int av_xiphlacing(ByteBuffer s, int v);
	/**
	 * Parses str and put in width_ptr and height_ptr the detected values.<br>
	 * * @return 0 in case of a successful parsing, a negative value otherwise<br>
	 * @param[in] str the string to parse: it has to be a string in the format<br>
	 * <width>x<height> or a valid video frame size abbreviation.<br>
	 * @param[in,out] width_ptr pointer to the variable which will contain the detected<br>
	 * frame width value<br>
	 * @param[in,out] height_ptr pointer to the variable which will contain the detected<br>
	 * frame height value<br>
	 * Original signature : <code>int av_parse_video_frame_size(int*, int*, const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3891</i><br>
	 * @deprecated use the safer methods {@link #av_parse_video_frame_size(java.nio.IntBuffer, java.nio.IntBuffer, java.lang.String)} and {@link #av_parse_video_frame_size(com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z25av_parse_video_frame_sizePiPiPKc", "?av_parse_video_frame_size@@YAHPAHPAHPAD@Z"}) 
	@Deprecated 
	int av_parse_video_frame_size(IntByReference width_ptr, IntByReference height_ptr, Pointer str);
	/**
	 * Parses str and put in width_ptr and height_ptr the detected values.<br>
	 * * @return 0 in case of a successful parsing, a negative value otherwise<br>
	 * @param[in] str the string to parse: it has to be a string in the format<br>
	 * <width>x<height> or a valid video frame size abbreviation.<br>
	 * @param[in,out] width_ptr pointer to the variable which will contain the detected<br>
	 * frame width value<br>
	 * @param[in,out] height_ptr pointer to the variable which will contain the detected<br>
	 * frame height value<br>
	 * Original signature : <code>int av_parse_video_frame_size(int*, int*, const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3891</i>
	 */
	@Mangling({"_Z25av_parse_video_frame_sizePiPiPKc", "?av_parse_video_frame_size@@YAHPAHPAHPAD@Z"}) 
	int av_parse_video_frame_size(IntBuffer width_ptr, IntBuffer height_ptr, String str);
	/**
	 * Parses str and put in frame_rate the detected values.<br>
	 * * @return 0 in case of a successful parsing, a negative value otherwise<br>
	 * @param[in] str the string to parse: it has to be a string in the format<br>
	 * <frame_rate_num>/<frame_rate_den>, a float number or a valid video rate abbreviation<br>
	 * @param[in,out] frame_rate pointer to the AVRational which will contain the detected<br>
	 * frame rate<br>
	 * Original signature : <code>int av_parse_video_frame_rate(AVRational*, const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3902</i><br>
	 * @deprecated use the safer methods {@link #av_parse_video_frame_rate(avutil.AVRational, java.lang.String)} and {@link #av_parse_video_frame_rate(avutil.AVRational, com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z25av_parse_video_frame_rateP10AVRationalPKc", "?av_parse_video_frame_rate@@YAHPAUAVRational@@PAD@Z"}) 
	@Deprecated 
	int av_parse_video_frame_rate(AVRational frame_rate, Pointer str);
	/**
	 * Parses str and put in frame_rate the detected values.<br>
	 * * @return 0 in case of a successful parsing, a negative value otherwise<br>
	 * @param[in] str the string to parse: it has to be a string in the format<br>
	 * <frame_rate_num>/<frame_rate_den>, a float number or a valid video rate abbreviation<br>
	 * @param[in,out] frame_rate pointer to the AVRational which will contain the detected<br>
	 * frame rate<br>
	 * Original signature : <code>int av_parse_video_frame_rate(AVRational*, const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3902</i>
	 */
	@Mangling({"_Z25av_parse_video_frame_rateP10AVRationalPKc", "?av_parse_video_frame_rate@@YAHPAUAVRational@@PAD@Z"}) 
	int av_parse_video_frame_rate(AVRational frame_rate, String str);
	/**
	 * Logs a generic warning message about a missing feature. This function is<br>
	 * intended to be used internally by FFmpeg (libavcodec, libavformat, etc.)<br>
	 * only, and would normally not be used by applications.<br>
	 * @param[in] avc a pointer to an arbitrary struct of which the first field is<br>
	 * a pointer to an AVClass struct<br>
	 * @param[in] feature string containing the name of the missing feature<br>
	 * @param[in] want_sample indicates if samples are wanted which exhibit this feature.<br>
	 * If want_sample is non-zero, additional verbage will be added to the log<br>
	 * message which tells the user how to report samples to the development<br>
	 * mailing list.<br>
	 * Original signature : <code>void av_log_missing_feature(void*, const char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3916</i><br>
	 * @deprecated use the safer methods {@link #av_log_missing_feature(com.sun.jna.Pointer, java.lang.String, int)} and {@link #av_log_missing_feature(com.sun.jna.Pointer, com.sun.jna.Pointer, int)} instead
	 */
	@Mangling({"_Z22av_log_missing_featurePvPKci", "?av_log_missing_feature@@YAXPAXPADH@Z"}) 
	@Deprecated 
	void av_log_missing_feature(Pointer avc, Pointer feature, int want_sample);
	/**
	 * Logs a generic warning message about a missing feature. This function is<br>
	 * intended to be used internally by FFmpeg (libavcodec, libavformat, etc.)<br>
	 * only, and would normally not be used by applications.<br>
	 * @param[in] avc a pointer to an arbitrary struct of which the first field is<br>
	 * a pointer to an AVClass struct<br>
	 * @param[in] feature string containing the name of the missing feature<br>
	 * @param[in] want_sample indicates if samples are wanted which exhibit this feature.<br>
	 * If want_sample is non-zero, additional verbage will be added to the log<br>
	 * message which tells the user how to report samples to the development<br>
	 * mailing list.<br>
	 * Original signature : <code>void av_log_missing_feature(void*, const char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3916</i>
	 */
	@Mangling({"_Z22av_log_missing_featurePvPKci", "?av_log_missing_feature@@YAXPAXPADH@Z"}) 
	void av_log_missing_feature(Pointer avc, String feature, int want_sample);
	/**
	 * Logs a generic warning message asking for a sample. This function is<br>
	 * intended to be used internally by FFmpeg (libavcodec, libavformat, etc.)<br>
	 * only, and would normally not be used by applications.<br>
	 * @param[in] avc a pointer to an arbitrary struct of which the first field is<br>
	 * a pointer to an AVClass struct<br>
	 * @param[in] msg string containing an optional message, or NULL if no message<br>
	 * Original signature : <code>void av_log_ask_for_sample(void*, const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3926</i><br>
	 * @deprecated use the safer methods {@link #av_log_ask_for_sample(com.sun.jna.Pointer, java.lang.String)} and {@link #av_log_ask_for_sample(com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z21av_log_ask_for_samplePvPKc", "?av_log_ask_for_sample@@YAXPAXPAD@Z"}) 
	@Deprecated 
	void av_log_ask_for_sample(Pointer avc, Pointer msg);
	/**
	 * Logs a generic warning message asking for a sample. This function is<br>
	 * intended to be used internally by FFmpeg (libavcodec, libavformat, etc.)<br>
	 * only, and would normally not be used by applications.<br>
	 * @param[in] avc a pointer to an arbitrary struct of which the first field is<br>
	 * a pointer to an AVClass struct<br>
	 * @param[in] msg string containing an optional message, or NULL if no message<br>
	 * Original signature : <code>void av_log_ask_for_sample(void*, const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3926</i>
	 */
	@Mangling({"_Z21av_log_ask_for_samplePvPKc", "?av_log_ask_for_sample@@YAXPAXPAD@Z"}) 
	void av_log_ask_for_sample(Pointer avc, String msg);
	/**
	 * Registers the hardware accelerator hwaccel.<br>
	 * Original signature : <code>void av_register_hwaccel(AVHWAccel*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3931</i>
	 */
	@Mangling({"_Z19av_register_hwaccelP9AVHWAccel", "?av_register_hwaccel@@YAXPAUAVHWAccel@@@Z"}) 
	void av_register_hwaccel(AVHWAccel hwaccel);
	/**
	 * If hwaccel is NULL, returns the first registered hardware accelerator,<br>
	 * if hwaccel is non-NULL, returns the next registered hardware accelerator<br>
	 * after hwaccel, or NULL if hwaccel is the last one.<br>
	 * Original signature : <code>AVHWAccel* av_hwaccel_next(AVHWAccel*)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3938</i>
	 */
	@Mangling({"_Z15av_hwaccel_nextP9AVHWAccel", "?av_hwaccel_next@@YAPAUAVHWAccel@@PAUAVHWAccel@@@Z"}) 
	AVHWAccel av_hwaccel_next(AVHWAccel hwaccel);
	/**
	 * Register a user provided lock manager supporting the operations<br>
	 * specified by AVLockOp. mutex points to a (void *) where the<br>
	 * lockmgr should store/get a pointer to a user allocated mutex. It's<br>
	 * NULL upon AV_LOCK_CREATE and != NULL for all other ops.<br>
	 * * @param cb User defined callback. Note: FFmpeg may invoke calls to this<br>
	 *           callback during the call to av_lockmgr_register().<br>
	 *           Thus, the application must be prepared to handle that.<br>
	 *           If cb is set to NULL the lockmgr will be unregistered.<br>
	 *           Also note that during unregistration the previously registered<br>
	 *           lockmgr callback may also be invoked.<br>
	 * Original signature : <code>int av_lockmgr_register(av_lockmgr_register_arg1_cb_callback)</code><br>
	 * <i>native declaration : src/main/headers/libavcodec/avcodec.h:3964</i>
	 */
	@Mangling({"_Z19av_lockmgr_registerPFiPPv8AVLockOpE", "?av_lockmgr_register@@YAHPFHPAPAX8AVLockOp@E@Z"}) 
	int av_lockmgr_register(AvcodecLibrary.av_lockmgr_register_arg1_cb_callback arg1);
	/// Undefined type
	public static interface AVResampleContext {
		
	};
	/// Undefined type
	public static interface ReSampleContext {
		
	};
}
