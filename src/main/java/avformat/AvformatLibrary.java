package avformat;
import avcodec.AVPacket;
import avutil.AVRational.ByValue;
import com.ochafik.lang.jnaerator.runtime.LibraryExtractor;
import com.ochafik.lang.jnaerator.runtime.MangledFunctionMapper;
import com.ochafik.lang.jnaerator.runtime.Mangling;
import com.ochafik.lang.jnaerator.runtime.globals.GlobalStruct;
import com.sun.jna.Callback;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.NativeLong;
import com.sun.jna.Pointer;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.LongByReference;
import com.sun.jna.ptr.PointerByReference;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.nio.LongBuffer;
/**
 * JNA Wrapper for library <b>avformat</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.free.fr/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface AvformatLibrary extends Library {
	public static final String JNA_LIBRARY_NAME = LibraryExtractor.getLibraryPath("avformat", true, avformat.AvformatLibrary.class);
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(avformat.AvformatLibrary.JNA_LIBRARY_NAME, com.ochafik.lang.jnaerator.runtime.MangledFunctionMapper.DEFAULT_OPTIONS);
	public static final AvformatLibrary INSTANCE = (AvformatLibrary)Native.loadLibrary(avformat.AvformatLibrary.JNA_LIBRARY_NAME, avformat.AvformatLibrary.class, com.ochafik.lang.jnaerator.runtime.MangledFunctionMapper.DEFAULT_OPTIONS);
	/**
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:369</i><br>
	 * enum values
	 */
	public static interface AVStreamParseType {
		/// <i>native declaration : src/main/headers/libavformat/avformat.h:370</i>
		public static final int AVSTREAM_PARSE_NONE = 0;
		/**
		 * < full parsing and repack<br>
		 * <i>native declaration : src/main/headers/libavformat/avformat.h:371</i>
		 */
		public static final int AVSTREAM_PARSE_FULL = 1;
		/**
		 * < Only parse headers, do not repack.<br>
		 * <i>native declaration : src/main/headers/libavformat/avformat.h:372</i>
		 */
		public static final int AVSTREAM_PARSE_HEADERS = 2;
		/**
		 * < full parsing and interpolation of timestamps for frames not starting on a packet boundary<br>
		 * <i>native declaration : src/main/headers/libavformat/avformat.h:373</i>
		 */
		public static final int AVSTREAM_PARSE_TIMESTAMPS = 3;
	};
	/**
	 * Conversion Error : a.num<br>
	 * SKIPPED:<br>
	 * <i>native declaration : src/main/headers/libavutil/rational.h</i><br>
	 * const int64_t tmp = a.num * (int64_t)b.den - b.num * (int64_t)a.den;
	 */
	/// <i>native declaration : src/main/headers/libavformat/avio.h</i>
	public static final int URL_EOF = (-1);
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AVSEEK_FLAG_FRAME = 8;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AVFMT_NOFILE = 1;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int RAW_PACKET_BUFFER_SIZE = 2500000;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AV_DISPOSITION_DUB = 2;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AVFMT_GENERIC_INDEX = 256;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AVSEEK_FLAG_BACKWARD = 1;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AVFMT_FLAG_NONBLOCK = 4;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int FFM_PACKET_SIZE = 4096;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int MAX_STREAMS = 20;
	/// <i>native declaration : src/main/headers/libavformat/avio.h</i>
	public static final int AVSEEK_SIZE = 65536;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int LIBAVFORMAT_VERSION_MICRO = 2;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AV_METADATA_DONT_OVERWRITE = 16;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AVSEEK_FLAG_ANY = 4;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AV_DISPOSITION_LYRICS = 16;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AV_PROGRAM_RUNNING = 1;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AVSEEK_FLAG_BYTE = 2;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AVFMT_VARIABLE_FPS = 1024;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AVFMT_FLAG_NOFILLIN = 16;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final String LIBAVFORMAT_IDENT = "Lavf";
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AVFMT_FLAG_IGNIDX = 2;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int LIBAVFORMAT_VERSION_MAJOR = 52;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AVFMT_FLAG_RTP_HINT = 64;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AVFMT_INFINITEOUTPUTLOOP = 0;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int MAX_PROBE_PACKETS = 2500;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AVFMT_NOOUTPUTLOOP = -1;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AVFMT_NEEDNUMBER = 2;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AVFMT_FLAG_GENPTS = 1;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AVINDEX_KEYFRAME = 1;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AVFMTCTX_NOHEADER = 1;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AV_METADATA_IGNORE_SUFFIX = 2;
	/// <i>native declaration : src/main/headers/libavformat/avio.h</i>
	public static final int URL_RDWR = 2;
	/// <i>native declaration : src/main/headers/libavformat/avio.h</i>
	public static final int AVSEEK_FORCE = 131072;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AV_METADATA_DONT_STRDUP_VAL = 8;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AVFMT_SHOW_IDS = 8;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AVFMT_TS_DISCONT = 512;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AV_DISPOSITION_COMMENT = 8;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AVFMT_FLAG_NOPARSE = 32;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AV_METADATA_DONT_STRDUP_KEY = 4;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AVPROBE_SCORE_MAX = 100;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int FF_FDEBUG_TS = 1;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AV_DISPOSITION_KARAOKE = 32;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int LIBAVFORMAT_VERSION_MINOR = 64;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AV_DISPOSITION_ORIGINAL = 4;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AVFMT_FLAG_IGNDTS = 8;
	/// <i>native declaration : src/main/headers/libavformat/avio.h</i>
	public static final int URL_RDONLY = 0;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AVPROBE_PADDING_SIZE = 32;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AVFMT_NOTIMESTAMPS = 128;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AV_DISPOSITION_DEFAULT = 1;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AVFMT_NODIMENSIONS = 2048;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int MAX_REORDER_DELAY = 16;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AVFMT_RAWPICTURE = 32;
	/// <i>native declaration : src/main/headers/libavformat/avio.h</i>
	public static final int URL_WRONLY = 1;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AV_METADATA_MATCH_CASE = 1;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h</i>
	public static final int AVFMT_GLOBALHEADER = 64;
	/// <i>native declaration : src/main/headers/libavformat/avformat.h:1161</i>
	public interface av_gen_search_arg1_read_timestamp_callback extends Callback {
		long apply(AVFormatContext AVFormatContextPtr1, int int1, LongByReference int64_tPtr1, long int64_t1);
	};
	/// <i>native declaration : src/main/headers/libavformat/avio.h</i>
	public interface URLInterruptCB extends Callback {
		int apply();
	};
	/// <i>native declaration : src/main/headers/libavformat/avio.h:296</i>
	public interface init_put_byte_arg1_read_packet_callback extends Callback {
		int apply(Pointer opaque, Pointer buf, int buf_size);
	};
	/// <i>native declaration : src/main/headers/libavformat/avio.h:297</i>
	public interface init_put_byte_arg2_write_packet_callback extends Callback {
		int apply(Pointer opaque, Pointer buf, int buf_size);
	};
	/// <i>native declaration : src/main/headers/libavformat/avio.h:298</i>
	public interface init_put_byte_arg3_seek_callback extends Callback {
		long apply(Pointer opaque, long offset, int whence);
	};
	/// <i>native declaration : src/main/headers/libavformat/avio.h:304</i>
	public interface av_alloc_put_byte_arg1_read_packet_callback extends Callback {
		int apply(Pointer opaque, Pointer buf, int buf_size);
	};
	/// <i>native declaration : src/main/headers/libavformat/avio.h:305</i>
	public interface av_alloc_put_byte_arg2_write_packet_callback extends Callback {
		int apply(Pointer opaque, Pointer buf, int buf_size);
	};
	/// <i>native declaration : src/main/headers/libavformat/avio.h:306</i>
	public interface av_alloc_put_byte_arg3_seek_callback extends Callback {
		long apply(Pointer opaque, long offset, int whence);
	};
	/// <i>native declaration : src/main/headers/libavformat/avio.h:514</i>
	public interface init_checksum_arg1_update_checksum_callback extends Callback {
		NativeLong apply(NativeLong c, Pointer p, int len);
	};
	/**
	 * I return the LIBAVFORMAT_VERSION_INT constant.  You got<br>
	 * a fucking problem with that, douchebag?<br>
	 * Original signature : <code>avformat_version()</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:42</i>
	 */
	@Mangling({"_Z16avformat_versionv", "?avformat_version@@YAXXZ"}) 
	int avformat_version();
	/**
	 * Returns the libavformat build-time configuration.<br>
	 * Original signature : <code>char* avformat_configuration()</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:47</i>
	 */
	@Mangling({"_Z22avformat_configurationv", "?avformat_configuration@@YAQBDXZ"}) 
	String avformat_configuration();
	/**
	 * Returns the libavformat license.<br>
	 * Original signature : <code>char* avformat_license()</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:52</i>
	 */
	@Mangling({"_Z16avformat_licensev", "?avformat_license@@YAQBDXZ"}) 
	String avformat_license();
	/**
	 * Gets a metadata element with matching key.<br>
	 * @param prev Set to the previous matching element to find the next.<br>
	 *             If set to NULL the first matching element is returned.<br>
	 * @param flags Allows case as well as suffix-insensitive comparisons.<br>
	 * @return Found tag or NULL, changing key or value leads to undefined behavior.<br>
	 * Original signature : <code>AVMetadataTag* av_metadata_get(AVMetadata*, const char*, const AVMetadataTag*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:134</i><br>
	 * @deprecated use the safer methods {@link #av_metadata_get(com.sun.jna.Pointer, java.lang.String, avformat.AVMetadataTag, int)} and {@link #av_metadata_get(com.sun.jna.Pointer, com.sun.jna.Pointer, avformat.AVMetadataTag, int)} instead
	 */
	@Mangling({"_Z15av_metadata_getP10AVMetadataPKcPK13AVMetadataTagi", "?av_metadata_get@@YAPAUAVMetadataTag@@PA10AVMetadataPADPAUAVMetadataTag@@H@Z"}) 
	@Deprecated 
	AVMetadataTag av_metadata_get(Pointer m, Pointer key, AVMetadataTag prev, int flags);
	/**
	 * Gets a metadata element with matching key.<br>
	 * @param prev Set to the previous matching element to find the next.<br>
	 *             If set to NULL the first matching element is returned.<br>
	 * @param flags Allows case as well as suffix-insensitive comparisons.<br>
	 * @return Found tag or NULL, changing key or value leads to undefined behavior.<br>
	 * Original signature : <code>AVMetadataTag* av_metadata_get(AVMetadata*, const char*, const AVMetadataTag*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:134</i>
	 */
	@Mangling({"_Z15av_metadata_getP10AVMetadataPKcPK13AVMetadataTagi", "?av_metadata_get@@YAPAUAVMetadataTag@@PA10AVMetadataPADPAUAVMetadataTag@@H@Z"}) 
	AVMetadataTag av_metadata_get(Pointer m, String key, AVMetadataTag prev, int flags);
	/**
	 * Sets the given tag in m, overwriting an existing tag.<br>
	 * @param key tag key to add to m (will be av_strduped)<br>
	 * @param value tag value to add to m (will be av_strduped)<br>
	 * @return >= 0 on success otherwise an error code <0<br>
	 * @deprecated Use av_metadata_set2() instead.<br>
	 * Original signature : <code>int av_metadata_set(AVMetadata**, const char*, const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:145</i><br>
	 * @deprecated use the safer methods {@link #av_metadata_set(com.sun.jna.ptr.PointerByReference, java.lang.String, java.lang.String)} and {@link #av_metadata_set(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z15av_metadata_setPP10AVMetadataPKcPKc", "?av_metadata_set@@YAHPAPA10AVMetadataPADPAD@Z"}) 
	@Deprecated 
	int av_metadata_set(PointerByReference pm, Pointer key, Pointer value);
	/**
	 * Sets the given tag in m, overwriting an existing tag.<br>
	 * @param key tag key to add to m (will be av_strduped)<br>
	 * @param value tag value to add to m (will be av_strduped)<br>
	 * @return >= 0 on success otherwise an error code <0<br>
	 * @deprecated Use av_metadata_set2() instead.<br>
	 * Original signature : <code>int av_metadata_set(AVMetadata**, const char*, const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:145</i>
	 */
	@Mangling({"_Z15av_metadata_setPP10AVMetadataPKcPKc", "?av_metadata_set@@YAHPAPA10AVMetadataPADPAD@Z"}) 
	int av_metadata_set(PointerByReference pm, String key, String value);
	/**
	 * Sets the given tag in m, overwriting an existing tag.<br>
	 * @param key tag key to add to m (will be av_strduped depending on flags)<br>
	 * @param value tag value to add to m (will be av_strduped depending on flags)<br>
	 * @return >= 0 on success otherwise an error code <0<br>
	 * Original signature : <code>int av_metadata_set2(AVMetadata**, const char*, const char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:154</i><br>
	 * @deprecated use the safer methods {@link #av_metadata_set2(com.sun.jna.ptr.PointerByReference, java.lang.String, java.lang.String, int)} and {@link #av_metadata_set2(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, com.sun.jna.Pointer, int)} instead
	 */
	@Mangling({"_Z16av_metadata_set2PP10AVMetadataPKcPKci", "?av_metadata_set2@@YAHPAPA10AVMetadataPADPADH@Z"}) 
	@Deprecated 
	int av_metadata_set2(PointerByReference pm, Pointer key, Pointer value, int flags);
	/**
	 * Sets the given tag in m, overwriting an existing tag.<br>
	 * @param key tag key to add to m (will be av_strduped depending on flags)<br>
	 * @param value tag value to add to m (will be av_strduped depending on flags)<br>
	 * @return >= 0 on success otherwise an error code <0<br>
	 * Original signature : <code>int av_metadata_set2(AVMetadata**, const char*, const char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:154</i>
	 */
	@Mangling({"_Z16av_metadata_set2PP10AVMetadataPKcPKci", "?av_metadata_set2@@YAHPAPA10AVMetadataPADPADH@Z"}) 
	int av_metadata_set2(PointerByReference pm, String key, String value, int flags);
	/**
	 * Converts all the metadata sets from ctx according to the source and<br>
	 * destination conversion tables. If one of the tables is NULL, then<br>
	 * tags are converted to/from ffmpeg generic tag names.<br>
	 * @param d_conv destination tags format conversion table<br>
	 * @param s_conv source tags format conversion table<br>
	 * Original signature : <code>void av_metadata_conv(AVFormatContext*, const AVMetadataConv*, const AVMetadataConv*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:163</i>
	 */
	@Mangling({"_Z16av_metadata_convP15AVFormatContextPK14AVMetadataConvPK14AVMetadataConv", "?av_metadata_conv@@YAXPAUAVFormatContext@@PA14AVMetadataConvPA14AVMetadataConv@Z"}) 
	void av_metadata_conv(AVFormatContext ctx, Pointer d_conv, Pointer s_conv);
	/**
	 * Frees all the memory allocated for an AVMetadata struct.<br>
	 * Original signature : <code>void av_metadata_free(AVMetadata**)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:169</i>
	 */
	@Mangling({"_Z16av_metadata_freePP10AVMetadata", "?av_metadata_free@@YAXPAPA10AVMetadata@Z"}) 
	void av_metadata_free(PointerByReference m);
	/**
	 * Allocates and reads the payload of a packet and initializes its<br>
	 * fields with default values.<br>
	 * * @param pkt packet<br>
	 * @param size desired payload size<br>
	 * @return >0 (read size) if OK, AVERROR_xxx otherwise<br>
	 * Original signature : <code>int av_get_packet(ByteIOContext*, AVPacket*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:183</i>
	 */
	@Mangling({"_Z13av_get_packetP13ByteIOContextP8AVPacketi", "?av_get_packet@@YAHPAUByteIOContext@@PAUAVPacket@@H@Z"}) 
	int av_get_packet(ByteIOContext s, AVPacket pkt, int size);
	/**
	 * If f is NULL, returns the first registered input format,<br>
	 * if f is non-NULL, returns the next registered input format after f<br>
	 * or NULL if f is the last one.<br>
	 * Original signature : <code>AVInputFormat* av_iformat_next(AVInputFormat*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:755</i>
	 */
	@Mangling({"_Z15av_iformat_nextP13AVInputFormat", "?av_iformat_next@@YAPAUAVInputFormat@@PAUAVInputFormat@@@Z"}) 
	AVInputFormat av_iformat_next(AVInputFormat f);
	/**
	 * If f is NULL, returns the first registered output format,<br>
	 * if f is non-NULL, returns the next registered output format after f<br>
	 * or NULL if f is the last one.<br>
	 * Original signature : <code>AVOutputFormat* av_oformat_next(AVOutputFormat*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:762</i>
	 */
	@Mangling({"_Z15av_oformat_nextP14AVOutputFormat", "?av_oformat_next@@YAPAUAVOutputFormat@@PAUAVOutputFormat@@@Z"}) 
	AVOutputFormat av_oformat_next(AVOutputFormat f);
	/**
	 * Original signature : <code>CodecID av_guess_image2_codec(const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:764</i><br>
	 * @deprecated use the safer methods {@link #av_guess_image2_codec(java.lang.String)} and {@link #av_guess_image2_codec(com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z21av_guess_image2_codecPKc", "?av_guess_image2_codec@@YA7CodecIDPAD@Z"}) 
	@Deprecated 
	/**
	 * @see avcodec.AvcodecLibrary#CodecID
	 */int av_guess_image2_codec(Pointer filename);
	/**
	 * Original signature : <code>CodecID av_guess_image2_codec(const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:764</i>
	 */
	@Mangling({"_Z21av_guess_image2_codecPKc", "?av_guess_image2_codec@@YA7CodecIDPAD@Z"}) 
	/**
	 * @see avcodec.AvcodecLibrary#CodecID
	 */int av_guess_image2_codec(String filename);
	/**
	 * utils.c<br>
	 * Original signature : <code>void av_register_input_format(AVInputFormat*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:770</i>
	 */
	@Mangling({"_Z24av_register_input_formatP13AVInputFormat", "?av_register_input_format@@YAXPAUAVInputFormat@@@Z"}) 
	void av_register_input_format(AVInputFormat format);
	/**
	 * Original signature : <code>void av_register_output_format(AVOutputFormat*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:771</i>
	 */
	@Mangling({"_Z25av_register_output_formatP14AVOutputFormat", "?av_register_output_format@@YAXPAUAVOutputFormat@@@Z"}) 
	void av_register_output_format(AVOutputFormat format);
	/**
	 * Original signature : <code>AVOutputFormat* guess_stream_format(const char*, const char*, const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:773</i><br>
	 * @deprecated use the safer methods {@link #guess_stream_format(java.lang.String, java.lang.String, java.lang.String)} and {@link #guess_stream_format(com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z19guess_stream_formatPKcPKcPKc", "?guess_stream_format@@YAPAUAVOutputFormat@@PADPADPAD@Z"}) 
	@Deprecated 
	AVOutputFormat guess_stream_format(Pointer short_name, Pointer filename, Pointer mime_type);
	/**
	 * Original signature : <code>AVOutputFormat* guess_stream_format(const char*, const char*, const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:773</i>
	 */
	@Mangling({"_Z19guess_stream_formatPKcPKcPKc", "?guess_stream_format@@YAPAUAVOutputFormat@@PADPADPAD@Z"}) 
	AVOutputFormat guess_stream_format(String short_name, String filename, String mime_type);
	/**
	 * @deprecated Use av_guess_format() instead.<br>
	 * Original signature : <code>AVOutputFormat* guess_format(const char*, const char*, const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:780</i><br>
	 * @deprecated use the safer methods {@link #guess_format(java.lang.String, java.lang.String, java.lang.String)} and {@link #guess_format(com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z12guess_formatPKcPKcPKc", "?guess_format@@YAPAUAVOutputFormat@@PADPADPAD@Z"}) 
	@Deprecated 
	AVOutputFormat guess_format(Pointer short_name, Pointer filename, Pointer mime_type);
	/**
	 * @deprecated Use av_guess_format() instead.<br>
	 * Original signature : <code>AVOutputFormat* guess_format(const char*, const char*, const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:780</i>
	 */
	@Mangling({"_Z12guess_formatPKcPKcPKc", "?guess_format@@YAPAUAVOutputFormat@@PADPADPAD@Z"}) 
	AVOutputFormat guess_format(String short_name, String filename, String mime_type);
	/**
	 * Returns the output format in the list of registered output formats<br>
	 * which best matches the provided parameters, or returns NULL if<br>
	 * there is no match.<br>
	 * * @param short_name if non-NULL checks if short_name matches with the<br>
	 * names of the registered formats<br>
	 * @param filename if non-NULL checks if filename terminates with the<br>
	 * extensions of the registered formats<br>
	 * @param mime_type if non-NULL checks if mime_type matches with the<br>
	 * MIME type of the registered formats<br>
	 * Original signature : <code>AVOutputFormat* av_guess_format(const char*, const char*, const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:797</i><br>
	 * @deprecated use the safer methods {@link #av_guess_format(java.lang.String, java.lang.String, java.lang.String)} and {@link #av_guess_format(com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z15av_guess_formatPKcPKcPKc", "?av_guess_format@@YAPAUAVOutputFormat@@PADPADPAD@Z"}) 
	@Deprecated 
	AVOutputFormat av_guess_format(Pointer short_name, Pointer filename, Pointer mime_type);
	/**
	 * Returns the output format in the list of registered output formats<br>
	 * which best matches the provided parameters, or returns NULL if<br>
	 * there is no match.<br>
	 * * @param short_name if non-NULL checks if short_name matches with the<br>
	 * names of the registered formats<br>
	 * @param filename if non-NULL checks if filename terminates with the<br>
	 * extensions of the registered formats<br>
	 * @param mime_type if non-NULL checks if mime_type matches with the<br>
	 * MIME type of the registered formats<br>
	 * Original signature : <code>AVOutputFormat* av_guess_format(const char*, const char*, const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:797</i>
	 */
	@Mangling({"_Z15av_guess_formatPKcPKcPKc", "?av_guess_format@@YAPAUAVOutputFormat@@PADPADPAD@Z"}) 
	AVOutputFormat av_guess_format(String short_name, String filename, String mime_type);
	/**
	 * Guesses the codec ID based upon muxer and filename.<br>
	 * Original signature : <code>CodecID av_guess_codec(AVOutputFormat*, const char*, const char*, const char*, AVMediaType)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:804</i><br>
	 * @deprecated use the safer methods {@link #av_guess_codec(avformat.AVOutputFormat, java.lang.String, java.lang.String, java.lang.String, int)} and {@link #av_guess_codec(avformat.AVOutputFormat, com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.Pointer, int)} instead<br>
	 * @param type @see avcodec.AvcodecLibrary#AVMediaType
	 */
	@Mangling({"_Z14av_guess_codecP14AVOutputFormatPKcPKcPKc11AVMediaType", "?av_guess_codec@@YA7CodecIDPAUAVOutputFormat@@PADPADPAD11AVMediaType@Z"}) 
	@Deprecated 
	/**
	 * @see avcodec.AvcodecLibrary#CodecID
	 */int av_guess_codec(AVOutputFormat fmt, Pointer short_name, Pointer filename, Pointer mime_type, int type);
	/**
	 * Guesses the codec ID based upon muxer and filename.<br>
	 * Original signature : <code>CodecID av_guess_codec(AVOutputFormat*, const char*, const char*, const char*, AVMediaType)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:804</i><br>
	 * @param type @see avcodec.AvcodecLibrary#AVMediaType
	 */
	@Mangling({"_Z14av_guess_codecP14AVOutputFormatPKcPKcPKc11AVMediaType", "?av_guess_codec@@YA7CodecIDPAUAVOutputFormat@@PADPADPAD11AVMediaType@Z"}) 
	/**
	 * @see avcodec.AvcodecLibrary#CodecID
	 */int av_guess_codec(AVOutputFormat fmt, String short_name, String filename, String mime_type, int type);
	/**
	 * Sends a nice hexadecimal dump of a buffer to the specified file stream.<br>
	 * * @param f The file stream pointer where the dump should be sent to.<br>
	 * @param buf buffer<br>
	 * @param size buffer size<br>
	 * * @see av_hex_dump_log, av_pkt_dump, av_pkt_dump_log<br>
	 * Original signature : <code>void av_hex_dump(FILE*, uint8_t*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:817</i><br>
	 * @deprecated use the safer methods {@link #av_hex_dump(com.sun.jna.Pointer, java.nio.ByteBuffer, int)} and {@link #av_hex_dump(com.sun.jna.Pointer, com.sun.jna.Pointer, int)} instead
	 */
	@Mangling({"_Z11av_hex_dumpP8_IO_FILEP7uint8_ti", "?av_hex_dump@@YAXPA8_IO_FILEPA7uint8_tH@Z"}) 
	@Deprecated 
	void av_hex_dump(Pointer f, Pointer buf, int size);
	/**
	 * Sends a nice hexadecimal dump of a buffer to the specified file stream.<br>
	 * * @param f The file stream pointer where the dump should be sent to.<br>
	 * @param buf buffer<br>
	 * @param size buffer size<br>
	 * * @see av_hex_dump_log, av_pkt_dump, av_pkt_dump_log<br>
	 * Original signature : <code>void av_hex_dump(FILE*, uint8_t*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:817</i>
	 */
	@Mangling({"_Z11av_hex_dumpP8_IO_FILEP7uint8_ti", "?av_hex_dump@@YAXPA8_IO_FILEPA7uint8_tH@Z"}) 
	void av_hex_dump(Pointer f, ByteBuffer buf, int size);
	/**
	 * Sends a nice hexadecimal dump of a buffer to the log.<br>
	 * * @param avcl A pointer to an arbitrary struct of which the first field is a<br>
	 * pointer to an AVClass struct.<br>
	 * @param level The importance level of the message, lower values signifying<br>
	 * higher importance.<br>
	 * @param buf buffer<br>
	 * @param size buffer size<br>
	 * * @see av_hex_dump, av_pkt_dump, av_pkt_dump_log<br>
	 * Original signature : <code>void av_hex_dump_log(void*, int, uint8_t*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:831</i><br>
	 * @deprecated use the safer methods {@link #av_hex_dump_log(com.sun.jna.Pointer, int, java.nio.ByteBuffer, int)} and {@link #av_hex_dump_log(com.sun.jna.Pointer, int, com.sun.jna.Pointer, int)} instead
	 */
	@Mangling({"_Z15av_hex_dump_logPviP7uint8_ti", "?av_hex_dump_log@@YAXPAXHPA7uint8_tH@Z"}) 
	@Deprecated 
	void av_hex_dump_log(Pointer avcl, int level, Pointer buf, int size);
	/**
	 * Sends a nice hexadecimal dump of a buffer to the log.<br>
	 * * @param avcl A pointer to an arbitrary struct of which the first field is a<br>
	 * pointer to an AVClass struct.<br>
	 * @param level The importance level of the message, lower values signifying<br>
	 * higher importance.<br>
	 * @param buf buffer<br>
	 * @param size buffer size<br>
	 * * @see av_hex_dump, av_pkt_dump, av_pkt_dump_log<br>
	 * Original signature : <code>void av_hex_dump_log(void*, int, uint8_t*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:831</i>
	 */
	@Mangling({"_Z15av_hex_dump_logPviP7uint8_ti", "?av_hex_dump_log@@YAXPAXHPA7uint8_tH@Z"}) 
	void av_hex_dump_log(Pointer avcl, int level, ByteBuffer buf, int size);
	/**
	 * Sends a nice dump of a packet to the specified file stream.<br>
	 * * @param f The file stream pointer where the dump should be sent to.<br>
	 * @param pkt packet to dump<br>
	 * @param dump_payload True if the payload must be displayed, too.<br>
	 * Original signature : <code>void av_pkt_dump(FILE*, AVPacket*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:840</i>
	 */
	@Mangling({"_Z11av_pkt_dumpP8_IO_FILEP8AVPacketi", "?av_pkt_dump@@YAXPA8_IO_FILEPAUAVPacket@@H@Z"}) 
	void av_pkt_dump(Pointer f, AVPacket pkt, int dump_payload);
	/**
	 * Sends a nice dump of a packet to the log.<br>
	 * * @param avcl A pointer to an arbitrary struct of which the first field is a<br>
	 * pointer to an AVClass struct.<br>
	 * @param level The importance level of the message, lower values signifying<br>
	 * higher importance.<br>
	 * @param pkt packet to dump<br>
	 * @param dump_payload True if the payload must be displayed, too.<br>
	 * Original signature : <code>void av_pkt_dump_log(void*, int, AVPacket*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:852</i>
	 */
	@Mangling({"_Z15av_pkt_dump_logPviP8AVPacketi", "?av_pkt_dump_log@@YAXPAXHPAUAVPacket@@H@Z"}) 
	void av_pkt_dump_log(Pointer avcl, int level, AVPacket pkt, int dump_payload);
	/**
	 * Initializes libavformat and registers all the muxers, demuxers and<br>
	 * protocols. If you do not call this function, then you can select<br>
	 * exactly which formats you want to support.<br>
	 * * @see av_register_input_format()<br>
	 * @see av_register_output_format()<br>
	 * @see av_register_protocol()<br>
	 * Original signature : <code>void av_register_all()</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:863</i>
	 */
	@Mangling({"_Z15av_register_allv", "?av_register_all@@YAXXZ"}) 
	void av_register_all();
	/**
	 * codec tag <-> codec id<br>
	 * Original signature : <code>CodecID av_codec_get_id(const AVCodecTag**, unsigned int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:866</i><br>
	 * @deprecated use the safer methods {@link #av_codec_get_id(com.sun.jna.Pointer[], int)} and {@link #av_codec_get_id(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Mangling({"_Z15av_codec_get_idKPP10AVCodecTagj", "?av_codec_get_id@@YA7CodecIDQBPA10AVCodecTagI@Z"}) 
	@Deprecated 
	/**
	 * @see avcodec.AvcodecLibrary#CodecID
	 */int av_codec_get_id(PointerByReference tags, int tag);
	/**
	 * codec tag <-> codec id<br>
	 * Original signature : <code>CodecID av_codec_get_id(const AVCodecTag**, unsigned int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:866</i>
	 */
	@Mangling({"_Z15av_codec_get_idKPP10AVCodecTagj", "?av_codec_get_id@@YA7CodecIDQBPA10AVCodecTagI@Z"}) 
	/**
	 * @see avcodec.AvcodecLibrary#CodecID
	 */int av_codec_get_id(Pointer tags[], int tag);
	/**
	 * Original signature : <code>int av_codec_get_tag(const AVCodecTag**, CodecID)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:867</i><br>
	 * @deprecated use the safer methods {@link #av_codec_get_tag(com.sun.jna.Pointer[], int)} and {@link #av_codec_get_tag(com.sun.jna.ptr.PointerByReference, int)} instead<br>
	 * @param id @see avcodec.AvcodecLibrary#CodecID
	 */
	@Mangling({"_Z16av_codec_get_tagKPP10AVCodecTag7CodecID", "?av_codec_get_tag@@YAIQBPA10AVCodecTag7CodecID@Z"}) 
	@Deprecated 
	int av_codec_get_tag(PointerByReference tags, int id);
	/**
	 * Original signature : <code>int av_codec_get_tag(const AVCodecTag**, CodecID)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:867</i><br>
	 * @param id @see avcodec.AvcodecLibrary#CodecID
	 */
	@Mangling({"_Z16av_codec_get_tagKPP10AVCodecTag7CodecID", "?av_codec_get_tag@@YAIQBPA10AVCodecTag7CodecID@Z"}) 
	int av_codec_get_tag(Pointer tags[], int id);
	/**
	 * Finds AVInputFormat based on the short name of the input format.<br>
	 * Original signature : <code>AVInputFormat* av_find_input_format(const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:874</i><br>
	 * @deprecated use the safer methods {@link #av_find_input_format(java.lang.String)} and {@link #av_find_input_format(com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z20av_find_input_formatPKc", "?av_find_input_format@@YAPAUAVInputFormat@@PAD@Z"}) 
	@Deprecated 
	AVInputFormat av_find_input_format(Pointer short_name);
	/**
	 * Finds AVInputFormat based on the short name of the input format.<br>
	 * Original signature : <code>AVInputFormat* av_find_input_format(const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:874</i>
	 */
	@Mangling({"_Z20av_find_input_formatPKc", "?av_find_input_format@@YAPAUAVInputFormat@@PAD@Z"}) 
	AVInputFormat av_find_input_format(String short_name);
	/**
	 * Guesses the file format.<br>
	 * * @param is_opened Whether the file is already opened; determines whether<br>
	 *                  demuxers with or without AVFMT_NOFILE are probed.<br>
	 * Original signature : <code>AVInputFormat* av_probe_input_format(AVProbeData*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:882</i>
	 */
	@Mangling({"_Z21av_probe_input_formatP11AVProbeDatai", "?av_probe_input_format@@YAPAUAVInputFormat@@PAUAVProbeData@@H@Z"}) 
	AVInputFormat av_probe_input_format(AVProbeData pd, int is_opened);
	/**
	 * Guesses the file format.<br>
	 * * @param is_opened Whether the file is already opened; determines whether<br>
	 *                  demuxers with or without AVFMT_NOFILE are probed.<br>
	 * @param score_max A probe score larger that this is required to accept a<br>
	 *                  detection, the variable is set to the actual detection<br>
	 *                  score afterwards.<br>
	 *                  If the score is <= AVPROBE_SCORE_MAX / 4 it is recommended<br>
	 *                  to retry with a larger probe buffer.<br>
	 * Original signature : <code>AVInputFormat* av_probe_input_format2(AVProbeData*, int, int*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:895</i><br>
	 * @deprecated use the safer methods {@link #av_probe_input_format2(avformat.AVProbeData, int, java.nio.IntBuffer)} and {@link #av_probe_input_format2(avformat.AVProbeData, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Mangling({"_Z22av_probe_input_format2P11AVProbeDataiPi", "?av_probe_input_format2@@YAPAUAVInputFormat@@PAUAVProbeData@@HPAH@Z"}) 
	@Deprecated 
	AVInputFormat av_probe_input_format2(AVProbeData pd, int is_opened, IntByReference score_max);
	/**
	 * Guesses the file format.<br>
	 * * @param is_opened Whether the file is already opened; determines whether<br>
	 *                  demuxers with or without AVFMT_NOFILE are probed.<br>
	 * @param score_max A probe score larger that this is required to accept a<br>
	 *                  detection, the variable is set to the actual detection<br>
	 *                  score afterwards.<br>
	 *                  If the score is <= AVPROBE_SCORE_MAX / 4 it is recommended<br>
	 *                  to retry with a larger probe buffer.<br>
	 * Original signature : <code>AVInputFormat* av_probe_input_format2(AVProbeData*, int, int*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:895</i>
	 */
	@Mangling({"_Z22av_probe_input_format2P11AVProbeDataiPi", "?av_probe_input_format2@@YAPAUAVInputFormat@@PAUAVProbeData@@HPAH@Z"}) 
	AVInputFormat av_probe_input_format2(AVProbeData pd, int is_opened, IntBuffer score_max);
	/**
	 * Allocates all the structures needed to read an input stream.<br>
	 *        This does not open the needed codecs for decoding the stream[s].<br>
	 * Original signature : <code>int av_open_input_stream(AVFormatContext**, ByteIOContext*, const char*, AVInputFormat*, AVFormatParameters*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:901</i><br>
	 * @deprecated use the safer methods {@link #av_open_input_stream(avformat.AVFormatContext.ByReference[], avformat.ByteIOContext, java.lang.String, avformat.AVInputFormat, avformat.AVFormatParameters)} and {@link #av_open_input_stream(avformat.AVFormatContext.ByReference[], avformat.ByteIOContext, com.sun.jna.Pointer, avformat.AVInputFormat, avformat.AVFormatParameters)} instead
	 */
	@Mangling({"_Z20av_open_input_streamPP15AVFormatContextP13ByteIOContextPKcP13AVInputFormatP18AVFormatParameters", "?av_open_input_stream@@YAHPAPAUAVFormatContext@@PAUByteIOContext@@PADPAUAVInputFormat@@PAUAVFormatParameters@@@Z"}) 
	@Deprecated 
	int av_open_input_stream(PointerByReference ic_ptr, ByteIOContext pb, Pointer filename, AVInputFormat fmt, AVFormatParameters ap);
	/**
	 * Allocates all the structures needed to read an input stream.<br>
	 *        This does not open the needed codecs for decoding the stream[s].<br>
	 * Original signature : <code>int av_open_input_stream(AVFormatContext**, ByteIOContext*, const char*, AVInputFormat*, AVFormatParameters*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:901</i>
	 */
	@Mangling({"_Z20av_open_input_streamPP15AVFormatContextP13ByteIOContextPKcP13AVInputFormatP18AVFormatParameters", "?av_open_input_stream@@YAHPAPAUAVFormatContext@@PAUByteIOContext@@PADPAUAVInputFormat@@PAUAVFormatParameters@@@Z"}) 
	int av_open_input_stream(AVFormatContext.ByReference ic_ptr[], ByteIOContext pb, String filename, AVInputFormat fmt, AVFormatParameters ap);
	/**
	 * Allocates all the structures needed to read an input stream.<br>
	 *        This does not open the needed codecs for decoding the stream[s].<br>
	 * Original signature : <code>int av_open_input_stream(AVFormatContext**, ByteIOContext*, const char*, AVInputFormat*, AVFormatParameters*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:901</i>
	 */
	@Mangling({"_Z20av_open_input_streamPP15AVFormatContextP13ByteIOContextPKcP13AVInputFormatP18AVFormatParameters", "?av_open_input_stream@@YAHPAPAUAVFormatContext@@PAUByteIOContext@@PADPAUAVInputFormat@@PAUAVFormatParameters@@@Z"}) 
	int av_open_input_stream(AVFormatContext.ByReference ic_ptr[], ByteIOContext pb, Pointer filename, AVInputFormat fmt, AVFormatParameters ap);
	/**
	 * Opens a media file as input. The codecs are not opened. Only the file<br>
	 * header (if present) is read.<br>
	 * * @param ic_ptr The opened media file handle is put here.<br>
	 * @param filename filename to open<br>
	 * @param fmt If non-NULL, force the file format to use.<br>
	 * @param buf_size optional buffer size (zero if default is OK)<br>
	 * @param ap Additional parameters needed when opening the file<br>
	 *           (NULL if default).<br>
	 * @return 0 if OK, AVERROR_xxx otherwise<br>
	 * Original signature : <code>int av_open_input_file(AVFormatContext**, const char*, AVInputFormat*, int, AVFormatParameters*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:917</i><br>
	 * @deprecated use the safer methods {@link #av_open_input_file(avformat.AVFormatContext.ByReference[], java.lang.String, avformat.AVInputFormat, int, avformat.AVFormatParameters)} and {@link #av_open_input_file(avformat.AVFormatContext.ByReference[], com.sun.jna.Pointer, avformat.AVInputFormat, int, avformat.AVFormatParameters)} instead
	 */
	@Mangling({"_Z18av_open_input_filePP15AVFormatContextPKcP13AVInputFormatiP18AVFormatParameters", "?av_open_input_file@@YAHPAPAUAVFormatContext@@PADPAUAVInputFormat@@HPAUAVFormatParameters@@@Z"}) 
	@Deprecated 
	int av_open_input_file(PointerByReference ic_ptr, Pointer filename, AVInputFormat fmt, int buf_size, AVFormatParameters ap);
	/**
	 * Opens a media file as input. The codecs are not opened. Only the file<br>
	 * header (if present) is read.<br>
	 * * @param ic_ptr The opened media file handle is put here.<br>
	 * @param filename filename to open<br>
	 * @param fmt If non-NULL, force the file format to use.<br>
	 * @param buf_size optional buffer size (zero if default is OK)<br>
	 * @param ap Additional parameters needed when opening the file<br>
	 *           (NULL if default).<br>
	 * @return 0 if OK, AVERROR_xxx otherwise<br>
	 * Original signature : <code>int av_open_input_file(AVFormatContext**, const char*, AVInputFormat*, int, AVFormatParameters*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:917</i>
	 */
	@Mangling({"_Z18av_open_input_filePP15AVFormatContextPKcP13AVInputFormatiP18AVFormatParameters", "?av_open_input_file@@YAHPAPAUAVFormatContext@@PADPAUAVInputFormat@@HPAUAVFormatParameters@@@Z"}) 
	int av_open_input_file(AVFormatContext.ByReference ic_ptr[], String filename, AVInputFormat fmt, int buf_size, AVFormatParameters ap);
	/**
	 * Opens a media file as input. The codecs are not opened. Only the file<br>
	 * header (if present) is read.<br>
	 * * @param ic_ptr The opened media file handle is put here.<br>
	 * @param filename filename to open<br>
	 * @param fmt If non-NULL, force the file format to use.<br>
	 * @param buf_size optional buffer size (zero if default is OK)<br>
	 * @param ap Additional parameters needed when opening the file<br>
	 *           (NULL if default).<br>
	 * @return 0 if OK, AVERROR_xxx otherwise<br>
	 * Original signature : <code>int av_open_input_file(AVFormatContext**, const char*, AVInputFormat*, int, AVFormatParameters*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:917</i>
	 */
	@Mangling({"_Z18av_open_input_filePP15AVFormatContextPKcP13AVInputFormatiP18AVFormatParameters", "?av_open_input_file@@YAHPAPAUAVFormatContext@@PADPAUAVInputFormat@@HPAUAVFormatParameters@@@Z"}) 
	int av_open_input_file(AVFormatContext.ByReference ic_ptr[], Pointer filename, AVInputFormat fmt, int buf_size, AVFormatParameters ap);
	/**
	 * @deprecated Use avformat_alloc_context() instead.<br>
	 * Original signature : <code>AVFormatContext* av_alloc_format_context()</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:926</i>
	 */
	@Mangling({"_Z23av_alloc_format_contextv", "?av_alloc_format_context@@YAPAUAVFormatContext@@XZ"}) 
	AVFormatContext av_alloc_format_context();
	/**
	 * Allocates an AVFormatContext.<br>
	 * Can be freed with av_free() but do not forget to free everything you<br>
	 * explicitly allocated as well!<br>
	 * Original signature : <code>AVFormatContext* avformat_alloc_context()</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:934</i>
	 */
	@Mangling({"_Z22avformat_alloc_contextv", "?avformat_alloc_context@@YAPAUAVFormatContext@@XZ"}) 
	AVFormatContext avformat_alloc_context();
	/**
	 * Reads packets of a media file to get stream information. This<br>
	 * is useful for file formats with no headers such as MPEG. This<br>
	 * function also computes the real framerate in case of MPEG-2 repeat<br>
	 * frame mode.<br>
	 * The logical file position is not changed by this function;<br>
	 * examined packets may be buffered for later processing.<br>
	 * * @param ic media file handle<br>
	 * @return >=0 if OK, AVERROR_xxx on error<br>
	 * @todo Let the user decide somehow what information is needed so that<br>
	 *       we do not waste time getting stuff the user does not need.<br>
	 * Original signature : <code>int av_find_stream_info(AVFormatContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:949</i>
	 */
	@Mangling({"_Z19av_find_stream_infoP15AVFormatContext", "?av_find_stream_info@@YAHPAUAVFormatContext@@@Z"}) 
	int av_find_stream_info(AVFormatContext ic);
	/**
	 * Reads a transport packet from a media file.<br>
	 * * This function is obsolete and should never be used.<br>
	 * Use av_read_frame() instead.<br>
	 * * @param s media file handle<br>
	 * @param pkt is filled<br>
	 * @return 0 if OK, AVERROR_xxx on error<br>
	 * Original signature : <code>int av_read_packet(AVFormatContext*, AVPacket*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:961</i>
	 */
	@Mangling({"_Z14av_read_packetP15AVFormatContextP8AVPacket", "?av_read_packet@@YAHPAUAVFormatContext@@PAUAVPacket@@@Z"}) 
	int av_read_packet(AVFormatContext s, AVPacket pkt);
	/**
	 * Returns the next frame of a stream.<br>
	 * * The returned packet is valid<br>
	 * until the next av_read_frame() or until av_close_input_file() and<br>
	 * must be freed with av_free_packet. For video, the packet contains<br>
	 * exactly one frame. For audio, it contains an integer number of<br>
	 * frames if each frame has a known fixed size (e.g. PCM or ADPCM<br>
	 * data). If the audio frames have a variable size (e.g. MPEG audio),<br>
	 * then it contains one frame.<br>
	 * * pkt->pts, pkt->dts and pkt->duration are always set to correct<br>
	 * values in AVStream.time_base units (and guessed if the format cannot<br>
	 * provide them). pkt->pts can be AV_NOPTS_VALUE if the video format<br>
	 * has B-frames, so it is better to rely on pkt->dts if you do not<br>
	 * decompress the payload.<br>
	 * * @return 0 if OK, < 0 on error or end of file<br>
	 * Original signature : <code>int av_read_frame(AVFormatContext*, AVPacket*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:982</i>
	 */
	@Mangling({"_Z13av_read_frameP15AVFormatContextP8AVPacket", "?av_read_frame@@YAHPAUAVFormatContext@@PAUAVPacket@@@Z"}) 
	int av_read_frame(AVFormatContext s, AVPacket pkt);
	/**
	 * Seeks to the keyframe at timestamp.<br>
	 * 'timestamp' in 'stream_index'.<br>
	 * @param stream_index If stream_index is (-1), a default<br>
	 * stream is selected, and timestamp is automatically converted<br>
	 * from AV_TIME_BASE units to the stream specific time_base.<br>
	 * @param timestamp Timestamp in AVStream.time_base units<br>
	 *        or, if no stream is specified, in AV_TIME_BASE units.<br>
	 * @param flags flags which select direction and seeking mode<br>
	 * @return >= 0 on success<br>
	 * Original signature : <code>int av_seek_frame(AVFormatContext*, int, int64_t, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:995</i>
	 */
	@Mangling({"_Z13av_seek_frameP15AVFormatContexti7int64_ti", "?av_seek_frame@@YAHPAUAVFormatContext@@H7int64_tH@Z"}) 
	int av_seek_frame(AVFormatContext s, int stream_index, long timestamp, int flags);
	/**
	 * Seeks to timestamp ts.<br>
	 * Seeking will be done so that the point from which all active streams<br>
	 * can be presented successfully will be closest to ts and within min/max_ts.<br>
	 * Active streams are all streams that have AVStream.discard < AVDISCARD_ALL.<br>
	 * * If flags contain AVSEEK_FLAG_BYTE, then all timestamps are in bytes and<br>
	 * are the file position (this may not be supported by all demuxers).<br>
	 * If flags contain AVSEEK_FLAG_FRAME, then all timestamps are in frames<br>
	 * in the stream with stream_index (this may not be supported by all demuxers).<br>
	 * Otherwise all timestamps are in units of the stream selected by stream_index<br>
	 * or if stream_index is -1, in AV_TIME_BASE units.<br>
	 * If flags contain AVSEEK_FLAG_ANY, then non-keyframes are treated as<br>
	 * keyframes (this may not be supported by all demuxers).<br>
	 * * @param stream_index index of the stream which is used as time base reference<br>
	 * @param min_ts smallest acceptable timestamp<br>
	 * @param ts target timestamp<br>
	 * @param max_ts largest acceptable timestamp<br>
	 * @param flags flags<br>
	 * @return >=0 on success, error code otherwise<br>
	 * * @NOTE This is part of the new seek API which is still under construction.<br>
	 *       Thus do not use this yet. It may change at any time, do not expect<br>
	 *       ABI compatibility yet!<br>
	 * Original signature : <code>int avformat_seek_file(AVFormatContext*, int, int64_t, int64_t, int64_t, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1024</i>
	 */
	@Mangling({"_Z18avformat_seek_fileP15AVFormatContexti7int64_t7int64_t7int64_ti", "?avformat_seek_file@@YAHPAUAVFormatContext@@H7int64_t7int64_t7int64_tH@Z"}) 
	int avformat_seek_file(AVFormatContext s, int stream_index, long min_ts, long ts, long max_ts, int flags);
	/**
	 * Starts playing a network-based stream (e.g. RTSP stream) at the<br>
	 * current position.<br>
	 * Original signature : <code>int av_read_play(AVFormatContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1030</i>
	 */
	@Mangling({"_Z12av_read_playP15AVFormatContext", "?av_read_play@@YAHPAUAVFormatContext@@@Z"}) 
	int av_read_play(AVFormatContext s);
	/**
	 * Pauses a network-based stream (e.g. RTSP stream).<br>
	 * * Use av_read_play() to resume it.<br>
	 * Original signature : <code>int av_read_pause(AVFormatContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1037</i>
	 */
	@Mangling({"_Z13av_read_pauseP15AVFormatContext", "?av_read_pause@@YAHPAUAVFormatContext@@@Z"}) 
	int av_read_pause(AVFormatContext s);
	/**
	 * Frees a AVFormatContext allocated by av_open_input_stream.<br>
	 * @param s context to free<br>
	 * Original signature : <code>void av_close_input_stream(AVFormatContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1043</i>
	 */
	@Mangling({"_Z21av_close_input_streamP15AVFormatContext", "?av_close_input_stream@@YAXPAUAVFormatContext@@@Z"}) 
	void av_close_input_stream(AVFormatContext s);
	/**
	 * Closes a media file (but not its codecs).<br>
	 * * @param s media file handle<br>
	 * Original signature : <code>void av_close_input_file(AVFormatContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1050</i>
	 */
	@Mangling({"_Z19av_close_input_fileP15AVFormatContext", "?av_close_input_file@@YAXPAUAVFormatContext@@@Z"}) 
	void av_close_input_file(AVFormatContext s);
	/**
	 * Adds a new stream to a media file.<br>
	 * * Can only be called in the read_header() function. If the flag<br>
	 * AVFMTCTX_NOHEADER is in the format context, then new streams<br>
	 * can be added in read_packet too.<br>
	 * * @param s media file handle<br>
	 * @param id file-format-dependent stream ID<br>
	 * Original signature : <code>AVStream* av_new_stream(AVFormatContext*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1062</i>
	 */
	@Mangling({"_Z13av_new_streamP15AVFormatContexti", "?av_new_stream@@YAPAUAVStream@@PAUAVFormatContext@@H@Z"}) 
	AVStream av_new_stream(AVFormatContext s, int id);
	/**
	 * Original signature : <code>AVProgram* av_new_program(AVFormatContext*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1063</i>
	 */
	@Mangling({"_Z14av_new_programP15AVFormatContexti", "?av_new_program@@YAPAUAVProgram@@PAUAVFormatContext@@H@Z"}) 
	AVProgram av_new_program(AVFormatContext s, int id);
	/**
	 * Adds a new chapter.<br>
	 * This function is NOT part of the public API<br>
	 * and should ONLY be used by demuxers.<br>
	 * * @param s media file handle<br>
	 * @param id unique ID for this chapter<br>
	 * @param start chapter start time in time_base units<br>
	 * @param end chapter end time in time_base units<br>
	 * @param title chapter title<br>
	 * * @return AVChapter or NULL on error<br>
	 * Original signature : <code>AVChapter* ff_new_chapter(AVFormatContext*, int, AVRational, int64_t, int64_t, const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1078</i><br>
	 * @deprecated use the safer methods {@link #ff_new_chapter(avformat.AVFormatContext, int, avutil.AVRational.ByValue, long, long, java.lang.String)} and {@link #ff_new_chapter(avformat.AVFormatContext, int, avutil.AVRational.ByValue, long, long, com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z14ff_new_chapterP15AVFormatContexti10AVRational7int64_t7int64_tPKc", "?ff_new_chapter@@YAPAUAVChapter@@PAUAVFormatContext@@HUAVRational@@7int64_t7int64_tPAD@Z"}) 
	@Deprecated 
	AVChapter ff_new_chapter(AVFormatContext s, int id, ByValue time_base, long start, long end, Pointer title);
	/**
	 * Adds a new chapter.<br>
	 * This function is NOT part of the public API<br>
	 * and should ONLY be used by demuxers.<br>
	 * * @param s media file handle<br>
	 * @param id unique ID for this chapter<br>
	 * @param start chapter start time in time_base units<br>
	 * @param end chapter end time in time_base units<br>
	 * @param title chapter title<br>
	 * * @return AVChapter or NULL on error<br>
	 * Original signature : <code>AVChapter* ff_new_chapter(AVFormatContext*, int, AVRational, int64_t, int64_t, const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1078</i>
	 */
	@Mangling({"_Z14ff_new_chapterP15AVFormatContexti10AVRational7int64_t7int64_tPKc", "?ff_new_chapter@@YAPAUAVChapter@@PAUAVFormatContext@@HUAVRational@@7int64_t7int64_tPAD@Z"}) 
	AVChapter ff_new_chapter(AVFormatContext s, int id, ByValue time_base, long start, long end, String title);
	/**
	 * Sets the pts for a given stream.<br>
	 * * @param s stream<br>
	 * @param pts_wrap_bits number of bits effectively used by the pts<br>
	 *        (used for wrap control, 33 is the value for MPEG)<br>
	 * @param pts_num numerator to convert to seconds (MPEG: 1)<br>
	 * @param pts_den denominator to convert to seconds (MPEG: 90000)<br>
	 * Original signature : <code>void av_set_pts_info(AVStream*, int, unsigned int, unsigned int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1090</i>
	 */
	@Mangling({"_Z15av_set_pts_infoP8AVStreamijj", "?av_set_pts_info@@YAXPAUAVStream@@HII@Z"}) 
	void av_set_pts_info(AVStream s, int pts_wrap_bits, int pts_num, int pts_den);
	/**
	 * Original signature : <code>int av_find_default_stream_index(AVFormatContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1098</i>
	 */
	@Mangling({"_Z28av_find_default_stream_indexP15AVFormatContext", "?av_find_default_stream_index@@YAHPAUAVFormatContext@@@Z"}) 
	int av_find_default_stream_index(AVFormatContext s);
	/**
	 * Gets the index for a specific timestamp.<br>
	 * @param flags if AVSEEK_FLAG_BACKWARD then the returned index will correspond<br>
	 *                 to the timestamp which is <= the requested one, if backward<br>
	 *                 is 0, then it will be >=<br>
	 *              if AVSEEK_FLAG_ANY seek to any frame, only keyframes otherwise<br>
	 * @return < 0 if no such timestamp could be found<br>
	 * Original signature : <code>int av_index_search_timestamp(AVStream*, int64_t, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1108</i>
	 */
	@Mangling({"_Z25av_index_search_timestampP8AVStream7int64_ti", "?av_index_search_timestamp@@YAHPAUAVStream@@7int64_tH@Z"}) 
	int av_index_search_timestamp(AVStream st, long timestamp, int flags);
	/**
	 * Ensures the index uses less memory than the maximum specified in<br>
	 * AVFormatContext.max_index_size by discarding entries if it grows<br>
	 * too large.<br>
	 * This function is not part of the public API and should only be called<br>
	 * by demuxers.<br>
	 * Original signature : <code>void ff_reduce_index(AVFormatContext*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1117</i>
	 */
	@Mangling({"_Z15ff_reduce_indexP15AVFormatContexti", "?ff_reduce_index@@YAXPAUAVFormatContext@@H@Z"}) 
	void ff_reduce_index(AVFormatContext s, int stream_index);
	/**
	 * Adds an index entry into a sorted list. Updates the entry if the list<br>
	 * already contains it.<br>
	 * * @param timestamp timestamp in the time base of the given stream<br>
	 * Original signature : <code>int av_add_index_entry(AVStream*, int64_t, int64_t, int, int, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1125</i>
	 */
	@Mangling({"_Z18av_add_index_entryP8AVStream7int64_t7int64_tiii", "?av_add_index_entry@@YAHPAUAVStream@@7int64_t7int64_tHHH@Z"}) 
	int av_add_index_entry(AVStream st, long pos, long timestamp, int size, int distance, int flags);
	/**
	 * Does a binary search using av_index_search_timestamp() and<br>
	 * AVCodec.read_timestamp().<br>
	 * This is not supposed to be called directly by a user application,<br>
	 * but by demuxers.<br>
	 * @param target_ts target timestamp in the time base of the given stream<br>
	 * @param stream_index stream number<br>
	 * Original signature : <code>int av_seek_frame_binary(AVFormatContext*, int, int64_t, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1136</i>
	 */
	@Mangling({"_Z20av_seek_frame_binaryP15AVFormatContexti7int64_ti", "?av_seek_frame_binary@@YAHPAUAVFormatContext@@H7int64_tH@Z"}) 
	int av_seek_frame_binary(AVFormatContext s, int stream_index, long target_ts, int flags);
	/**
	 * Updates cur_dts of all streams based on the given timestamp and AVStream.<br>
	 * * Stream ref_st unchanged, others set cur_dts in their native time base.<br>
	 * Only needed for timestamp wrapping or if (dts not set and pts!=dts).<br>
	 * @param timestamp new dts expressed in time_base of param ref_st<br>
	 * @param ref_st reference stream giving time_base of param timestamp<br>
	 * Original signature : <code>void av_update_cur_dts(AVFormatContext*, AVStream*, int64_t)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1147</i>
	 */
	@Mangling({"_Z17av_update_cur_dtsP15AVFormatContextP8AVStream7int64_t", "?av_update_cur_dts@@YAXPAUAVFormatContext@@PAUAVStream@@7int64_t@Z"}) 
	void av_update_cur_dts(AVFormatContext s, AVStream ref_st, long timestamp);
	/**
	 * Does a binary search using read_timestamp().<br>
	 * This is not supposed to be called directly by a user application,<br>
	 * but by demuxers.<br>
	 * @param target_ts target timestamp in the time base of the given stream<br>
	 * @param stream_index stream number<br>
	 * Original signature : <code>int64_t av_gen_search(AVFormatContext*, int, int64_t, int64_t, int64_t, int64_t, int64_t, int64_t, int, int64_t*, av_gen_search_arg1_read_timestamp_callback)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1156</i><br>
	 * @deprecated use the safer methods {@link #av_gen_search(avformat.AVFormatContext, int, long, long, long, long, long, long, int, java.nio.LongBuffer, avformat.AvformatLibrary.av_gen_search_arg1_read_timestamp_callback)} and {@link #av_gen_search(avformat.AVFormatContext, int, long, long, long, long, long, long, int, com.sun.jna.ptr.LongByReference, avformat.AvformatLibrary.av_gen_search_arg1_read_timestamp_callback)} instead
	 */
	@Mangling({"_Z13av_gen_searchP15AVFormatContexti7int64_t7int64_t7int64_t7int64_t7int64_t7int64_tiP7int64_tPF7int64_tP15AVFormatContextiP7int64_t7int64_tE", "?av_gen_search@@YA7int64_tPAUAVFormatContext@@H7int64_t7int64_t7int64_t7int64_t7int64_t7int64_tHPA7int64_tPF7int64_tPAUAVFormatContext@@HPA7int64_t7int64_t@E@Z"}) 
	@Deprecated 
	long av_gen_search(AVFormatContext s, int stream_index, long target_ts, long pos_min, long pos_max, long pos_limit, long ts_min, long ts_max, int flags, LongByReference ts_ret, AvformatLibrary.av_gen_search_arg1_read_timestamp_callback arg1);
	/**
	 * Does a binary search using read_timestamp().<br>
	 * This is not supposed to be called directly by a user application,<br>
	 * but by demuxers.<br>
	 * @param target_ts target timestamp in the time base of the given stream<br>
	 * @param stream_index stream number<br>
	 * Original signature : <code>int64_t av_gen_search(AVFormatContext*, int, int64_t, int64_t, int64_t, int64_t, int64_t, int64_t, int, int64_t*, av_gen_search_arg1_read_timestamp_callback)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1156</i>
	 */
	@Mangling({"_Z13av_gen_searchP15AVFormatContexti7int64_t7int64_t7int64_t7int64_t7int64_t7int64_tiP7int64_tPF7int64_tP15AVFormatContextiP7int64_t7int64_tE", "?av_gen_search@@YA7int64_tPAUAVFormatContext@@H7int64_t7int64_t7int64_t7int64_t7int64_t7int64_tHPA7int64_tPF7int64_tPAUAVFormatContext@@HPA7int64_t7int64_t@E@Z"}) 
	long av_gen_search(AVFormatContext s, int stream_index, long target_ts, long pos_min, long pos_max, long pos_limit, long ts_min, long ts_max, int flags, LongBuffer ts_ret, AvformatLibrary.av_gen_search_arg1_read_timestamp_callback arg1);
	/**
	 * media file output<br>
	 * Original signature : <code>int av_set_parameters(AVFormatContext*, AVFormatParameters*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1164</i>
	 */
	@Mangling({"_Z17av_set_parametersP15AVFormatContextP18AVFormatParameters", "?av_set_parameters@@YAHPAUAVFormatContext@@PAUAVFormatParameters@@@Z"}) 
	int av_set_parameters(AVFormatContext s, AVFormatParameters ap);
	/**
	 * Allocates the stream private data and writes the stream header to an<br>
	 * output media file.<br>
	 * * @param s media file handle<br>
	 * @return 0 if OK, AVERROR_xxx on error<br>
	 * Original signature : <code>int av_write_header(AVFormatContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1173</i>
	 */
	@Mangling({"_Z15av_write_headerP15AVFormatContext", "?av_write_header@@YAHPAUAVFormatContext@@@Z"}) 
	int av_write_header(AVFormatContext s);
	/**
	 * Writes a packet to an output media file.<br>
	 * * The packet shall contain one audio or video frame.<br>
	 * The packet must be correctly interleaved according to the container<br>
	 * specification, if not then av_interleaved_write_frame must be used.<br>
	 * * @param s media file handle<br>
	 * @param pkt The packet, which contains the stream_index, buf/buf_size,<br>
	 * dts/pts, ...<br>
	 * @return < 0 on error, = 0 if OK, 1 if end of stream wanted<br>
	 * Original signature : <code>int av_write_frame(AVFormatContext*, AVPacket*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1187</i>
	 */
	@Mangling({"_Z14av_write_frameP15AVFormatContextP8AVPacket", "?av_write_frame@@YAHPAUAVFormatContext@@PAUAVPacket@@@Z"}) 
	int av_write_frame(AVFormatContext s, AVPacket pkt);
	/**
	 * Writes a packet to an output media file ensuring correct interleaving.<br>
	 * * The packet must contain one audio or video frame.<br>
	 * If the packets are already correctly interleaved, the application should<br>
	 * call av_write_frame() instead as it is slightly faster. It is also important<br>
	 * to keep in mind that completely non-interleaved input will need huge amounts<br>
	 * of memory to interleave with this, so it is preferable to interleave at the<br>
	 * demuxer level.<br>
	 * * @param s media file handle<br>
	 * @param pkt The packet, which contains the stream_index, buf/buf_size,<br>
	 * dts/pts, ...<br>
	 * @return < 0 on error, = 0 if OK, 1 if end of stream wanted<br>
	 * Original signature : <code>int av_interleaved_write_frame(AVFormatContext*, AVPacket*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1204</i>
	 */
	@Mangling({"_Z26av_interleaved_write_frameP15AVFormatContextP8AVPacket", "?av_interleaved_write_frame@@YAHPAUAVFormatContext@@PAUAVPacket@@@Z"}) 
	int av_interleaved_write_frame(AVFormatContext s, AVPacket pkt);
	/**
	 * Interleaves a packet per dts in an output media file.<br>
	 * * Packets with pkt->destruct == av_destruct_packet will be freed inside this<br>
	 * function, so they cannot be used after it. Note that calling av_free_packet()<br>
	 * on them is still safe.<br>
	 * * @param s media file handle<br>
	 * @param out the interleaved packet will be output here<br>
	 * @param in the input packet<br>
	 * @param flush 1 if no further packets are available as input and all<br>
	 *              remaining packets should be output<br>
	 * @return 1 if a packet was output, 0 if no packet could be output,<br>
	 *         < 0 if an error occurred<br>
	 * Original signature : <code>int av_interleave_packet_per_dts(AVFormatContext*, AVPacket*, AVPacket*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1221</i>
	 */
	@Mangling({"_Z28av_interleave_packet_per_dtsP15AVFormatContextP8AVPacketP8AVPacketi", "?av_interleave_packet_per_dts@@YAHPAUAVFormatContext@@PAUAVPacket@@PAUAVPacket@@H@Z"}) 
	int av_interleave_packet_per_dts(AVFormatContext s, AVPacket out, AVPacket pkt, int flush);
	/**
	 * Writes the stream trailer to an output media file and frees the<br>
	 * file private data.<br>
	 * * May only be called after a successful call to av_write_header.<br>
	 * * @param s media file handle<br>
	 * @return 0 if OK, AVERROR_xxx on error<br>
	 * Original signature : <code>int av_write_trailer(AVFormatContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1233</i>
	 */
	@Mangling({"_Z16av_write_trailerP15AVFormatContext", "?av_write_trailer@@YAHPAUAVFormatContext@@@Z"}) 
	int av_write_trailer(AVFormatContext s);
	/**
	 * Original signature : <code>void dump_format(AVFormatContext*, int, const char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1235</i><br>
	 * @deprecated use the safer methods {@link #dump_format(avformat.AVFormatContext, int, java.lang.String, int)} and {@link #dump_format(avformat.AVFormatContext, int, com.sun.jna.Pointer, int)} instead
	 */
	@Mangling({"_Z11dump_formatP15AVFormatContextiPKci", "?dump_format@@YAXPAUAVFormatContext@@HPADH@Z"}) 
	@Deprecated 
	void dump_format(AVFormatContext ic, int index, Pointer url, int is_output);
	/**
	 * Original signature : <code>void dump_format(AVFormatContext*, int, const char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1235</i>
	 */
	@Mangling({"_Z11dump_formatP15AVFormatContextiPKci", "?dump_format@@YAXPAUAVFormatContext@@HPADH@Z"}) 
	void dump_format(AVFormatContext ic, int index, String url, int is_output);
	/**
	 * Parses width and height out of string str.<br>
	 * @deprecated Use av_parse_video_frame_size instead.<br>
	 * Original signature : <code>int parse_image_size(int*, int*, const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1245</i><br>
	 * @deprecated use the safer methods {@link #parse_image_size(java.nio.IntBuffer, java.nio.IntBuffer, java.lang.String)} and {@link #parse_image_size(com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z16parse_image_sizePiPiPKc", "?parse_image_size@@YAHPAHPAHPAD@Z"}) 
	@Deprecated 
	int parse_image_size(IntByReference width_ptr, IntByReference height_ptr, Pointer str);
	/**
	 * Parses width and height out of string str.<br>
	 * @deprecated Use av_parse_video_frame_size instead.<br>
	 * Original signature : <code>int parse_image_size(int*, int*, const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1245</i>
	 */
	@Mangling({"_Z16parse_image_sizePiPiPKc", "?parse_image_size@@YAHPAHPAHPAD@Z"}) 
	int parse_image_size(IntBuffer width_ptr, IntBuffer height_ptr, String str);
	/**
	 * Converts framerate from a string to a fraction.<br>
	 * @deprecated Use av_parse_video_frame_rate instead.<br>
	 * Original signature : <code>int parse_frame_rate(int*, int*, const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1252</i><br>
	 * @deprecated use the safer methods {@link #parse_frame_rate(java.nio.IntBuffer, java.nio.IntBuffer, java.lang.String)} and {@link #parse_frame_rate(com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z16parse_frame_ratePiPiPKc", "?parse_frame_rate@@YAHPAHPAHPAD@Z"}) 
	@Deprecated 
	int parse_frame_rate(IntByReference frame_rate, IntByReference frame_rate_base, Pointer arg);
	/**
	 * Converts framerate from a string to a fraction.<br>
	 * @deprecated Use av_parse_video_frame_rate instead.<br>
	 * Original signature : <code>int parse_frame_rate(int*, int*, const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1252</i>
	 */
	@Mangling({"_Z16parse_frame_ratePiPiPKc", "?parse_frame_rate@@YAHPAHPAHPAD@Z"}) 
	int parse_frame_rate(IntBuffer frame_rate, IntBuffer frame_rate_base, String arg);
	/**
	 * Parses datestr and returns a corresponding number of microseconds.<br>
	 * @param datestr String representing a date or a duration.<br>
	 * - If a date the syntax is:<br>
	 * @code<br>
	 *  [{YYYY-MM-DD|YYYYMMDD}]{T| }{HH[:MM[:SS[.m...]]][Z]|HH[MM[SS[.m...]]][Z]}<br>
	 * @endcode<br>
	 * Time is local time unless Z is appended, in which case it is<br>
	 * interpreted as UTC.<br>
	 * If the year-month-day part is not specified it takes the current<br>
	 * year-month-day.<br>
	 * Returns the number of microseconds since 1st of January, 1970 up to<br>
	 * the time of the parsed date or INT64_MIN if datestr cannot be<br>
	 * successfully parsed.<br>
	 * - If a duration the syntax is:<br>
	 * @code<br>
	 *  [-]HH[:MM[:SS[.m...]]]<br>
	 *  [-]S+[.m...]<br>
	 * @endcode<br>
	 * Returns the number of microseconds contained in a time interval<br>
	 * with the specified duration or INT64_MIN if datestr cannot be<br>
	 * successfully parsed.<br>
	 * @param duration Flag which tells how to interpret datestr, if<br>
	 * not zero datestr is interpreted as a duration, otherwise as a<br>
	 * date.<br>
	 * Original signature : <code>int64_t parse_date(const char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1282</i><br>
	 * @deprecated use the safer methods {@link #parse_date(java.lang.String, int)} and {@link #parse_date(com.sun.jna.Pointer, int)} instead
	 */
	@Mangling({"_Z10parse_datePKci", "?parse_date@@YA7int64_tPADH@Z"}) 
	@Deprecated 
	long parse_date(Pointer datestr, int duration);
	/**
	 * Parses datestr and returns a corresponding number of microseconds.<br>
	 * @param datestr String representing a date or a duration.<br>
	 * - If a date the syntax is:<br>
	 * @code<br>
	 *  [{YYYY-MM-DD|YYYYMMDD}]{T| }{HH[:MM[:SS[.m...]]][Z]|HH[MM[SS[.m...]]][Z]}<br>
	 * @endcode<br>
	 * Time is local time unless Z is appended, in which case it is<br>
	 * interpreted as UTC.<br>
	 * If the year-month-day part is not specified it takes the current<br>
	 * year-month-day.<br>
	 * Returns the number of microseconds since 1st of January, 1970 up to<br>
	 * the time of the parsed date or INT64_MIN if datestr cannot be<br>
	 * successfully parsed.<br>
	 * - If a duration the syntax is:<br>
	 * @code<br>
	 *  [-]HH[:MM[:SS[.m...]]]<br>
	 *  [-]S+[.m...]<br>
	 * @endcode<br>
	 * Returns the number of microseconds contained in a time interval<br>
	 * with the specified duration or INT64_MIN if datestr cannot be<br>
	 * successfully parsed.<br>
	 * @param duration Flag which tells how to interpret datestr, if<br>
	 * not zero datestr is interpreted as a duration, otherwise as a<br>
	 * date.<br>
	 * Original signature : <code>int64_t parse_date(const char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1282</i>
	 */
	@Mangling({"_Z10parse_datePKci", "?parse_date@@YA7int64_tPADH@Z"}) 
	long parse_date(String datestr, int duration);
	/**
	 * Gets the current time in microseconds.<br>
	 * Original signature : <code>int64_t av_gettime()</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1285</i>
	 */
	@Mangling({"_Z10av_gettimev", "?av_gettime@@YA7int64_tXZ"}) 
	long av_gettime();
	/**
	 * Original signature : <code>int64_t ffm_read_write_index(int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1289</i>
	 */
	@Mangling({"_Z20ffm_read_write_indexi", "?ffm_read_write_index@@YA7int64_tH@Z"}) 
	long ffm_read_write_index(int fd);
	/**
	 * Original signature : <code>int ffm_write_write_index(int, int64_t)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1290</i>
	 */
	@Mangling({"_Z21ffm_write_write_indexi7int64_t", "?ffm_write_write_index@@YAHH7int64_t@Z"}) 
	int ffm_write_write_index(int fd, long pos);
	/**
	 * Original signature : <code>void ffm_set_write_index(AVFormatContext*, int64_t, int64_t)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1291</i>
	 */
	@Mangling({"_Z19ffm_set_write_indexP15AVFormatContext7int64_t7int64_t", "?ffm_set_write_index@@YAXPAUAVFormatContext@@7int64_t7int64_t@Z"}) 
	void ffm_set_write_index(AVFormatContext s, long pos, long file_size);
	/**
	 * Attempts to find a specific tag in a URL.<br>
	 * * syntax: '?tag1=val1&tag2=val2...'. Little URL decoding is done.<br>
	 * Return 1 if found.<br>
	 * Original signature : <code>int find_info_tag(char*, int, const char*, const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1299</i><br>
	 * @deprecated use the safer methods {@link #find_info_tag(java.nio.ByteBuffer, int, java.lang.String, java.lang.String)} and {@link #find_info_tag(com.sun.jna.Pointer, int, com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z13find_info_tagPciPKcPKc", "?find_info_tag@@YAHPADHPADPAD@Z"}) 
	@Deprecated 
	int find_info_tag(Pointer arg, int arg_size, Pointer tag1, Pointer info);
	/**
	 * Attempts to find a specific tag in a URL.<br>
	 * * syntax: '?tag1=val1&tag2=val2...'. Little URL decoding is done.<br>
	 * Return 1 if found.<br>
	 * Original signature : <code>int find_info_tag(char*, int, const char*, const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1299</i>
	 */
	@Mangling({"_Z13find_info_tagPciPKcPKc", "?find_info_tag@@YAHPADHPADPAD@Z"}) 
	int find_info_tag(ByteBuffer arg, int arg_size, String tag1, String info);
	/**
	 * Returns in 'buf' the path with '%d' replaced by a number.<br>
	 * * Also handles the '%0nd' format where 'n' is the total number<br>
	 * of digits and '%%'.<br>
	 * * @param buf destination buffer<br>
	 * @param buf_size destination buffer size<br>
	 * @param path numbered sequence string<br>
	 * @param number frame number<br>
	 * @return 0 if OK, -1 on format error<br>
	 * Original signature : <code>int av_get_frame_filename(char*, int, const char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1313</i><br>
	 * @deprecated use the safer methods {@link #av_get_frame_filename(java.nio.ByteBuffer, int, java.lang.String, int)} and {@link #av_get_frame_filename(com.sun.jna.Pointer, int, com.sun.jna.Pointer, int)} instead
	 */
	@Mangling({"_Z21av_get_frame_filenamePciPKci", "?av_get_frame_filename@@YAHPADHPADH@Z"}) 
	@Deprecated 
	int av_get_frame_filename(Pointer buf, int buf_size, Pointer path, int number);
	/**
	 * Returns in 'buf' the path with '%d' replaced by a number.<br>
	 * * Also handles the '%0nd' format where 'n' is the total number<br>
	 * of digits and '%%'.<br>
	 * * @param buf destination buffer<br>
	 * @param buf_size destination buffer size<br>
	 * @param path numbered sequence string<br>
	 * @param number frame number<br>
	 * @return 0 if OK, -1 on format error<br>
	 * Original signature : <code>int av_get_frame_filename(char*, int, const char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1313</i>
	 */
	@Mangling({"_Z21av_get_frame_filenamePciPKci", "?av_get_frame_filename@@YAHPADHPADH@Z"}) 
	int av_get_frame_filename(ByteBuffer buf, int buf_size, String path, int number);
	/**
	 * Checks whether filename actually is a numbered sequence generator.<br>
	 * * @param filename possible numbered sequence string<br>
	 * @return 1 if a valid numbered sequence string, 0 otherwise<br>
	 * Original signature : <code>int av_filename_number_test(const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1322</i><br>
	 * @deprecated use the safer methods {@link #av_filename_number_test(java.lang.String)} and {@link #av_filename_number_test(com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z23av_filename_number_testPKc", "?av_filename_number_test@@YAHPAD@Z"}) 
	@Deprecated 
	int av_filename_number_test(Pointer filename);
	/**
	 * Checks whether filename actually is a numbered sequence generator.<br>
	 * * @param filename possible numbered sequence string<br>
	 * @return 1 if a valid numbered sequence string, 0 otherwise<br>
	 * Original signature : <code>int av_filename_number_test(const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1322</i>
	 */
	@Mangling({"_Z23av_filename_number_testPKc", "?av_filename_number_test@@YAHPAD@Z"}) 
	int av_filename_number_test(String filename);
	/**
	 * Generates an SDP for an RTP session.<br>
	 * * @param ac array of AVFormatContexts describing the RTP streams. If the<br>
	 *           array is composed by only one context, such context can contain<br>
	 *           multiple AVStreams (one AVStream per RTP stream). Otherwise,<br>
	 *           all the contexts in the array (an AVCodecContext per RTP stream)<br>
	 *           must contain only one AVStream.<br>
	 * @param n_files number of AVCodecContexts contained in ac<br>
	 * @param buff buffer where the SDP will be stored (must be allocated by<br>
	 *             the caller)<br>
	 * @param size the size of the buffer<br>
	 * @return 0 if OK, AVERROR_xxx on error<br>
	 * Original signature : <code>int avf_sdp_create(AVFormatContext*[], int, char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1338</i><br>
	 * @deprecated use the safer methods {@link #avf_sdp_create(avformat.AVFormatContext.ByReference[], int, java.nio.ByteBuffer, int)} and {@link #avf_sdp_create(avformat.AVFormatContext.ByReference[], int, com.sun.jna.Pointer, int)} instead
	 */
	@Mangling({"_Z14avf_sdp_createPP15AVFormatContextiPci", "?avf_sdp_create@@YAHQAPAUAVFormatContext@@HPADH@Z"}) 
	@Deprecated 
	int avf_sdp_create(PointerByReference ac, int n_files, Pointer buff, int size);
	/**
	 * Generates an SDP for an RTP session.<br>
	 * * @param ac array of AVFormatContexts describing the RTP streams. If the<br>
	 *           array is composed by only one context, such context can contain<br>
	 *           multiple AVStreams (one AVStream per RTP stream). Otherwise,<br>
	 *           all the contexts in the array (an AVCodecContext per RTP stream)<br>
	 *           must contain only one AVStream.<br>
	 * @param n_files number of AVCodecContexts contained in ac<br>
	 * @param buff buffer where the SDP will be stored (must be allocated by<br>
	 *             the caller)<br>
	 * @param size the size of the buffer<br>
	 * @return 0 if OK, AVERROR_xxx on error<br>
	 * Original signature : <code>int avf_sdp_create(AVFormatContext*[], int, char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1338</i>
	 */
	@Mangling({"_Z14avf_sdp_createPP15AVFormatContextiPci", "?avf_sdp_create@@YAHQAPAUAVFormatContext@@HPADH@Z"}) 
	int avf_sdp_create(AVFormatContext.ByReference ac[], int n_files, ByteBuffer buff, int size);
	/**
	 * Generates an SDP for an RTP session.<br>
	 * * @param ac array of AVFormatContexts describing the RTP streams. If the<br>
	 *           array is composed by only one context, such context can contain<br>
	 *           multiple AVStreams (one AVStream per RTP stream). Otherwise,<br>
	 *           all the contexts in the array (an AVCodecContext per RTP stream)<br>
	 *           must contain only one AVStream.<br>
	 * @param n_files number of AVCodecContexts contained in ac<br>
	 * @param buff buffer where the SDP will be stored (must be allocated by<br>
	 *             the caller)<br>
	 * @param size the size of the buffer<br>
	 * @return 0 if OK, AVERROR_xxx on error<br>
	 * Original signature : <code>int avf_sdp_create(AVFormatContext*[], int, char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1338</i>
	 */
	@Mangling({"_Z14avf_sdp_createPP15AVFormatContextiPci", "?avf_sdp_create@@YAHQAPAUAVFormatContext@@HPADH@Z"}) 
	int avf_sdp_create(AVFormatContext.ByReference ac[], int n_files, Pointer buff, int size);
	/**
	 * Returns a positive value if the given filename has one of the given<br>
	 * extensions, 0 otherwise.<br>
	 * * @param extensions a comma-separated list of filename extensions<br>
	 * Original signature : <code>int av_match_ext(const char*, const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1346</i><br>
	 * @deprecated use the safer methods {@link #av_match_ext(java.lang.String, java.lang.String)} and {@link #av_match_ext(com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z12av_match_extPKcPKc", "?av_match_ext@@YAHPADPAD@Z"}) 
	@Deprecated 
	int av_match_ext(Pointer filename, Pointer extensions);
	/**
	 * Returns a positive value if the given filename has one of the given<br>
	 * extensions, 0 otherwise.<br>
	 * * @param extensions a comma-separated list of filename extensions<br>
	 * Original signature : <code>int av_match_ext(const char*, const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avformat.h:1346</i>
	 */
	@Mangling({"_Z12av_match_extPKcPKc", "?av_match_ext@@YAHPADPAD@Z"}) 
	int av_match_ext(String filename, String extensions);
	/**
	 * Creates an URLContext for accessing to the resource indicated by<br>
	 * url, and opens it using the URLProtocol up.<br>
	 * * @param puc pointer to the location where, in case of success, the<br>
	 * function puts the pointer to the created URLContext<br>
	 * @param flags flags which control how the resource indicated by url<br>
	 * is to be opened<br>
	 * @return 0 in case of success, a negative value corresponding to an<br>
	 * AVERROR code in case of failure<br>
	 * Original signature : <code>int url_open_protocol(URLContext**, URLProtocol*, const char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:78</i><br>
	 * @deprecated use the safer methods {@link #url_open_protocol(avformat.URLContext.ByReference[], avformat.URLProtocol, java.lang.String, int)} and {@link #url_open_protocol(avformat.URLContext.ByReference[], avformat.URLProtocol, com.sun.jna.Pointer, int)} instead
	 */
	@Mangling({"_Z17url_open_protocolPP10URLContextP11URLProtocolPKci", "?url_open_protocol@@YAHPAPAUURLContext@@PAUURLProtocol@@PADH@Z"}) 
	@Deprecated 
	int url_open_protocol(PointerByReference puc, URLProtocol up, Pointer url, int flags);
	/**
	 * Creates an URLContext for accessing to the resource indicated by<br>
	 * url, and opens it using the URLProtocol up.<br>
	 * * @param puc pointer to the location where, in case of success, the<br>
	 * function puts the pointer to the created URLContext<br>
	 * @param flags flags which control how the resource indicated by url<br>
	 * is to be opened<br>
	 * @return 0 in case of success, a negative value corresponding to an<br>
	 * AVERROR code in case of failure<br>
	 * Original signature : <code>int url_open_protocol(URLContext**, URLProtocol*, const char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:78</i>
	 */
	@Mangling({"_Z17url_open_protocolPP10URLContextP11URLProtocolPKci", "?url_open_protocol@@YAHPAPAUURLContext@@PAUURLProtocol@@PADH@Z"}) 
	int url_open_protocol(URLContext.ByReference puc[], URLProtocol up, String url, int flags);
	/**
	 * Creates an URLContext for accessing to the resource indicated by<br>
	 * url, and opens it using the URLProtocol up.<br>
	 * * @param puc pointer to the location where, in case of success, the<br>
	 * function puts the pointer to the created URLContext<br>
	 * @param flags flags which control how the resource indicated by url<br>
	 * is to be opened<br>
	 * @return 0 in case of success, a negative value corresponding to an<br>
	 * AVERROR code in case of failure<br>
	 * Original signature : <code>int url_open_protocol(URLContext**, URLProtocol*, const char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:78</i>
	 */
	@Mangling({"_Z17url_open_protocolPP10URLContextP11URLProtocolPKci", "?url_open_protocol@@YAHPAPAUURLContext@@PAUURLProtocol@@PADH@Z"}) 
	int url_open_protocol(URLContext.ByReference puc[], URLProtocol up, Pointer url, int flags);
	/**
	 * Creates an URLContext for accessing to the resource indicated by<br>
	 * url, and opens it.<br>
	 * * @param puc pointer to the location where, in case of success, the<br>
	 * function puts the pointer to the created URLContext<br>
	 * @param flags flags which control how the resource indicated by url<br>
	 * is to be opened<br>
	 * @return 0 in case of success, a negative value corresponding to an<br>
	 * AVERROR code in case of failure<br>
	 * Original signature : <code>int url_open(URLContext**, const char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:92</i><br>
	 * @deprecated use the safer methods {@link #url_open(avformat.URLContext.ByReference[], java.lang.String, int)} and {@link #url_open(avformat.URLContext.ByReference[], com.sun.jna.Pointer, int)} instead
	 */
	@Mangling({"_Z8url_openPP10URLContextPKci", "?url_open@@YAHPAPAUURLContext@@PADH@Z"}) 
	@Deprecated 
	int url_open(PointerByReference h, Pointer url, int flags);
	/**
	 * Creates an URLContext for accessing to the resource indicated by<br>
	 * url, and opens it.<br>
	 * * @param puc pointer to the location where, in case of success, the<br>
	 * function puts the pointer to the created URLContext<br>
	 * @param flags flags which control how the resource indicated by url<br>
	 * is to be opened<br>
	 * @return 0 in case of success, a negative value corresponding to an<br>
	 * AVERROR code in case of failure<br>
	 * Original signature : <code>int url_open(URLContext**, const char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:92</i>
	 */
	@Mangling({"_Z8url_openPP10URLContextPKci", "?url_open@@YAHPAPAUURLContext@@PADH@Z"}) 
	int url_open(URLContext.ByReference h[], String url, int flags);
	/**
	 * Creates an URLContext for accessing to the resource indicated by<br>
	 * url, and opens it.<br>
	 * * @param puc pointer to the location where, in case of success, the<br>
	 * function puts the pointer to the created URLContext<br>
	 * @param flags flags which control how the resource indicated by url<br>
	 * is to be opened<br>
	 * @return 0 in case of success, a negative value corresponding to an<br>
	 * AVERROR code in case of failure<br>
	 * Original signature : <code>int url_open(URLContext**, const char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:92</i>
	 */
	@Mangling({"_Z8url_openPP10URLContextPKci", "?url_open@@YAHPAPAUURLContext@@PADH@Z"}) 
	int url_open(URLContext.ByReference h[], Pointer url, int flags);
	/**
	 * Reads up to size bytes from the resource accessed by h, and stores<br>
	 * the read bytes in buf.<br>
	 * * @return The number of bytes actually read, or a negative value<br>
	 * corresponding to an AVERROR code in case of error. A value of zero<br>
	 * indicates that it is not possible to read more from the accessed<br>
	 * resource (except if the value of the size argument is also zero).<br>
	 * Original signature : <code>int url_read(URLContext*, unsigned char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:103</i><br>
	 * @deprecated use the safer methods {@link #url_read(avformat.URLContext, java.nio.ByteBuffer, int)} and {@link #url_read(avformat.URLContext, com.sun.jna.Pointer, int)} instead
	 */
	@Mangling({"_Z8url_readP10URLContextPhi", "?url_read@@YAHPAUURLContext@@PAEH@Z"}) 
	@Deprecated 
	int url_read(URLContext h, Pointer buf, int size);
	/**
	 * Reads up to size bytes from the resource accessed by h, and stores<br>
	 * the read bytes in buf.<br>
	 * * @return The number of bytes actually read, or a negative value<br>
	 * corresponding to an AVERROR code in case of error. A value of zero<br>
	 * indicates that it is not possible to read more from the accessed<br>
	 * resource (except if the value of the size argument is also zero).<br>
	 * Original signature : <code>int url_read(URLContext*, unsigned char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:103</i>
	 */
	@Mangling({"_Z8url_readP10URLContextPhi", "?url_read@@YAHPAUURLContext@@PAEH@Z"}) 
	int url_read(URLContext h, ByteBuffer buf, int size);
	/**
	 * Read as many bytes as possible (up to size), calling the<br>
	 * read function multiple times if necessary.<br>
	 * Will also retry if the read function returns AVERROR(EAGAIN).<br>
	 * This makes special short-read handling in applications<br>
	 * unnecessary, if the return value is < size then it is<br>
	 * certain there was either an error or the end of file was reached.<br>
	 * Original signature : <code>int url_read_complete(URLContext*, unsigned char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:113</i><br>
	 * @deprecated use the safer methods {@link #url_read_complete(avformat.URLContext, java.nio.ByteBuffer, int)} and {@link #url_read_complete(avformat.URLContext, com.sun.jna.Pointer, int)} instead
	 */
	@Mangling({"_Z17url_read_completeP10URLContextPhi", "?url_read_complete@@YAHPAUURLContext@@PAEH@Z"}) 
	@Deprecated 
	int url_read_complete(URLContext h, Pointer buf, int size);
	/**
	 * Read as many bytes as possible (up to size), calling the<br>
	 * read function multiple times if necessary.<br>
	 * Will also retry if the read function returns AVERROR(EAGAIN).<br>
	 * This makes special short-read handling in applications<br>
	 * unnecessary, if the return value is < size then it is<br>
	 * certain there was either an error or the end of file was reached.<br>
	 * Original signature : <code>int url_read_complete(URLContext*, unsigned char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:113</i>
	 */
	@Mangling({"_Z17url_read_completeP10URLContextPhi", "?url_read_complete@@YAHPAUURLContext@@PAEH@Z"}) 
	int url_read_complete(URLContext h, ByteBuffer buf, int size);
	/**
	 * Original signature : <code>int url_write(URLContext*, unsigned char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:114</i><br>
	 * @deprecated use the safer methods {@link #url_write(avformat.URLContext, java.nio.ByteBuffer, int)} and {@link #url_write(avformat.URLContext, com.sun.jna.Pointer, int)} instead
	 */
	@Mangling({"_Z9url_writeP10URLContextPhi", "?url_write@@YAHPAUURLContext@@PAEH@Z"}) 
	@Deprecated 
	int url_write(URLContext h, Pointer buf, int size);
	/**
	 * Original signature : <code>int url_write(URLContext*, unsigned char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:114</i>
	 */
	@Mangling({"_Z9url_writeP10URLContextPhi", "?url_write@@YAHPAUURLContext@@PAEH@Z"}) 
	int url_write(URLContext h, ByteBuffer buf, int size);
	/**
	 * Changes the position that will be used by the next read/write<br>
	 * operation on the resource accessed by h.<br>
	 * * @param pos specifies the new position to set<br>
	 * @param whence specifies how pos should be interpreted, it must be<br>
	 * one of SEEK_SET (seek from the beginning), SEEK_CUR (seek from the<br>
	 * current position), SEEK_END (seek from the end), or AVSEEK_SIZE<br>
	 * (return the filesize of the requested resource, pos is ignored).<br>
	 * @return a negative value corresponding to an AVERROR code in case<br>
	 * of failure, or the resulting file position, measured in bytes from<br>
	 * the beginning of the file. You can use this feature together with<br>
	 * SEEK_CUR to read the current file position.<br>
	 * Original signature : <code>int64_t url_seek(URLContext*, int64_t, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:130</i>
	 */
	@Mangling({"_Z8url_seekP10URLContext7int64_ti", "?url_seek@@YA7int64_tPAUURLContext@@7int64_tH@Z"}) 
	long url_seek(URLContext h, long pos, int whence);
	/**
	 * Closes the resource accessed by the URLContext h, and frees the<br>
	 * memory used by it.<br>
	 * * @return a negative value if an error condition occurred, 0<br>
	 * otherwise<br>
	 * Original signature : <code>int url_close(URLContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:139</i>
	 */
	@Mangling({"_Z9url_closeP10URLContext", "?url_close@@YAHPAUURLContext@@@Z"}) 
	int url_close(URLContext h);
	/**
	 * Returns a non-zero value if the resource indicated by url<br>
	 * exists, 0 otherwise.<br>
	 * Original signature : <code>int url_exist(const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:145</i><br>
	 * @deprecated use the safer methods {@link #url_exist(java.lang.String)} and {@link #url_exist(com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z9url_existPKc", "?url_exist@@YAHPAD@Z"}) 
	@Deprecated 
	int url_exist(Pointer url);
	/**
	 * Returns a non-zero value if the resource indicated by url<br>
	 * exists, 0 otherwise.<br>
	 * Original signature : <code>int url_exist(const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:145</i>
	 */
	@Mangling({"_Z9url_existPKc", "?url_exist@@YAHPAD@Z"}) 
	int url_exist(String url);
	/**
	 * Original signature : <code>int64_t url_filesize(URLContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:147</i>
	 */
	@Mangling({"_Z12url_filesizeP10URLContext", "?url_filesize@@YA7int64_tPAUURLContext@@@Z"}) 
	long url_filesize(URLContext h);
	/**
	 * Return the file descriptor associated with this URL. For RTP, this<br>
	 * will return only the RTP file descriptor, not the RTCP file descriptor.<br>
	 * To get both, use rtp_get_file_handles().<br>
	 * * @return the file descriptor associated with this URL, or <0 on error.<br>
	 * Original signature : <code>int url_get_file_handle(URLContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:156</i>
	 */
	@Mangling({"_Z19url_get_file_handleP10URLContext", "?url_get_file_handle@@YAHPAUURLContext@@@Z"}) 
	int url_get_file_handle(URLContext h);
	/**
	 * Return the maximum packet size associated to packetized file<br>
	 * handle. If the file is not packetized (stream like HTTP or file on<br>
	 * disk), then 0 is returned.<br>
	 * * @param h file handle<br>
	 * @return maximum packet size in bytes<br>
	 * Original signature : <code>int url_get_max_packet_size(URLContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:166</i>
	 */
	@Mangling({"_Z23url_get_max_packet_sizeP10URLContext", "?url_get_max_packet_size@@YAHPAUURLContext@@@Z"}) 
	int url_get_max_packet_size(URLContext h);
	/**
	 * Original signature : <code>void url_get_filename(URLContext*, char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:167</i><br>
	 * @deprecated use the safer methods {@link #url_get_filename(avformat.URLContext, java.nio.ByteBuffer, int)} and {@link #url_get_filename(avformat.URLContext, com.sun.jna.Pointer, int)} instead
	 */
	@Mangling({"_Z16url_get_filenameP10URLContextPci", "?url_get_filename@@YAXPAUURLContext@@PADH@Z"}) 
	@Deprecated 
	void url_get_filename(URLContext h, Pointer buf, int buf_size);
	/**
	 * Original signature : <code>void url_get_filename(URLContext*, char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:167</i>
	 */
	@Mangling({"_Z16url_get_filenameP10URLContextPci", "?url_get_filename@@YAXPAUURLContext@@PADH@Z"}) 
	void url_get_filename(URLContext h, ByteBuffer buf, int buf_size);
	/**
	 * The callback is called in blocking functions to test regulary if<br>
	 * asynchronous interruption is needed. AVERROR(EINTR) is returned<br>
	 * in this case by the interrupted function. 'NULL' means no interrupt<br>
	 * callback is given.<br>
	 * Original signature : <code>void url_set_interrupt_cb(URLInterruptCB*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:175</i><br>
	 * @param interrupt_cb @see avformat.AvformatLibrary.URLInterruptCB
	 */
	@Mangling({"_Z20url_set_interrupt_cbPPFivE", "?url_set_interrupt_cb@@YAXPAPFHXE@Z"}) 
	void url_set_interrupt_cb(Pointer interrupt_cb);
	/**
	 * not implemented<br>
	 * Original signature : <code>int url_poll(URLPollEntry*, int, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:178</i>
	 */
	@Mangling({"_Z8url_pollP12URLPollEntryii", "?url_poll@@YAHPAUURLPollEntry@@HH@Z"}) 
	int url_poll(URLPollEntry poll_table, int n, int timeout);
	/**
	 * Pause and resume playing - only meaningful if using a network streaming<br>
	 * protocol (e.g. MMS).<br>
	 * @param pause 1 for pause, 0 for resume<br>
	 * Original signature : <code>int av_url_read_pause(URLContext*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:185</i>
	 */
	@Mangling({"_Z17av_url_read_pauseP10URLContexti", "?av_url_read_pause@@YAHPAUURLContext@@H@Z"}) 
	int av_url_read_pause(URLContext h, int pause);
	/**
	 * Seek to a given timestamp relative to some component stream.<br>
	 * Only meaningful if using a network streaming protocol (e.g. MMS.).<br>
	 * @param stream_index The stream index that the timestamp is relative to.<br>
	 *        If stream_index is (-1) the timestamp should be in AV_TIME_BASE<br>
	 *        units from the beginning of the presentation.<br>
	 *        If a stream_index >= 0 is used and the protocol does not support<br>
	 *        seeking based on component streams, the call will fail with ENOTSUP.<br>
	 * @param timestamp timestamp in AVStream.time_base units<br>
	 *        or if there is no stream specified then in AV_TIME_BASE units.<br>
	 * @param flags Optional combination of AVSEEK_FLAG_BACKWARD, AVSEEK_FLAG_BYTE<br>
	 *        and AVSEEK_FLAG_ANY. The protocol may silently ignore<br>
	 *        AVSEEK_FLAG_BACKWARD and AVSEEK_FLAG_ANY, but AVSEEK_FLAG_BYTE will<br>
	 *        fail with ENOTSUP if used and not supported.<br>
	 * @return >= 0 on success<br>
	 * @see AVInputFormat::read_seek<br>
	 * Original signature : <code>int64_t av_url_read_seek(URLContext*, int, int64_t, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:204</i>
	 */
	@Mangling({"_Z16av_url_read_seekP10URLContexti7int64_ti", "?av_url_read_seek@@YA7int64_tPAUURLContext@@H7int64_tH@Z"}) 
	long av_url_read_seek(URLContext h, int stream_index, long timestamp, int flags);
	/**
	 * If protocol is NULL, returns the first registered protocol,<br>
	 * if protocol is non-NULL, returns the next registered protocol after protocol,<br>
	 * or NULL if protocol is the last one.<br>
	 * Original signature : <code>URLProtocol* av_protocol_next(URLProtocol*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:247</i>
	 */
	@Mangling({"_Z16av_protocol_nextP11URLProtocol", "?av_protocol_next@@YAPAUURLProtocol@@PAUURLProtocol@@@Z"}) 
	URLProtocol av_protocol_next(URLProtocol p);
	/**
	 * @deprecated Use av_register_protocol() instead.<br>
	 * Original signature : <code>int register_protocol(URLProtocol*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:253</i>
	 */
	@Mangling({"_Z17register_protocolP11URLProtocol", "?register_protocol@@YAHPAUURLProtocol@@@Z"}) 
	int register_protocol(URLProtocol protocol);
	/**
	 * Registers the URLProtocol protocol.<br>
	 * Original signature : <code>int av_register_protocol(URLProtocol*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:259</i>
	 */
	@Mangling({"_Z20av_register_protocolP11URLProtocol", "?av_register_protocol@@YAHPAUURLProtocol@@@Z"}) 
	int av_register_protocol(URLProtocol protocol);
	/**
	 * Original signature : <code>int init_put_byte(ByteIOContext*, unsigned char*, int, int, void*, init_put_byte_arg1_read_packet_callback, init_put_byte_arg2_write_packet_callback, init_put_byte_arg3_seek_callback)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:291</i><br>
	 * @deprecated use the safer methods {@link #init_put_byte(avformat.ByteIOContext, java.nio.ByteBuffer, int, int, com.sun.jna.Pointer, avformat.AvformatLibrary.init_put_byte_arg1_read_packet_callback, avformat.AvformatLibrary.init_put_byte_arg2_write_packet_callback, avformat.AvformatLibrary.init_put_byte_arg3_seek_callback)} and {@link #init_put_byte(avformat.ByteIOContext, com.sun.jna.Pointer, int, int, com.sun.jna.Pointer, avformat.AvformatLibrary.init_put_byte_arg1_read_packet_callback, avformat.AvformatLibrary.init_put_byte_arg2_write_packet_callback, avformat.AvformatLibrary.init_put_byte_arg3_seek_callback)} instead
	 */
	@Mangling({"_Z13init_put_byteP13ByteIOContextPhiiPvPFiPvP7uint8_tiEPFiPvP7uint8_tiEPF7int64_tPv7int64_tiE", "?init_put_byte@@YAHPAUByteIOContext@@PAEHHPAXPFHPAXPA7uint8_tH@EPFHPAXPA7uint8_tH@EPF7int64_tPAX7int64_tH@E@Z"}) 
	@Deprecated 
	int init_put_byte(ByteIOContext s, Pointer buffer, int buffer_size, int write_flag, Pointer opaque, AvformatLibrary.init_put_byte_arg1_read_packet_callback arg1, AvformatLibrary.init_put_byte_arg2_write_packet_callback arg2, AvformatLibrary.init_put_byte_arg3_seek_callback arg3);
	/**
	 * Original signature : <code>int init_put_byte(ByteIOContext*, unsigned char*, int, int, void*, init_put_byte_arg1_read_packet_callback, init_put_byte_arg2_write_packet_callback, init_put_byte_arg3_seek_callback)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:291</i>
	 */
	@Mangling({"_Z13init_put_byteP13ByteIOContextPhiiPvPFiPvP7uint8_tiEPFiPvP7uint8_tiEPF7int64_tPv7int64_tiE", "?init_put_byte@@YAHPAUByteIOContext@@PAEHHPAXPFHPAXPA7uint8_tH@EPFHPAXPA7uint8_tH@EPF7int64_tPAX7int64_tH@E@Z"}) 
	int init_put_byte(ByteIOContext s, ByteBuffer buffer, int buffer_size, int write_flag, Pointer opaque, AvformatLibrary.init_put_byte_arg1_read_packet_callback arg1, AvformatLibrary.init_put_byte_arg2_write_packet_callback arg2, AvformatLibrary.init_put_byte_arg3_seek_callback arg3);
	/**
	 * Original signature : <code>ByteIOContext* av_alloc_put_byte(unsigned char*, int, int, void*, av_alloc_put_byte_arg1_read_packet_callback, av_alloc_put_byte_arg2_write_packet_callback, av_alloc_put_byte_arg3_seek_callback)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:299</i><br>
	 * @deprecated use the safer methods {@link #av_alloc_put_byte(java.nio.ByteBuffer, int, int, com.sun.jna.Pointer, avformat.AvformatLibrary.av_alloc_put_byte_arg1_read_packet_callback, avformat.AvformatLibrary.av_alloc_put_byte_arg2_write_packet_callback, avformat.AvformatLibrary.av_alloc_put_byte_arg3_seek_callback)} and {@link #av_alloc_put_byte(com.sun.jna.Pointer, int, int, com.sun.jna.Pointer, avformat.AvformatLibrary.av_alloc_put_byte_arg1_read_packet_callback, avformat.AvformatLibrary.av_alloc_put_byte_arg2_write_packet_callback, avformat.AvformatLibrary.av_alloc_put_byte_arg3_seek_callback)} instead
	 */
	@Mangling({"_Z17av_alloc_put_bytePhiiPvPFiPvP7uint8_tiEPFiPvP7uint8_tiEPF7int64_tPv7int64_tiE", "?av_alloc_put_byte@@YAPAUByteIOContext@@PAEHHPAXPFHPAXPA7uint8_tH@EPFHPAXPA7uint8_tH@EPF7int64_tPAX7int64_tH@E@Z"}) 
	@Deprecated 
	ByteIOContext av_alloc_put_byte(Pointer buffer, int buffer_size, int write_flag, Pointer opaque, AvformatLibrary.av_alloc_put_byte_arg1_read_packet_callback arg1, AvformatLibrary.av_alloc_put_byte_arg2_write_packet_callback arg2, AvformatLibrary.av_alloc_put_byte_arg3_seek_callback arg3);
	/**
	 * Original signature : <code>ByteIOContext* av_alloc_put_byte(unsigned char*, int, int, void*, av_alloc_put_byte_arg1_read_packet_callback, av_alloc_put_byte_arg2_write_packet_callback, av_alloc_put_byte_arg3_seek_callback)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:299</i>
	 */
	@Mangling({"_Z17av_alloc_put_bytePhiiPvPFiPvP7uint8_tiEPFiPvP7uint8_tiEPF7int64_tPv7int64_tiE", "?av_alloc_put_byte@@YAPAUByteIOContext@@PAEHHPAXPFHPAXPA7uint8_tH@EPFHPAXPA7uint8_tH@EPF7int64_tPAX7int64_tH@E@Z"}) 
	ByteIOContext av_alloc_put_byte(ByteBuffer buffer, int buffer_size, int write_flag, Pointer opaque, AvformatLibrary.av_alloc_put_byte_arg1_read_packet_callback arg1, AvformatLibrary.av_alloc_put_byte_arg2_write_packet_callback arg2, AvformatLibrary.av_alloc_put_byte_arg3_seek_callback arg3);
	/**
	 * Original signature : <code>void put_byte(ByteIOContext*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:308</i>
	 */
	@Mangling({"_Z8put_byteP13ByteIOContexti", "?put_byte@@YAXPAUByteIOContext@@H@Z"}) 
	void put_byte(ByteIOContext s, int b);
	/**
	 * Original signature : <code>void put_buffer(ByteIOContext*, const unsigned char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:309</i><br>
	 * @deprecated use the safer methods {@link #put_buffer(avformat.ByteIOContext, byte[], int)} and {@link #put_buffer(avformat.ByteIOContext, com.sun.jna.Pointer, int)} instead
	 */
	@Mangling({"_Z10put_bufferP13ByteIOContextPKhi", "?put_buffer@@YAXPAUByteIOContext@@PAEH@Z"}) 
	@Deprecated 
	void put_buffer(ByteIOContext s, Pointer buf, int size);
	/**
	 * Original signature : <code>void put_buffer(ByteIOContext*, const unsigned char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:309</i>
	 */
	@Mangling({"_Z10put_bufferP13ByteIOContextPKhi", "?put_buffer@@YAXPAUByteIOContext@@PAEH@Z"}) 
	void put_buffer(ByteIOContext s, byte buf[], int size);
	/**
	 * Original signature : <code>void put_le64(ByteIOContext*, uint64_t)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:310</i>
	 */
	@Mangling({"_Z8put_le64P13ByteIOContext8uint64_t", "?put_le64@@YAXPAUByteIOContext@@8uint64_t@Z"}) 
	void put_le64(ByteIOContext s, long val);
	/**
	 * Original signature : <code>void put_be64(ByteIOContext*, uint64_t)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:311</i>
	 */
	@Mangling({"_Z8put_be64P13ByteIOContext8uint64_t", "?put_be64@@YAXPAUByteIOContext@@8uint64_t@Z"}) 
	void put_be64(ByteIOContext s, long val);
	/**
	 * Original signature : <code>void put_le32(ByteIOContext*, unsigned int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:312</i>
	 */
	@Mangling({"_Z8put_le32P13ByteIOContextj", "?put_le32@@YAXPAUByteIOContext@@I@Z"}) 
	void put_le32(ByteIOContext s, int val);
	/**
	 * Original signature : <code>void put_be32(ByteIOContext*, unsigned int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:313</i>
	 */
	@Mangling({"_Z8put_be32P13ByteIOContextj", "?put_be32@@YAXPAUByteIOContext@@I@Z"}) 
	void put_be32(ByteIOContext s, int val);
	/**
	 * Original signature : <code>void put_le24(ByteIOContext*, unsigned int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:314</i>
	 */
	@Mangling({"_Z8put_le24P13ByteIOContextj", "?put_le24@@YAXPAUByteIOContext@@I@Z"}) 
	void put_le24(ByteIOContext s, int val);
	/**
	 * Original signature : <code>void put_be24(ByteIOContext*, unsigned int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:315</i>
	 */
	@Mangling({"_Z8put_be24P13ByteIOContextj", "?put_be24@@YAXPAUByteIOContext@@I@Z"}) 
	void put_be24(ByteIOContext s, int val);
	/**
	 * Original signature : <code>void put_le16(ByteIOContext*, unsigned int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:316</i>
	 */
	@Mangling({"_Z8put_le16P13ByteIOContextj", "?put_le16@@YAXPAUByteIOContext@@I@Z"}) 
	void put_le16(ByteIOContext s, int val);
	/**
	 * Original signature : <code>void put_be16(ByteIOContext*, unsigned int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:317</i>
	 */
	@Mangling({"_Z8put_be16P13ByteIOContextj", "?put_be16@@YAXPAUByteIOContext@@I@Z"}) 
	void put_be16(ByteIOContext s, int val);
	/**
	 * Original signature : <code>void put_tag(ByteIOContext*, const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:318</i><br>
	 * @deprecated use the safer methods {@link #put_tag(avformat.ByteIOContext, java.lang.String)} and {@link #put_tag(avformat.ByteIOContext, com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z7put_tagP13ByteIOContextPKc", "?put_tag@@YAXPAUByteIOContext@@PAD@Z"}) 
	@Deprecated 
	void put_tag(ByteIOContext s, Pointer tag);
	/**
	 * Original signature : <code>void put_tag(ByteIOContext*, const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:318</i>
	 */
	@Mangling({"_Z7put_tagP13ByteIOContextPKc", "?put_tag@@YAXPAUByteIOContext@@PAD@Z"}) 
	void put_tag(ByteIOContext s, String tag);
	/**
	 * Original signature : <code>void put_strz(ByteIOContext*, const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:320</i><br>
	 * @deprecated use the safer methods {@link #put_strz(avformat.ByteIOContext, java.lang.String)} and {@link #put_strz(avformat.ByteIOContext, com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z8put_strzP13ByteIOContextPKc", "?put_strz@@YAXPAUByteIOContext@@PAD@Z"}) 
	@Deprecated 
	void put_strz(ByteIOContext s, Pointer buf);
	/**
	 * Original signature : <code>void put_strz(ByteIOContext*, const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:320</i>
	 */
	@Mangling({"_Z8put_strzP13ByteIOContextPKc", "?put_strz@@YAXPAUByteIOContext@@PAD@Z"}) 
	void put_strz(ByteIOContext s, String buf);
	/**
	 * fseek() equivalent for ByteIOContext.<br>
	 * @return new position or AVERROR.<br>
	 * Original signature : <code>int64_t url_fseek(ByteIOContext*, int64_t, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:326</i>
	 */
	@Mangling({"_Z9url_fseekP13ByteIOContext7int64_ti", "?url_fseek@@YA7int64_tPAUByteIOContext@@7int64_tH@Z"}) 
	long url_fseek(ByteIOContext s, long offset, int whence);
	/**
	 * Skip given number of bytes forward.<br>
	 * @param offset number of bytes<br>
	 * Original signature : <code>void url_fskip(ByteIOContext*, int64_t)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:332</i>
	 */
	@Mangling({"_Z9url_fskipP13ByteIOContext7int64_t", "?url_fskip@@YAXPAUByteIOContext@@7int64_t@Z"}) 
	void url_fskip(ByteIOContext s, long offset);
	/**
	 * ftell() equivalent for ByteIOContext.<br>
	 * @return position or AVERROR.<br>
	 * Original signature : <code>int64_t url_ftell(ByteIOContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:338</i>
	 */
	@Mangling({"_Z9url_ftellP13ByteIOContext", "?url_ftell@@YA7int64_tPAUByteIOContext@@@Z"}) 
	long url_ftell(ByteIOContext s);
	/**
	 * Gets the filesize.<br>
	 * @return filesize or AVERROR<br>
	 * Original signature : <code>int64_t url_fsize(ByteIOContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:344</i>
	 */
	@Mangling({"_Z9url_fsizeP13ByteIOContext", "?url_fsize@@YA7int64_tPAUByteIOContext@@@Z"}) 
	long url_fsize(ByteIOContext s);
	/**
	 * feof() equivalent for ByteIOContext.<br>
	 * @return non zero if and only if end of file<br>
	 * Original signature : <code>int url_feof(ByteIOContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:350</i>
	 */
	@Mangling({"_Z8url_feofP13ByteIOContext", "?url_feof@@YAHPAUByteIOContext@@@Z"}) 
	int url_feof(ByteIOContext s);
	/**
	 * Original signature : <code>int url_ferror(ByteIOContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:352</i>
	 */
	@Mangling({"_Z10url_ferrorP13ByteIOContext", "?url_ferror@@YAHPAUByteIOContext@@@Z"}) 
	int url_ferror(ByteIOContext s);
	/**
	 * Original signature : <code>int av_url_read_fpause(ByteIOContext*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:354</i>
	 */
	@Mangling({"_Z18av_url_read_fpauseP13ByteIOContexti", "?av_url_read_fpause@@YAHPAUByteIOContext@@H@Z"}) 
	int av_url_read_fpause(ByteIOContext h, int pause);
	/**
	 * Original signature : <code>int64_t av_url_read_fseek(ByteIOContext*, int, int64_t, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:355</i>
	 */
	@Mangling({"_Z17av_url_read_fseekP13ByteIOContexti7int64_ti", "?av_url_read_fseek@@YA7int64_tPAUByteIOContext@@H7int64_tH@Z"}) 
	long av_url_read_fseek(ByteIOContext h, int stream_index, long timestamp, int flags);
	/**
	 * @note return URL_EOF (-1) if EOF<br>
	 * Original signature : <code>int url_fgetc(ByteIOContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:360</i>
	 */
	@Mangling({"_Z9url_fgetcP13ByteIOContext", "?url_fgetc@@YAHPAUByteIOContext@@@Z"}) 
	int url_fgetc(ByteIOContext s);
	/**
	 * Original signature : <code>int url_fprintf(ByteIOContext*, const char*, null)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:364</i><br>
	 * @deprecated use the safer methods {@link #url_fprintf(avformat.ByteIOContext, java.lang.String, java.lang.Object)} and {@link #url_fprintf(avformat.ByteIOContext, com.sun.jna.Pointer, java.lang.Object)} instead
	 */
	@Mangling({"_Z11url_fprintfP13ByteIOContextPKcv", "?url_fprintf@@YAHPAUByteIOContext@@PADX@Z"}) 
	@Deprecated 
	int url_fprintf(ByteIOContext s, Pointer fmt, Object... varargs);
	/**
	 * Original signature : <code>int url_fprintf(ByteIOContext*, const char*, null)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:364</i>
	 */
	@Mangling({"_Z11url_fprintfP13ByteIOContextPKcv", "?url_fprintf@@YAHPAUByteIOContext@@PADX@Z"}) 
	int url_fprintf(ByteIOContext s, String fmt, Object... varargs);
	/**
	 * @note unlike fgets, the EOL character is not returned and a whole<br>
	 * line is parsed. return NULL if first char read was EOF<br>
	 * Original signature : <code>char* url_fgets(ByteIOContext*, char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:371</i><br>
	 * @deprecated use the safer methods {@link #url_fgets(avformat.ByteIOContext, java.nio.ByteBuffer, int)} and {@link #url_fgets(avformat.ByteIOContext, com.sun.jna.Pointer, int)} instead
	 */
	@Mangling({"_Z9url_fgetsP13ByteIOContextPci", "?url_fgets@@YAPADPAUByteIOContext@@PADH@Z"}) 
	@Deprecated 
	Pointer url_fgets(ByteIOContext s, Pointer buf, int buf_size);
	/**
	 * @note unlike fgets, the EOL character is not returned and a whole<br>
	 * line is parsed. return NULL if first char read was EOF<br>
	 * Original signature : <code>char* url_fgets(ByteIOContext*, char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:371</i>
	 */
	@Mangling({"_Z9url_fgetsP13ByteIOContextPci", "?url_fgets@@YAPADPAUByteIOContext@@PADH@Z"}) 
	Pointer url_fgets(ByteIOContext s, ByteBuffer buf, int buf_size);
	/**
	 * Original signature : <code>void put_flush_packet(ByteIOContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:373</i>
	 */
	@Mangling({"_Z16put_flush_packetP13ByteIOContext", "?put_flush_packet@@YAXPAUByteIOContext@@@Z"}) 
	void put_flush_packet(ByteIOContext s);
	/**
	 * Reads size bytes from ByteIOContext into buf.<br>
	 * @return number of bytes read or AVERROR<br>
	 * Original signature : <code>int get_buffer(ByteIOContext*, unsigned char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:380</i><br>
	 * @deprecated use the safer methods {@link #get_buffer(avformat.ByteIOContext, java.nio.ByteBuffer, int)} and {@link #get_buffer(avformat.ByteIOContext, com.sun.jna.Pointer, int)} instead
	 */
	@Mangling({"_Z10get_bufferP13ByteIOContextPhi", "?get_buffer@@YAHPAUByteIOContext@@PAEH@Z"}) 
	@Deprecated 
	int get_buffer(ByteIOContext s, Pointer buf, int size);
	/**
	 * Reads size bytes from ByteIOContext into buf.<br>
	 * @return number of bytes read or AVERROR<br>
	 * Original signature : <code>int get_buffer(ByteIOContext*, unsigned char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:380</i>
	 */
	@Mangling({"_Z10get_bufferP13ByteIOContextPhi", "?get_buffer@@YAHPAUByteIOContext@@PAEH@Z"}) 
	int get_buffer(ByteIOContext s, ByteBuffer buf, int size);
	/**
	 * Reads size bytes from ByteIOContext into buf.<br>
	 * This reads at most 1 packet. If that is not enough fewer bytes will be<br>
	 * returned.<br>
	 * @return number of bytes read or AVERROR<br>
	 * Original signature : <code>int get_partial_buffer(ByteIOContext*, unsigned char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:388</i><br>
	 * @deprecated use the safer methods {@link #get_partial_buffer(avformat.ByteIOContext, java.nio.ByteBuffer, int)} and {@link #get_partial_buffer(avformat.ByteIOContext, com.sun.jna.Pointer, int)} instead
	 */
	@Mangling({"_Z18get_partial_bufferP13ByteIOContextPhi", "?get_partial_buffer@@YAHPAUByteIOContext@@PAEH@Z"}) 
	@Deprecated 
	int get_partial_buffer(ByteIOContext s, Pointer buf, int size);
	/**
	 * Reads size bytes from ByteIOContext into buf.<br>
	 * This reads at most 1 packet. If that is not enough fewer bytes will be<br>
	 * returned.<br>
	 * @return number of bytes read or AVERROR<br>
	 * Original signature : <code>int get_partial_buffer(ByteIOContext*, unsigned char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:388</i>
	 */
	@Mangling({"_Z18get_partial_bufferP13ByteIOContextPhi", "?get_partial_buffer@@YAHPAUByteIOContext@@PAEH@Z"}) 
	int get_partial_buffer(ByteIOContext s, ByteBuffer buf, int size);
	/**
	 * @note return 0 if EOF, so you cannot use it if EOF handling is<br>
	 * necessary<br>
	 * Original signature : <code>int get_byte(ByteIOContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:392</i>
	 */
	@Mangling({"_Z8get_byteP13ByteIOContext", "?get_byte@@YAHPAUByteIOContext@@@Z"}) 
	int get_byte(ByteIOContext s);
	/**
	 * Original signature : <code>int get_le24(ByteIOContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:393</i>
	 */
	@Mangling({"_Z8get_le24P13ByteIOContext", "?get_le24@@YAIPAUByteIOContext@@@Z"}) 
	int get_le24(ByteIOContext s);
	/**
	 * Original signature : <code>int get_le32(ByteIOContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:394</i>
	 */
	@Mangling({"_Z8get_le32P13ByteIOContext", "?get_le32@@YAIPAUByteIOContext@@@Z"}) 
	int get_le32(ByteIOContext s);
	/**
	 * Original signature : <code>uint64_t get_le64(ByteIOContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:395</i>
	 */
	@Mangling({"_Z8get_le64P13ByteIOContext", "?get_le64@@YA8uint64_tPAUByteIOContext@@@Z"}) 
	long get_le64(ByteIOContext s);
	/**
	 * Original signature : <code>int get_le16(ByteIOContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:396</i>
	 */
	@Mangling({"_Z8get_le16P13ByteIOContext", "?get_le16@@YAIPAUByteIOContext@@@Z"}) 
	int get_le16(ByteIOContext s);
	/**
	 * Original signature : <code>char* get_strz(ByteIOContext*, char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:398</i><br>
	 * @deprecated use the safer methods {@link #get_strz(avformat.ByteIOContext, java.nio.ByteBuffer, int)} and {@link #get_strz(avformat.ByteIOContext, com.sun.jna.Pointer, int)} instead
	 */
	@Mangling({"_Z8get_strzP13ByteIOContextPci", "?get_strz@@YAPADPAUByteIOContext@@PADH@Z"}) 
	@Deprecated 
	Pointer get_strz(ByteIOContext s, Pointer buf, int maxlen);
	/**
	 * Original signature : <code>char* get_strz(ByteIOContext*, char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:398</i>
	 */
	@Mangling({"_Z8get_strzP13ByteIOContextPci", "?get_strz@@YAPADPAUByteIOContext@@PADH@Z"}) 
	Pointer get_strz(ByteIOContext s, ByteBuffer buf, int maxlen);
	/**
	 * Original signature : <code>int get_be16(ByteIOContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:399</i>
	 */
	@Mangling({"_Z8get_be16P13ByteIOContext", "?get_be16@@YAIPAUByteIOContext@@@Z"}) 
	int get_be16(ByteIOContext s);
	/**
	 * Original signature : <code>int get_be24(ByteIOContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:400</i>
	 */
	@Mangling({"_Z8get_be24P13ByteIOContext", "?get_be24@@YAIPAUByteIOContext@@@Z"}) 
	int get_be24(ByteIOContext s);
	/**
	 * Original signature : <code>int get_be32(ByteIOContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:401</i>
	 */
	@Mangling({"_Z8get_be32P13ByteIOContext", "?get_be32@@YAIPAUByteIOContext@@@Z"}) 
	int get_be32(ByteIOContext s);
	/**
	 * Original signature : <code>uint64_t get_be64(ByteIOContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:402</i>
	 */
	@Mangling({"_Z8get_be64P13ByteIOContext", "?get_be64@@YA8uint64_tPAUByteIOContext@@@Z"}) 
	long get_be64(ByteIOContext s);
	/**
	 * Original signature : <code>uint64_t ff_get_v(ByteIOContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:404</i>
	 */
	@Mangling({"_Z8ff_get_vP13ByteIOContext", "?ff_get_v@@YA8uint64_tPAUByteIOContext@@@Z"}) 
	long ff_get_v(ByteIOContext bc);
	/**
	 * Creates and initializes a ByteIOContext for accessing the<br>
	 * resource referenced by the URLContext h.<br>
	 * @note When the URLContext h has been opened in read+write mode, the<br>
	 * ByteIOContext can be used only for writing.<br>
	 * * @param s Used to return the pointer to the created ByteIOContext.<br>
	 * In case of failure the pointed to value is set to NULL.<br>
	 * @return 0 in case of success, a negative value corresponding to an<br>
	 * AVERROR code in case of failure<br>
	 * Original signature : <code>int url_fdopen(ByteIOContext**, URLContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:422</i><br>
	 * @deprecated use the safer method {@link #url_fdopen(avformat.ByteIOContext.ByReference[], avformat.URLContext)} instead
	 */
	@Mangling({"_Z10url_fdopenPP13ByteIOContextP10URLContext", "?url_fdopen@@YAHPAPAUByteIOContext@@PAUURLContext@@@Z"}) 
	@Deprecated 
	int url_fdopen(PointerByReference s, URLContext h);
	/**
	 * Creates and initializes a ByteIOContext for accessing the<br>
	 * resource referenced by the URLContext h.<br>
	 * @note When the URLContext h has been opened in read+write mode, the<br>
	 * ByteIOContext can be used only for writing.<br>
	 * * @param s Used to return the pointer to the created ByteIOContext.<br>
	 * In case of failure the pointed to value is set to NULL.<br>
	 * @return 0 in case of success, a negative value corresponding to an<br>
	 * AVERROR code in case of failure<br>
	 * Original signature : <code>int url_fdopen(ByteIOContext**, URLContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:422</i>
	 */
	@Mangling({"_Z10url_fdopenPP13ByteIOContextP10URLContext", "?url_fdopen@@YAHPAPAUByteIOContext@@PAUURLContext@@@Z"}) 
	int url_fdopen(ByteIOContext.ByReference s[], URLContext h);
	/**
	 * @warning must be called before any I/O<br>
	 * Original signature : <code>int url_setbufsize(ByteIOContext*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:425</i>
	 */
	@Mangling({"_Z14url_setbufsizeP13ByteIOContexti", "?url_setbufsize@@YAHPAUByteIOContext@@H@Z"}) 
	int url_setbufsize(ByteIOContext s, int buf_size);
	/**
	 * Reset the buffer for reading or writing.<br>
	 * @note Will drop any data currently in the buffer without transmitting it.<br>
	 * @param flags URL_RDONLY to set up the buffer for reading, or URL_WRONLY<br>
	 *        to set up the buffer for writing.<br>
	 * Original signature : <code>int url_resetbuf(ByteIOContext*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:431</i>
	 */
	@Mangling({"_Z12url_resetbufP13ByteIOContexti", "?url_resetbuf@@YAHPAUByteIOContext@@H@Z"}) 
	int url_resetbuf(ByteIOContext s, int flags);
	/**
	 * Rewinds the ByteIOContext using the specified buffer containing the first buf_size bytes of the file.<br>
	 * Used after probing to avoid seeking.<br>
	 * Joins buf and s->buffer, taking any overlap into consideration.<br>
	 * @note s->buffer must overlap with buf or they can't be joined and the function fails<br>
	 * @note This function is NOT part of the public API<br>
	 * * @param s The read-only ByteIOContext to rewind<br>
	 * @param buf The probe buffer containing the first buf_size bytes of the file<br>
	 * @param buf_size The size of buf<br>
	 * @return 0 in case of success, a negative value corresponding to an<br>
	 * AVERROR code in case of failure<br>
	 * Original signature : <code>int ff_rewind_with_probe_data(ByteIOContext*, unsigned char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:447</i><br>
	 * @deprecated use the safer methods {@link #ff_rewind_with_probe_data(avformat.ByteIOContext, java.nio.ByteBuffer, int)} and {@link #ff_rewind_with_probe_data(avformat.ByteIOContext, com.sun.jna.Pointer, int)} instead
	 */
	@Mangling({"_Z25ff_rewind_with_probe_dataP13ByteIOContextPhi", "?ff_rewind_with_probe_data@@YAHPAUByteIOContext@@PAEH@Z"}) 
	@Deprecated 
	int ff_rewind_with_probe_data(ByteIOContext s, Pointer buf, int buf_size);
	/**
	 * Rewinds the ByteIOContext using the specified buffer containing the first buf_size bytes of the file.<br>
	 * Used after probing to avoid seeking.<br>
	 * Joins buf and s->buffer, taking any overlap into consideration.<br>
	 * @note s->buffer must overlap with buf or they can't be joined and the function fails<br>
	 * @note This function is NOT part of the public API<br>
	 * * @param s The read-only ByteIOContext to rewind<br>
	 * @param buf The probe buffer containing the first buf_size bytes of the file<br>
	 * @param buf_size The size of buf<br>
	 * @return 0 in case of success, a negative value corresponding to an<br>
	 * AVERROR code in case of failure<br>
	 * Original signature : <code>int ff_rewind_with_probe_data(ByteIOContext*, unsigned char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:447</i>
	 */
	@Mangling({"_Z25ff_rewind_with_probe_dataP13ByteIOContextPhi", "?ff_rewind_with_probe_data@@YAHPAUByteIOContext@@PAEH@Z"}) 
	int ff_rewind_with_probe_data(ByteIOContext s, ByteBuffer buf, int buf_size);
	/**
	 * Creates and initializes a ByteIOContext for accessing the<br>
	 * resource indicated by url.<br>
	 * @note When the resource indicated by url has been opened in<br>
	 * read+write mode, the ByteIOContext can be used only for writing.<br>
	 * * @param s Used to return the pointer to the created ByteIOContext.<br>
	 * In case of failure the pointed to value is set to NULL.<br>
	 * @param flags flags which control how the resource indicated by url<br>
	 * is to be opened<br>
	 * @return 0 in case of success, a negative value corresponding to an<br>
	 * AVERROR code in case of failure<br>
	 * Original signature : <code>int url_fopen(ByteIOContext**, const char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:462</i><br>
	 * @deprecated use the safer methods {@link #url_fopen(avformat.ByteIOContext.ByReference[], java.lang.String, int)} and {@link #url_fopen(avformat.ByteIOContext.ByReference[], com.sun.jna.Pointer, int)} instead
	 */
	@Mangling({"_Z9url_fopenPP13ByteIOContextPKci", "?url_fopen@@YAHPAPAUByteIOContext@@PADH@Z"}) 
	@Deprecated 
	int url_fopen(PointerByReference s, Pointer url, int flags);
	/**
	 * Creates and initializes a ByteIOContext for accessing the<br>
	 * resource indicated by url.<br>
	 * @note When the resource indicated by url has been opened in<br>
	 * read+write mode, the ByteIOContext can be used only for writing.<br>
	 * * @param s Used to return the pointer to the created ByteIOContext.<br>
	 * In case of failure the pointed to value is set to NULL.<br>
	 * @param flags flags which control how the resource indicated by url<br>
	 * is to be opened<br>
	 * @return 0 in case of success, a negative value corresponding to an<br>
	 * AVERROR code in case of failure<br>
	 * Original signature : <code>int url_fopen(ByteIOContext**, const char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:462</i>
	 */
	@Mangling({"_Z9url_fopenPP13ByteIOContextPKci", "?url_fopen@@YAHPAPAUByteIOContext@@PADH@Z"}) 
	int url_fopen(ByteIOContext.ByReference s[], String url, int flags);
	/**
	 * Creates and initializes a ByteIOContext for accessing the<br>
	 * resource indicated by url.<br>
	 * @note When the resource indicated by url has been opened in<br>
	 * read+write mode, the ByteIOContext can be used only for writing.<br>
	 * * @param s Used to return the pointer to the created ByteIOContext.<br>
	 * In case of failure the pointed to value is set to NULL.<br>
	 * @param flags flags which control how the resource indicated by url<br>
	 * is to be opened<br>
	 * @return 0 in case of success, a negative value corresponding to an<br>
	 * AVERROR code in case of failure<br>
	 * Original signature : <code>int url_fopen(ByteIOContext**, const char*, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:462</i>
	 */
	@Mangling({"_Z9url_fopenPP13ByteIOContextPKci", "?url_fopen@@YAHPAPAUByteIOContext@@PADH@Z"}) 
	int url_fopen(ByteIOContext.ByReference s[], Pointer url, int flags);
	/**
	 * Original signature : <code>int url_fclose(ByteIOContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:464</i>
	 */
	@Mangling({"_Z10url_fcloseP13ByteIOContext", "?url_fclose@@YAHPAUByteIOContext@@@Z"}) 
	int url_fclose(ByteIOContext s);
	/**
	 * Original signature : <code>URLContext* url_fileno(ByteIOContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:465</i>
	 */
	@Mangling({"_Z10url_filenoP13ByteIOContext", "?url_fileno@@YAPAUURLContext@@PAUByteIOContext@@@Z"}) 
	URLContext url_fileno(ByteIOContext s);
	/**
	 * Return the maximum packet size associated to packetized buffered file<br>
	 * handle. If the file is not packetized (stream like http or file on<br>
	 * disk), then 0 is returned.<br>
	 * * @param s buffered file handle<br>
	 * @return maximum packet size in bytes<br>
	 * Original signature : <code>int url_fget_max_packet_size(ByteIOContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:475</i>
	 */
	@Mangling({"_Z24url_fget_max_packet_sizeP13ByteIOContext", "?url_fget_max_packet_size@@YAHPAUByteIOContext@@@Z"}) 
	int url_fget_max_packet_size(ByteIOContext s);
	/**
	 * Original signature : <code>int url_open_buf(ByteIOContext**, uint8_t*, int, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:477</i><br>
	 * @deprecated use the safer methods {@link #url_open_buf(avformat.ByteIOContext.ByReference[], java.nio.ByteBuffer, int, int)} and {@link #url_open_buf(avformat.ByteIOContext.ByReference[], com.sun.jna.Pointer, int, int)} instead
	 */
	@Mangling({"_Z12url_open_bufPP13ByteIOContextP7uint8_tii", "?url_open_buf@@YAHPAPAUByteIOContext@@PA7uint8_tHH@Z"}) 
	@Deprecated 
	int url_open_buf(PointerByReference s, Pointer buf, int buf_size, int flags);
	/**
	 * Original signature : <code>int url_open_buf(ByteIOContext**, uint8_t*, int, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:477</i>
	 */
	@Mangling({"_Z12url_open_bufPP13ByteIOContextP7uint8_tii", "?url_open_buf@@YAHPAPAUByteIOContext@@PA7uint8_tHH@Z"}) 
	int url_open_buf(ByteIOContext.ByReference s[], ByteBuffer buf, int buf_size, int flags);
	/**
	 * Original signature : <code>int url_open_buf(ByteIOContext**, uint8_t*, int, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:477</i>
	 */
	@Mangling({"_Z12url_open_bufPP13ByteIOContextP7uint8_tii", "?url_open_buf@@YAHPAPAUByteIOContext@@PA7uint8_tHH@Z"}) 
	int url_open_buf(ByteIOContext.ByReference s[], Pointer buf, int buf_size, int flags);
	/**
	 * return the written or read size<br>
	 * Original signature : <code>int url_close_buf(ByteIOContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:480</i>
	 */
	@Mangling({"_Z13url_close_bufP13ByteIOContext", "?url_close_buf@@YAHPAUByteIOContext@@@Z"}) 
	int url_close_buf(ByteIOContext s);
	/**
	 * Open a write only memory stream.<br>
	 * * @param s new IO context<br>
	 * @return zero if no error.<br>
	 * Original signature : <code>int url_open_dyn_buf(ByteIOContext**)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:488</i><br>
	 * @deprecated use the safer method {@link #url_open_dyn_buf(avformat.ByteIOContext.ByReference[])} instead
	 */
	@Mangling({"_Z16url_open_dyn_bufPP13ByteIOContext", "?url_open_dyn_buf@@YAHPAPAUByteIOContext@@@Z"}) 
	@Deprecated 
	int url_open_dyn_buf(PointerByReference s);
	/**
	 * Open a write only memory stream.<br>
	 * * @param s new IO context<br>
	 * @return zero if no error.<br>
	 * Original signature : <code>int url_open_dyn_buf(ByteIOContext**)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:488</i>
	 */
	@Mangling({"_Z16url_open_dyn_bufPP13ByteIOContext", "?url_open_dyn_buf@@YAHPAPAUByteIOContext@@@Z"}) 
	int url_open_dyn_buf(ByteIOContext.ByReference s[]);
	/**
	 * Open a write only packetized memory stream with a maximum packet<br>
	 * size of 'max_packet_size'.  The stream is stored in a memory buffer<br>
	 * with a big endian 4 byte header giving the packet size in bytes.<br>
	 * * @param s new IO context<br>
	 * @param max_packet_size maximum packet size (must be > 0)<br>
	 * @return zero if no error.<br>
	 * Original signature : <code>int url_open_dyn_packet_buf(ByteIOContext**, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:499</i><br>
	 * @deprecated use the safer method {@link #url_open_dyn_packet_buf(avformat.ByteIOContext.ByReference[], int)} instead
	 */
	@Mangling({"_Z23url_open_dyn_packet_bufPP13ByteIOContexti", "?url_open_dyn_packet_buf@@YAHPAPAUByteIOContext@@H@Z"}) 
	@Deprecated 
	int url_open_dyn_packet_buf(PointerByReference s, int max_packet_size);
	/**
	 * Open a write only packetized memory stream with a maximum packet<br>
	 * size of 'max_packet_size'.  The stream is stored in a memory buffer<br>
	 * with a big endian 4 byte header giving the packet size in bytes.<br>
	 * * @param s new IO context<br>
	 * @param max_packet_size maximum packet size (must be > 0)<br>
	 * @return zero if no error.<br>
	 * Original signature : <code>int url_open_dyn_packet_buf(ByteIOContext**, int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:499</i>
	 */
	@Mangling({"_Z23url_open_dyn_packet_bufPP13ByteIOContexti", "?url_open_dyn_packet_buf@@YAHPAPAUByteIOContext@@H@Z"}) 
	int url_open_dyn_packet_buf(ByteIOContext.ByReference s[], int max_packet_size);
	/**
	 * Return the written size and a pointer to the buffer. The buffer<br>
	 *  must be freed with av_free().<br>
	 * @param s IO context<br>
	 * @param pbuffer pointer to a byte buffer<br>
	 * @return the length of the byte buffer<br>
	 * Original signature : <code>int url_close_dyn_buf(ByteIOContext*, uint8_t**)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:508</i>
	 */
	@Mangling({"_Z17url_close_dyn_bufP13ByteIOContextPP7uint8_t", "?url_close_dyn_buf@@YAHPAUByteIOContext@@PAPA7uint8_t@Z"}) 
	int url_close_dyn_buf(ByteIOContext s, PointerByReference pbuffer);
	/**
	 * Original signature : <code>ff_crc04C11DB7_update(unsigned long, const uint8_t*, unsigned int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:510</i><br>
	 * @deprecated use the safer methods {@link #ff_crc04C11DB7_update(com.sun.jna.NativeLong, byte[], int)} and {@link #ff_crc04C11DB7_update(com.sun.jna.NativeLong, com.sun.jna.Pointer, int)} instead
	 */
	@Mangling({"_Z21ff_crc04C11DB7_updatemPK7uint8_tj", "?ff_crc04C11DB7_update@@YAXKPA7uint8_tI@Z"}) 
	@Deprecated 
	int ff_crc04C11DB7_update(NativeLong checksum, Pointer buf, int len);
	/**
	 * Original signature : <code>ff_crc04C11DB7_update(unsigned long, const uint8_t*, unsigned int)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:510</i>
	 */
	@Mangling({"_Z21ff_crc04C11DB7_updatemPK7uint8_tj", "?ff_crc04C11DB7_update@@YAXKPA7uint8_tI@Z"}) 
	int ff_crc04C11DB7_update(NativeLong checksum, byte buf[], int len);
	/**
	 * Original signature : <code>get_checksum(ByteIOContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:512</i>
	 */
	@Mangling({"_Z12get_checksumP13ByteIOContext", "?get_checksum@@YAXPAUByteIOContext@@@Z"}) 
	int get_checksum(ByteIOContext s);
	/**
	 * Original signature : <code>void init_checksum(ByteIOContext*, init_checksum_arg1_update_checksum_callback, unsigned long)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:513</i>
	 */
	@Mangling({"_Z13init_checksumP13ByteIOContextPFmmPK7uint8_tjEm", "?init_checksum@@YAXPAUByteIOContext@@PFKKPA7uint8_tI@EK@Z"}) 
	void init_checksum(ByteIOContext s, AvformatLibrary.init_checksum_arg1_update_checksum_callback arg1, NativeLong checksum);
	/**
	 * udp.c<br>
	 * Original signature : <code>int udp_set_remote_url(URLContext*, const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:518</i><br>
	 * @deprecated use the safer methods {@link #udp_set_remote_url(avformat.URLContext, java.lang.String)} and {@link #udp_set_remote_url(avformat.URLContext, com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z18udp_set_remote_urlP10URLContextPKc", "?udp_set_remote_url@@YAHPAUURLContext@@PAD@Z"}) 
	@Deprecated 
	int udp_set_remote_url(URLContext h, Pointer uri);
	/**
	 * udp.c<br>
	 * Original signature : <code>int udp_set_remote_url(URLContext*, const char*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:518</i>
	 */
	@Mangling({"_Z18udp_set_remote_urlP10URLContextPKc", "?udp_set_remote_url@@YAHPAUURLContext@@PAD@Z"}) 
	int udp_set_remote_url(URLContext h, String uri);
	/**
	 * Original signature : <code>int udp_get_local_port(URLContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:519</i>
	 */
	@Mangling({"_Z18udp_get_local_portP10URLContext", "?udp_get_local_port@@YAHPAUURLContext@@@Z"}) 
	int udp_get_local_port(URLContext h);
	/**
	 * Original signature : <code>int udp_get_file_handle(URLContext*)</code><br>
	 * <i>native declaration : src/main/headers/libavformat/avio.h:521</i>
	 */
	@Mangling({"_Z19udp_get_file_handleP10URLContext", "?udp_get_file_handle@@YAHPAUURLContext@@@Z"}) 
	int udp_get_file_handle(URLContext h);
	public static final GlobalStruct<AVInputFormat > first_iformat = new GlobalStruct<AVInputFormat >(avformat.AvformatLibrary.JNA_NATIVE_LIB, avformat.AVInputFormat.class, "first_iformat");
	public static final GlobalStruct<AVOutputFormat > first_oformat = new GlobalStruct<AVOutputFormat >(avformat.AvformatLibrary.JNA_NATIVE_LIB, avformat.AVOutputFormat.class, "first_oformat");
	public static final GlobalStruct<URLProtocol > first_protocol = new GlobalStruct<URLProtocol >(avformat.AvformatLibrary.JNA_NATIVE_LIB, avformat.URLProtocol.class, "first_protocol");
	public static final class url_interrupt_cb {
		private static PointerByReference url_interrupt_cb;
		public static synchronized PointerByReference get() {
			if (url_interrupt_cb == null) {
				url_interrupt_cb = new PointerByReference();
				url_interrupt_cb.setPointer(avformat.AvformatLibrary.JNA_NATIVE_LIB.getGlobalVariableAddress("url_interrupt_cb"));
			}
			return url_interrupt_cb;
		}
	};
	/// Undefined type
	public static interface AVMetadataConv {
		
	};
	/// Undefined type
	public static interface AVCodecTag {
		
	};
	/// Undefined type
	public static interface _IO_FILE {
		
	};
	/// Undefined type
	public static interface checksum {
		
	};
	/// Undefined type
	public static interface AVMetadata {
		
	};
}
